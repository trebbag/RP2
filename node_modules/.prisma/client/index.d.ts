
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Encounter
 * 
 */
export type Encounter = $Result.DefaultSelection<Prisma.$EncounterPayload>
/**
 * Model Note
 * 
 */
export type Note = $Result.DefaultSelection<Prisma.$NotePayload>
/**
 * Model NoteVersion
 * 
 */
export type NoteVersion = $Result.DefaultSelection<Prisma.$NoteVersionPayload>
/**
 * Model TranscriptSegment
 * 
 */
export type TranscriptSegment = $Result.DefaultSelection<Prisma.$TranscriptSegmentPayload>
/**
 * Model ChartAsset
 * 
 */
export type ChartAsset = $Result.DefaultSelection<Prisma.$ChartAssetPayload>
/**
 * Model SuggestionGeneration
 * 
 */
export type SuggestionGeneration = $Result.DefaultSelection<Prisma.$SuggestionGenerationPayload>
/**
 * Model CodeSuggestion
 * 
 */
export type CodeSuggestion = $Result.DefaultSelection<Prisma.$CodeSuggestionPayload>
/**
 * Model CodeSelection
 * 
 */
export type CodeSelection = $Result.DefaultSelection<Prisma.$CodeSelectionPayload>
/**
 * Model ComplianceIssue
 * 
 */
export type ComplianceIssue = $Result.DefaultSelection<Prisma.$ComplianceIssuePayload>
/**
 * Model WizardRun
 * 
 */
export type WizardRun = $Result.DefaultSelection<Prisma.$WizardRunPayload>
/**
 * Model WizardStepState
 * 
 */
export type WizardStepState = $Result.DefaultSelection<Prisma.$WizardStepStatePayload>
/**
 * Model ExportArtifact
 * 
 */
export type ExportArtifact = $Result.DefaultSelection<Prisma.$ExportArtifactPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model AuthSession
 * 
 */
export type AuthSession = $Result.DefaultSelection<Prisma.$AuthSessionPayload>
/**
 * Model DispatchJob
 * 
 */
export type DispatchJob = $Result.DefaultSelection<Prisma.$DispatchJobPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  MA: 'MA',
  CLINICIAN: 'CLINICIAN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AppointmentStatus: {
  SCHEDULED: 'SCHEDULED',
  CHECKED_IN: 'CHECKED_IN',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  NO_SHOW: 'NO_SHOW',
  CANCELLED: 'CANCELLED'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const AppointmentPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type AppointmentPriority = (typeof AppointmentPriority)[keyof typeof AppointmentPriority]


export const EncounterStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  STOPPED: 'STOPPED',
  FINALIZED: 'FINALIZED'
};

export type EncounterStatus = (typeof EncounterStatus)[keyof typeof EncounterStatus]


export const NoteStatus: {
  DRAFT_HIDDEN: 'DRAFT_HIDDEN',
  DRAFT_ACTIVE: 'DRAFT_ACTIVE',
  FINAL: 'FINAL'
};

export type NoteStatus = (typeof NoteStatus)[keyof typeof NoteStatus]


export const NoteVisibility: {
  HIDDEN: 'HIDDEN',
  VISIBLE: 'VISIBLE',
  LOCKED: 'LOCKED'
};

export type NoteVisibility = (typeof NoteVisibility)[keyof typeof NoteVisibility]


export const TranscriptSource: {
  LIVE_UPLOAD: 'LIVE_UPLOAD',
  MANUAL: 'MANUAL'
};

export type TranscriptSource = (typeof TranscriptSource)[keyof typeof TranscriptSource]


export const SuggestionCategory: {
  CODE: 'CODE',
  DIAGNOSIS: 'DIAGNOSIS',
  DIFFERENTIAL: 'DIFFERENTIAL',
  PREVENTION: 'PREVENTION'
};

export type SuggestionCategory = (typeof SuggestionCategory)[keyof typeof SuggestionCategory]


export const SuggestionStatus: {
  SUGGESTED: 'SUGGESTED',
  SELECTED: 'SELECTED',
  REJECTED: 'REJECTED',
  REMOVED: 'REMOVED'
};

export type SuggestionStatus = (typeof SuggestionStatus)[keyof typeof SuggestionStatus]


export const SelectionAction: {
  KEEP: 'KEEP',
  REMOVE: 'REMOVE',
  MOVE_TO_DIAGNOSIS: 'MOVE_TO_DIAGNOSIS',
  MOVE_TO_DIFFERENTIAL: 'MOVE_TO_DIFFERENTIAL',
  ADD_FROM_SUGGESTION: 'ADD_FROM_SUGGESTION'
};

export type SelectionAction = (typeof SelectionAction)[keyof typeof SelectionAction]


export const ComplianceSeverity: {
  CRITICAL: 'CRITICAL',
  WARNING: 'WARNING',
  INFO: 'INFO'
};

export type ComplianceSeverity = (typeof ComplianceSeverity)[keyof typeof ComplianceSeverity]


export const ComplianceStatus: {
  ACTIVE: 'ACTIVE',
  DISMISSED: 'DISMISSED',
  RESOLVED: 'RESOLVED'
};

export type ComplianceStatus = (typeof ComplianceStatus)[keyof typeof ComplianceStatus]


export const WizardRunStatus: {
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type WizardRunStatus = (typeof WizardRunStatus)[keyof typeof WizardRunStatus]


export const WizardStep: {
  STEP1_CODE_REVIEW: 'STEP1_CODE_REVIEW',
  STEP2_SUGGESTION_REVIEW: 'STEP2_SUGGESTION_REVIEW',
  STEP3_COMPOSE: 'STEP3_COMPOSE',
  STEP4_COMPARE_EDIT: 'STEP4_COMPARE_EDIT',
  STEP5_BILLING_ATTEST: 'STEP5_BILLING_ATTEST',
  STEP6_SIGN_DISPATCH: 'STEP6_SIGN_DISPATCH'
};

export type WizardStep = (typeof WizardStep)[keyof typeof WizardStep]


export const WizardStepStatus: {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  BLOCKED: 'BLOCKED'
};

export type WizardStepStatus = (typeof WizardStepStatus)[keyof typeof WizardStepStatus]


export const ArtifactType: {
  NOTE_PDF: 'NOTE_PDF',
  PATIENT_SUMMARY_PDF: 'PATIENT_SUMMARY_PDF',
  TRACE_JSON: 'TRACE_JSON',
  STRUCTURED_CHART_JSON: 'STRUCTURED_CHART_JSON'
};

export type ArtifactType = (typeof ArtifactType)[keyof typeof ArtifactType]


export const DispatchTarget: {
  FHIR_R4: 'FHIR_R4',
  HL7_V2: 'HL7_V2',
  VENDOR_API: 'VENDOR_API',
  NONE: 'NONE'
};

export type DispatchTarget = (typeof DispatchTarget)[keyof typeof DispatchTarget]


export const DispatchStatus: {
  PENDING: 'PENDING',
  RETRYING: 'RETRYING',
  DISPATCHED: 'DISPATCHED',
  FAILED: 'FAILED',
  DEAD_LETTER: 'DEAD_LETTER'
};

export type DispatchStatus = (typeof DispatchStatus)[keyof typeof DispatchStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type AppointmentPriority = $Enums.AppointmentPriority

export const AppointmentPriority: typeof $Enums.AppointmentPriority

export type EncounterStatus = $Enums.EncounterStatus

export const EncounterStatus: typeof $Enums.EncounterStatus

export type NoteStatus = $Enums.NoteStatus

export const NoteStatus: typeof $Enums.NoteStatus

export type NoteVisibility = $Enums.NoteVisibility

export const NoteVisibility: typeof $Enums.NoteVisibility

export type TranscriptSource = $Enums.TranscriptSource

export const TranscriptSource: typeof $Enums.TranscriptSource

export type SuggestionCategory = $Enums.SuggestionCategory

export const SuggestionCategory: typeof $Enums.SuggestionCategory

export type SuggestionStatus = $Enums.SuggestionStatus

export const SuggestionStatus: typeof $Enums.SuggestionStatus

export type SelectionAction = $Enums.SelectionAction

export const SelectionAction: typeof $Enums.SelectionAction

export type ComplianceSeverity = $Enums.ComplianceSeverity

export const ComplianceSeverity: typeof $Enums.ComplianceSeverity

export type ComplianceStatus = $Enums.ComplianceStatus

export const ComplianceStatus: typeof $Enums.ComplianceStatus

export type WizardRunStatus = $Enums.WizardRunStatus

export const WizardRunStatus: typeof $Enums.WizardRunStatus

export type WizardStep = $Enums.WizardStep

export const WizardStep: typeof $Enums.WizardStep

export type WizardStepStatus = $Enums.WizardStepStatus

export const WizardStepStatus: typeof $Enums.WizardStepStatus

export type ArtifactType = $Enums.ArtifactType

export const ArtifactType: typeof $Enums.ArtifactType

export type DispatchTarget = $Enums.DispatchTarget

export const DispatchTarget: typeof $Enums.DispatchTarget

export type DispatchStatus = $Enums.DispatchStatus

export const DispatchStatus: typeof $Enums.DispatchStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encounter`: Exposes CRUD operations for the **Encounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encounters
    * const encounters = await prisma.encounter.findMany()
    * ```
    */
  get encounter(): Prisma.EncounterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.NoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.noteVersion`: Exposes CRUD operations for the **NoteVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoteVersions
    * const noteVersions = await prisma.noteVersion.findMany()
    * ```
    */
  get noteVersion(): Prisma.NoteVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transcriptSegment`: Exposes CRUD operations for the **TranscriptSegment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TranscriptSegments
    * const transcriptSegments = await prisma.transcriptSegment.findMany()
    * ```
    */
  get transcriptSegment(): Prisma.TranscriptSegmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chartAsset`: Exposes CRUD operations for the **ChartAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChartAssets
    * const chartAssets = await prisma.chartAsset.findMany()
    * ```
    */
  get chartAsset(): Prisma.ChartAssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.suggestionGeneration`: Exposes CRUD operations for the **SuggestionGeneration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuggestionGenerations
    * const suggestionGenerations = await prisma.suggestionGeneration.findMany()
    * ```
    */
  get suggestionGeneration(): Prisma.SuggestionGenerationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.codeSuggestion`: Exposes CRUD operations for the **CodeSuggestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeSuggestions
    * const codeSuggestions = await prisma.codeSuggestion.findMany()
    * ```
    */
  get codeSuggestion(): Prisma.CodeSuggestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.codeSelection`: Exposes CRUD operations for the **CodeSelection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeSelections
    * const codeSelections = await prisma.codeSelection.findMany()
    * ```
    */
  get codeSelection(): Prisma.CodeSelectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complianceIssue`: Exposes CRUD operations for the **ComplianceIssue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplianceIssues
    * const complianceIssues = await prisma.complianceIssue.findMany()
    * ```
    */
  get complianceIssue(): Prisma.ComplianceIssueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wizardRun`: Exposes CRUD operations for the **WizardRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WizardRuns
    * const wizardRuns = await prisma.wizardRun.findMany()
    * ```
    */
  get wizardRun(): Prisma.WizardRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wizardStepState`: Exposes CRUD operations for the **WizardStepState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WizardStepStates
    * const wizardStepStates = await prisma.wizardStepState.findMany()
    * ```
    */
  get wizardStepState(): Prisma.WizardStepStateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exportArtifact`: Exposes CRUD operations for the **ExportArtifact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExportArtifacts
    * const exportArtifacts = await prisma.exportArtifact.findMany()
    * ```
    */
  get exportArtifact(): Prisma.ExportArtifactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.authSession`: Exposes CRUD operations for the **AuthSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthSessions
    * const authSessions = await prisma.authSession.findMany()
    * ```
    */
  get authSession(): Prisma.AuthSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dispatchJob`: Exposes CRUD operations for the **DispatchJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DispatchJobs
    * const dispatchJobs = await prisma.dispatchJob.findMany()
    * ```
    */
  get dispatchJob(): Prisma.DispatchJobDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserSettings: 'UserSettings',
    Patient: 'Patient',
    Appointment: 'Appointment',
    Encounter: 'Encounter',
    Note: 'Note',
    NoteVersion: 'NoteVersion',
    TranscriptSegment: 'TranscriptSegment',
    ChartAsset: 'ChartAsset',
    SuggestionGeneration: 'SuggestionGeneration',
    CodeSuggestion: 'CodeSuggestion',
    CodeSelection: 'CodeSelection',
    ComplianceIssue: 'ComplianceIssue',
    WizardRun: 'WizardRun',
    WizardStepState: 'WizardStepState',
    ExportArtifact: 'ExportArtifact',
    AuditLog: 'AuditLog',
    AuthSession: 'AuthSession',
    DispatchJob: 'DispatchJob'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userSettings" | "patient" | "appointment" | "encounter" | "note" | "noteVersion" | "transcriptSegment" | "chartAsset" | "suggestionGeneration" | "codeSuggestion" | "codeSelection" | "complianceIssue" | "wizardRun" | "wizardStepState" | "exportArtifact" | "auditLog" | "authSession" | "dispatchJob"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Encounter: {
        payload: Prisma.$EncounterPayload<ExtArgs>
        fields: Prisma.EncounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findFirst: {
            args: Prisma.EncounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findMany: {
            args: Prisma.EncounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          create: {
            args: Prisma.EncounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          createMany: {
            args: Prisma.EncounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          delete: {
            args: Prisma.EncounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          update: {
            args: Prisma.EncounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          deleteMany: {
            args: Prisma.EncounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncounterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          upsert: {
            args: Prisma.EncounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          aggregate: {
            args: Prisma.EncounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounter>
          }
          groupBy: {
            args: Prisma.EncounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterCountAggregateOutputType> | number
          }
        }
      }
      Note: {
        payload: Prisma.$NotePayload<ExtArgs>
        fields: Prisma.NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findFirst: {
            args: Prisma.NoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findMany: {
            args: Prisma.NoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          create: {
            args: Prisma.NoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          createMany: {
            args: Prisma.NoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          delete: {
            args: Prisma.NoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          update: {
            args: Prisma.NoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          deleteMany: {
            args: Prisma.NoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          upsert: {
            args: Prisma.NoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote>
          }
          groupBy: {
            args: Prisma.NoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteCountArgs<ExtArgs>
            result: $Utils.Optional<NoteCountAggregateOutputType> | number
          }
        }
      }
      NoteVersion: {
        payload: Prisma.$NoteVersionPayload<ExtArgs>
        fields: Prisma.NoteVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteVersionPayload>
          }
          findFirst: {
            args: Prisma.NoteVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteVersionPayload>
          }
          findMany: {
            args: Prisma.NoteVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteVersionPayload>[]
          }
          create: {
            args: Prisma.NoteVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteVersionPayload>
          }
          createMany: {
            args: Prisma.NoteVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoteVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteVersionPayload>[]
          }
          delete: {
            args: Prisma.NoteVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteVersionPayload>
          }
          update: {
            args: Prisma.NoteVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteVersionPayload>
          }
          deleteMany: {
            args: Prisma.NoteVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NoteVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteVersionPayload>[]
          }
          upsert: {
            args: Prisma.NoteVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteVersionPayload>
          }
          aggregate: {
            args: Prisma.NoteVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoteVersion>
          }
          groupBy: {
            args: Prisma.NoteVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteVersionCountArgs<ExtArgs>
            result: $Utils.Optional<NoteVersionCountAggregateOutputType> | number
          }
        }
      }
      TranscriptSegment: {
        payload: Prisma.$TranscriptSegmentPayload<ExtArgs>
        fields: Prisma.TranscriptSegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranscriptSegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranscriptSegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>
          }
          findFirst: {
            args: Prisma.TranscriptSegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranscriptSegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>
          }
          findMany: {
            args: Prisma.TranscriptSegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>[]
          }
          create: {
            args: Prisma.TranscriptSegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>
          }
          createMany: {
            args: Prisma.TranscriptSegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TranscriptSegmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>[]
          }
          delete: {
            args: Prisma.TranscriptSegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>
          }
          update: {
            args: Prisma.TranscriptSegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>
          }
          deleteMany: {
            args: Prisma.TranscriptSegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranscriptSegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TranscriptSegmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>[]
          }
          upsert: {
            args: Prisma.TranscriptSegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptSegmentPayload>
          }
          aggregate: {
            args: Prisma.TranscriptSegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranscriptSegment>
          }
          groupBy: {
            args: Prisma.TranscriptSegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranscriptSegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranscriptSegmentCountArgs<ExtArgs>
            result: $Utils.Optional<TranscriptSegmentCountAggregateOutputType> | number
          }
        }
      }
      ChartAsset: {
        payload: Prisma.$ChartAssetPayload<ExtArgs>
        fields: Prisma.ChartAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChartAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChartAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartAssetPayload>
          }
          findFirst: {
            args: Prisma.ChartAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChartAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartAssetPayload>
          }
          findMany: {
            args: Prisma.ChartAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartAssetPayload>[]
          }
          create: {
            args: Prisma.ChartAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartAssetPayload>
          }
          createMany: {
            args: Prisma.ChartAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChartAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartAssetPayload>[]
          }
          delete: {
            args: Prisma.ChartAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartAssetPayload>
          }
          update: {
            args: Prisma.ChartAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartAssetPayload>
          }
          deleteMany: {
            args: Prisma.ChartAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChartAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChartAssetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartAssetPayload>[]
          }
          upsert: {
            args: Prisma.ChartAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartAssetPayload>
          }
          aggregate: {
            args: Prisma.ChartAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChartAsset>
          }
          groupBy: {
            args: Prisma.ChartAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChartAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChartAssetCountArgs<ExtArgs>
            result: $Utils.Optional<ChartAssetCountAggregateOutputType> | number
          }
        }
      }
      SuggestionGeneration: {
        payload: Prisma.$SuggestionGenerationPayload<ExtArgs>
        fields: Prisma.SuggestionGenerationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuggestionGenerationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionGenerationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuggestionGenerationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionGenerationPayload>
          }
          findFirst: {
            args: Prisma.SuggestionGenerationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionGenerationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuggestionGenerationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionGenerationPayload>
          }
          findMany: {
            args: Prisma.SuggestionGenerationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionGenerationPayload>[]
          }
          create: {
            args: Prisma.SuggestionGenerationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionGenerationPayload>
          }
          createMany: {
            args: Prisma.SuggestionGenerationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuggestionGenerationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionGenerationPayload>[]
          }
          delete: {
            args: Prisma.SuggestionGenerationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionGenerationPayload>
          }
          update: {
            args: Prisma.SuggestionGenerationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionGenerationPayload>
          }
          deleteMany: {
            args: Prisma.SuggestionGenerationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuggestionGenerationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SuggestionGenerationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionGenerationPayload>[]
          }
          upsert: {
            args: Prisma.SuggestionGenerationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionGenerationPayload>
          }
          aggregate: {
            args: Prisma.SuggestionGenerationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuggestionGeneration>
          }
          groupBy: {
            args: Prisma.SuggestionGenerationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuggestionGenerationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuggestionGenerationCountArgs<ExtArgs>
            result: $Utils.Optional<SuggestionGenerationCountAggregateOutputType> | number
          }
        }
      }
      CodeSuggestion: {
        payload: Prisma.$CodeSuggestionPayload<ExtArgs>
        fields: Prisma.CodeSuggestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CodeSuggestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSuggestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CodeSuggestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSuggestionPayload>
          }
          findFirst: {
            args: Prisma.CodeSuggestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSuggestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CodeSuggestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSuggestionPayload>
          }
          findMany: {
            args: Prisma.CodeSuggestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSuggestionPayload>[]
          }
          create: {
            args: Prisma.CodeSuggestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSuggestionPayload>
          }
          createMany: {
            args: Prisma.CodeSuggestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CodeSuggestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSuggestionPayload>[]
          }
          delete: {
            args: Prisma.CodeSuggestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSuggestionPayload>
          }
          update: {
            args: Prisma.CodeSuggestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSuggestionPayload>
          }
          deleteMany: {
            args: Prisma.CodeSuggestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CodeSuggestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CodeSuggestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSuggestionPayload>[]
          }
          upsert: {
            args: Prisma.CodeSuggestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSuggestionPayload>
          }
          aggregate: {
            args: Prisma.CodeSuggestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCodeSuggestion>
          }
          groupBy: {
            args: Prisma.CodeSuggestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CodeSuggestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CodeSuggestionCountArgs<ExtArgs>
            result: $Utils.Optional<CodeSuggestionCountAggregateOutputType> | number
          }
        }
      }
      CodeSelection: {
        payload: Prisma.$CodeSelectionPayload<ExtArgs>
        fields: Prisma.CodeSelectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CodeSelectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSelectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CodeSelectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSelectionPayload>
          }
          findFirst: {
            args: Prisma.CodeSelectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSelectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CodeSelectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSelectionPayload>
          }
          findMany: {
            args: Prisma.CodeSelectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSelectionPayload>[]
          }
          create: {
            args: Prisma.CodeSelectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSelectionPayload>
          }
          createMany: {
            args: Prisma.CodeSelectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CodeSelectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSelectionPayload>[]
          }
          delete: {
            args: Prisma.CodeSelectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSelectionPayload>
          }
          update: {
            args: Prisma.CodeSelectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSelectionPayload>
          }
          deleteMany: {
            args: Prisma.CodeSelectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CodeSelectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CodeSelectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSelectionPayload>[]
          }
          upsert: {
            args: Prisma.CodeSelectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSelectionPayload>
          }
          aggregate: {
            args: Prisma.CodeSelectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCodeSelection>
          }
          groupBy: {
            args: Prisma.CodeSelectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CodeSelectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CodeSelectionCountArgs<ExtArgs>
            result: $Utils.Optional<CodeSelectionCountAggregateOutputType> | number
          }
        }
      }
      ComplianceIssue: {
        payload: Prisma.$ComplianceIssuePayload<ExtArgs>
        fields: Prisma.ComplianceIssueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplianceIssueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceIssuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplianceIssueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceIssuePayload>
          }
          findFirst: {
            args: Prisma.ComplianceIssueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceIssuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplianceIssueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceIssuePayload>
          }
          findMany: {
            args: Prisma.ComplianceIssueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceIssuePayload>[]
          }
          create: {
            args: Prisma.ComplianceIssueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceIssuePayload>
          }
          createMany: {
            args: Prisma.ComplianceIssueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplianceIssueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceIssuePayload>[]
          }
          delete: {
            args: Prisma.ComplianceIssueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceIssuePayload>
          }
          update: {
            args: Prisma.ComplianceIssueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceIssuePayload>
          }
          deleteMany: {
            args: Prisma.ComplianceIssueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplianceIssueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComplianceIssueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceIssuePayload>[]
          }
          upsert: {
            args: Prisma.ComplianceIssueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceIssuePayload>
          }
          aggregate: {
            args: Prisma.ComplianceIssueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplianceIssue>
          }
          groupBy: {
            args: Prisma.ComplianceIssueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplianceIssueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplianceIssueCountArgs<ExtArgs>
            result: $Utils.Optional<ComplianceIssueCountAggregateOutputType> | number
          }
        }
      }
      WizardRun: {
        payload: Prisma.$WizardRunPayload<ExtArgs>
        fields: Prisma.WizardRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WizardRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WizardRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardRunPayload>
          }
          findFirst: {
            args: Prisma.WizardRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WizardRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardRunPayload>
          }
          findMany: {
            args: Prisma.WizardRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardRunPayload>[]
          }
          create: {
            args: Prisma.WizardRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardRunPayload>
          }
          createMany: {
            args: Prisma.WizardRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WizardRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardRunPayload>[]
          }
          delete: {
            args: Prisma.WizardRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardRunPayload>
          }
          update: {
            args: Prisma.WizardRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardRunPayload>
          }
          deleteMany: {
            args: Prisma.WizardRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WizardRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WizardRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardRunPayload>[]
          }
          upsert: {
            args: Prisma.WizardRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardRunPayload>
          }
          aggregate: {
            args: Prisma.WizardRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWizardRun>
          }
          groupBy: {
            args: Prisma.WizardRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<WizardRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.WizardRunCountArgs<ExtArgs>
            result: $Utils.Optional<WizardRunCountAggregateOutputType> | number
          }
        }
      }
      WizardStepState: {
        payload: Prisma.$WizardStepStatePayload<ExtArgs>
        fields: Prisma.WizardStepStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WizardStepStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardStepStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WizardStepStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardStepStatePayload>
          }
          findFirst: {
            args: Prisma.WizardStepStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardStepStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WizardStepStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardStepStatePayload>
          }
          findMany: {
            args: Prisma.WizardStepStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardStepStatePayload>[]
          }
          create: {
            args: Prisma.WizardStepStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardStepStatePayload>
          }
          createMany: {
            args: Prisma.WizardStepStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WizardStepStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardStepStatePayload>[]
          }
          delete: {
            args: Prisma.WizardStepStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardStepStatePayload>
          }
          update: {
            args: Prisma.WizardStepStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardStepStatePayload>
          }
          deleteMany: {
            args: Prisma.WizardStepStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WizardStepStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WizardStepStateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardStepStatePayload>[]
          }
          upsert: {
            args: Prisma.WizardStepStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WizardStepStatePayload>
          }
          aggregate: {
            args: Prisma.WizardStepStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWizardStepState>
          }
          groupBy: {
            args: Prisma.WizardStepStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<WizardStepStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.WizardStepStateCountArgs<ExtArgs>
            result: $Utils.Optional<WizardStepStateCountAggregateOutputType> | number
          }
        }
      }
      ExportArtifact: {
        payload: Prisma.$ExportArtifactPayload<ExtArgs>
        fields: Prisma.ExportArtifactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExportArtifactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportArtifactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExportArtifactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportArtifactPayload>
          }
          findFirst: {
            args: Prisma.ExportArtifactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportArtifactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExportArtifactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportArtifactPayload>
          }
          findMany: {
            args: Prisma.ExportArtifactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportArtifactPayload>[]
          }
          create: {
            args: Prisma.ExportArtifactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportArtifactPayload>
          }
          createMany: {
            args: Prisma.ExportArtifactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExportArtifactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportArtifactPayload>[]
          }
          delete: {
            args: Prisma.ExportArtifactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportArtifactPayload>
          }
          update: {
            args: Prisma.ExportArtifactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportArtifactPayload>
          }
          deleteMany: {
            args: Prisma.ExportArtifactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExportArtifactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExportArtifactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportArtifactPayload>[]
          }
          upsert: {
            args: Prisma.ExportArtifactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportArtifactPayload>
          }
          aggregate: {
            args: Prisma.ExportArtifactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExportArtifact>
          }
          groupBy: {
            args: Prisma.ExportArtifactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExportArtifactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExportArtifactCountArgs<ExtArgs>
            result: $Utils.Optional<ExportArtifactCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      AuthSession: {
        payload: Prisma.$AuthSessionPayload<ExtArgs>
        fields: Prisma.AuthSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          findFirst: {
            args: Prisma.AuthSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          findMany: {
            args: Prisma.AuthSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>[]
          }
          create: {
            args: Prisma.AuthSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          createMany: {
            args: Prisma.AuthSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>[]
          }
          delete: {
            args: Prisma.AuthSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          update: {
            args: Prisma.AuthSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          deleteMany: {
            args: Prisma.AuthSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>[]
          }
          upsert: {
            args: Prisma.AuthSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          aggregate: {
            args: Prisma.AuthSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthSession>
          }
          groupBy: {
            args: Prisma.AuthSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AuthSessionCountAggregateOutputType> | number
          }
        }
      }
      DispatchJob: {
        payload: Prisma.$DispatchJobPayload<ExtArgs>
        fields: Prisma.DispatchJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DispatchJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DispatchJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchJobPayload>
          }
          findFirst: {
            args: Prisma.DispatchJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DispatchJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchJobPayload>
          }
          findMany: {
            args: Prisma.DispatchJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchJobPayload>[]
          }
          create: {
            args: Prisma.DispatchJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchJobPayload>
          }
          createMany: {
            args: Prisma.DispatchJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DispatchJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchJobPayload>[]
          }
          delete: {
            args: Prisma.DispatchJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchJobPayload>
          }
          update: {
            args: Prisma.DispatchJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchJobPayload>
          }
          deleteMany: {
            args: Prisma.DispatchJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DispatchJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DispatchJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchJobPayload>[]
          }
          upsert: {
            args: Prisma.DispatchJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchJobPayload>
          }
          aggregate: {
            args: Prisma.DispatchJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDispatchJob>
          }
          groupBy: {
            args: Prisma.DispatchJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<DispatchJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.DispatchJobCountArgs<ExtArgs>
            result: $Utils.Optional<DispatchJobCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userSettings?: UserSettingsOmit
    patient?: PatientOmit
    appointment?: AppointmentOmit
    encounter?: EncounterOmit
    note?: NoteOmit
    noteVersion?: NoteVersionOmit
    transcriptSegment?: TranscriptSegmentOmit
    chartAsset?: ChartAssetOmit
    suggestionGeneration?: SuggestionGenerationOmit
    codeSuggestion?: CodeSuggestionOmit
    codeSelection?: CodeSelectionOmit
    complianceIssue?: ComplianceIssueOmit
    wizardRun?: WizardRunOmit
    wizardStepState?: WizardStepStateOmit
    exportArtifact?: ExportArtifactOmit
    auditLog?: AuditLogOmit
    authSession?: AuthSessionOmit
    dispatchJob?: DispatchJobOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    appointmentsCreated: number
    appointmentsProvided: number
    encountersProvided: number
    notesCreated: number
    notesUpdated: number
    noteVersions: number
    chartAssets: number
    suggestionGenerations: number
    codeSelections: number
    complianceIssues: number
    wizardStepStates: number
    exportArtifacts: number
    auditLogs: number
    authSessions: number
    dispatchJobs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointmentsCreated?: boolean | UserCountOutputTypeCountAppointmentsCreatedArgs
    appointmentsProvided?: boolean | UserCountOutputTypeCountAppointmentsProvidedArgs
    encountersProvided?: boolean | UserCountOutputTypeCountEncountersProvidedArgs
    notesCreated?: boolean | UserCountOutputTypeCountNotesCreatedArgs
    notesUpdated?: boolean | UserCountOutputTypeCountNotesUpdatedArgs
    noteVersions?: boolean | UserCountOutputTypeCountNoteVersionsArgs
    chartAssets?: boolean | UserCountOutputTypeCountChartAssetsArgs
    suggestionGenerations?: boolean | UserCountOutputTypeCountSuggestionGenerationsArgs
    codeSelections?: boolean | UserCountOutputTypeCountCodeSelectionsArgs
    complianceIssues?: boolean | UserCountOutputTypeCountComplianceIssuesArgs
    wizardStepStates?: boolean | UserCountOutputTypeCountWizardStepStatesArgs
    exportArtifacts?: boolean | UserCountOutputTypeCountExportArtifactsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    authSessions?: boolean | UserCountOutputTypeCountAuthSessionsArgs
    dispatchJobs?: boolean | UserCountOutputTypeCountDispatchJobsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsProvidedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEncountersProvidedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotesUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNoteVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChartAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartAssetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSuggestionGenerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuggestionGenerationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCodeSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeSelectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountComplianceIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceIssueWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWizardStepStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WizardStepStateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExportArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportArtifactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDispatchJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatchJobWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    appointments: number
    encounters: number
    chartAssets: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | PatientCountOutputTypeCountAppointmentsArgs
    encounters?: boolean | PatientCountOutputTypeCountEncountersArgs
    chartAssets?: boolean | PatientCountOutputTypeCountChartAssetsArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountChartAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartAssetWhereInput
  }


  /**
   * Count Type AppointmentCountOutputType
   */

  export type AppointmentCountOutputType = {
    chartAssets: number
  }

  export type AppointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chartAssets?: boolean | AppointmentCountOutputTypeCountChartAssetsArgs
  }

  // Custom InputTypes
  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentCountOutputType
     */
    select?: AppointmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountChartAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartAssetWhereInput
  }


  /**
   * Count Type EncounterCountOutputType
   */

  export type EncounterCountOutputType = {
    transcriptSegments: number
    chartAssets: number
    suggestionCycles: number
    codeSuggestions: number
    codeSelections: number
    complianceIssues: number
    wizardRuns: number
    wizardStepStates: number
    exportArtifacts: number
    auditLogs: number
    dispatchJobs: number
  }

  export type EncounterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transcriptSegments?: boolean | EncounterCountOutputTypeCountTranscriptSegmentsArgs
    chartAssets?: boolean | EncounterCountOutputTypeCountChartAssetsArgs
    suggestionCycles?: boolean | EncounterCountOutputTypeCountSuggestionCyclesArgs
    codeSuggestions?: boolean | EncounterCountOutputTypeCountCodeSuggestionsArgs
    codeSelections?: boolean | EncounterCountOutputTypeCountCodeSelectionsArgs
    complianceIssues?: boolean | EncounterCountOutputTypeCountComplianceIssuesArgs
    wizardRuns?: boolean | EncounterCountOutputTypeCountWizardRunsArgs
    wizardStepStates?: boolean | EncounterCountOutputTypeCountWizardStepStatesArgs
    exportArtifacts?: boolean | EncounterCountOutputTypeCountExportArtifactsArgs
    auditLogs?: boolean | EncounterCountOutputTypeCountAuditLogsArgs
    dispatchJobs?: boolean | EncounterCountOutputTypeCountDispatchJobsArgs
  }

  // Custom InputTypes
  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCountOutputType
     */
    select?: EncounterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountTranscriptSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptSegmentWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountChartAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartAssetWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountSuggestionCyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuggestionGenerationWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountCodeSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeSuggestionWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountCodeSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeSelectionWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountComplianceIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceIssueWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountWizardRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WizardRunWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountWizardStepStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WizardStepStateWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountExportArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportArtifactWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountDispatchJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatchJobWhereInput
  }


  /**
   * Count Type NoteCountOutputType
   */

  export type NoteCountOutputType = {
    versions: number
    exportArtifacts: number
    dispatchJobs: number
  }

  export type NoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | NoteCountOutputTypeCountVersionsArgs
    exportArtifacts?: boolean | NoteCountOutputTypeCountExportArtifactsArgs
    dispatchJobs?: boolean | NoteCountOutputTypeCountDispatchJobsArgs
  }

  // Custom InputTypes
  /**
   * NoteCountOutputType without action
   */
  export type NoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteCountOutputType
     */
    select?: NoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NoteCountOutputType without action
   */
  export type NoteCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteVersionWhereInput
  }

  /**
   * NoteCountOutputType without action
   */
  export type NoteCountOutputTypeCountExportArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportArtifactWhereInput
  }

  /**
   * NoteCountOutputType without action
   */
  export type NoteCountOutputTypeCountDispatchJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatchJobWhereInput
  }


  /**
   * Count Type SuggestionGenerationCountOutputType
   */

  export type SuggestionGenerationCountOutputType = {
    suggestions: number
  }

  export type SuggestionGenerationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suggestions?: boolean | SuggestionGenerationCountOutputTypeCountSuggestionsArgs
  }

  // Custom InputTypes
  /**
   * SuggestionGenerationCountOutputType without action
   */
  export type SuggestionGenerationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGenerationCountOutputType
     */
    select?: SuggestionGenerationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SuggestionGenerationCountOutputType without action
   */
  export type SuggestionGenerationCountOutputTypeCountSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeSuggestionWhereInput
  }


  /**
   * Count Type CodeSuggestionCountOutputType
   */

  export type CodeSuggestionCountOutputType = {
    selections: number
  }

  export type CodeSuggestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    selections?: boolean | CodeSuggestionCountOutputTypeCountSelectionsArgs
  }

  // Custom InputTypes
  /**
   * CodeSuggestionCountOutputType without action
   */
  export type CodeSuggestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestionCountOutputType
     */
    select?: CodeSuggestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CodeSuggestionCountOutputType without action
   */
  export type CodeSuggestionCountOutputTypeCountSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeSelectionWhereInput
  }


  /**
   * Count Type WizardRunCountOutputType
   */

  export type WizardRunCountOutputType = {
    stepStates: number
  }

  export type WizardRunCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stepStates?: boolean | WizardRunCountOutputTypeCountStepStatesArgs
  }

  // Custom InputTypes
  /**
   * WizardRunCountOutputType without action
   */
  export type WizardRunCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardRunCountOutputType
     */
    select?: WizardRunCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WizardRunCountOutputType without action
   */
  export type WizardRunCountOutputTypeCountStepStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WizardStepStateWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.UserRole | null
    passwordHash: string | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    mfaEnrolledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.UserRole | null
    passwordHash: string | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    mfaEnrolledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    passwordHash: number
    mfaEnabled: number
    mfaSecret: number
    mfaBackupCodesHash: number
    mfaEnrolledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    passwordHash?: true
    mfaEnabled?: true
    mfaSecret?: true
    mfaEnrolledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    passwordHash?: true
    mfaEnabled?: true
    mfaSecret?: true
    mfaEnrolledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    passwordHash?: true
    mfaEnabled?: true
    mfaSecret?: true
    mfaBackupCodesHash?: true
    mfaEnrolledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    role: $Enums.UserRole
    passwordHash: string | null
    mfaEnabled: boolean
    mfaSecret: string | null
    mfaBackupCodesHash: JsonValue | null
    mfaEnrolledAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    passwordHash?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaBackupCodesHash?: boolean
    mfaEnrolledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointmentsCreated?: boolean | User$appointmentsCreatedArgs<ExtArgs>
    appointmentsProvided?: boolean | User$appointmentsProvidedArgs<ExtArgs>
    encountersProvided?: boolean | User$encountersProvidedArgs<ExtArgs>
    notesCreated?: boolean | User$notesCreatedArgs<ExtArgs>
    notesUpdated?: boolean | User$notesUpdatedArgs<ExtArgs>
    noteVersions?: boolean | User$noteVersionsArgs<ExtArgs>
    chartAssets?: boolean | User$chartAssetsArgs<ExtArgs>
    suggestionGenerations?: boolean | User$suggestionGenerationsArgs<ExtArgs>
    codeSelections?: boolean | User$codeSelectionsArgs<ExtArgs>
    complianceIssues?: boolean | User$complianceIssuesArgs<ExtArgs>
    wizardStepStates?: boolean | User$wizardStepStatesArgs<ExtArgs>
    exportArtifacts?: boolean | User$exportArtifactsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    authSessions?: boolean | User$authSessionsArgs<ExtArgs>
    dispatchJobs?: boolean | User$dispatchJobsArgs<ExtArgs>
    userSettings?: boolean | User$userSettingsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    passwordHash?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaBackupCodesHash?: boolean
    mfaEnrolledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    passwordHash?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaBackupCodesHash?: boolean
    mfaEnrolledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    passwordHash?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaBackupCodesHash?: boolean
    mfaEnrolledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "role" | "passwordHash" | "mfaEnabled" | "mfaSecret" | "mfaBackupCodesHash" | "mfaEnrolledAt" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointmentsCreated?: boolean | User$appointmentsCreatedArgs<ExtArgs>
    appointmentsProvided?: boolean | User$appointmentsProvidedArgs<ExtArgs>
    encountersProvided?: boolean | User$encountersProvidedArgs<ExtArgs>
    notesCreated?: boolean | User$notesCreatedArgs<ExtArgs>
    notesUpdated?: boolean | User$notesUpdatedArgs<ExtArgs>
    noteVersions?: boolean | User$noteVersionsArgs<ExtArgs>
    chartAssets?: boolean | User$chartAssetsArgs<ExtArgs>
    suggestionGenerations?: boolean | User$suggestionGenerationsArgs<ExtArgs>
    codeSelections?: boolean | User$codeSelectionsArgs<ExtArgs>
    complianceIssues?: boolean | User$complianceIssuesArgs<ExtArgs>
    wizardStepStates?: boolean | User$wizardStepStatesArgs<ExtArgs>
    exportArtifacts?: boolean | User$exportArtifactsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    authSessions?: boolean | User$authSessionsArgs<ExtArgs>
    dispatchJobs?: boolean | User$dispatchJobsArgs<ExtArgs>
    userSettings?: boolean | User$userSettingsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      appointmentsCreated: Prisma.$AppointmentPayload<ExtArgs>[]
      appointmentsProvided: Prisma.$AppointmentPayload<ExtArgs>[]
      encountersProvided: Prisma.$EncounterPayload<ExtArgs>[]
      notesCreated: Prisma.$NotePayload<ExtArgs>[]
      notesUpdated: Prisma.$NotePayload<ExtArgs>[]
      noteVersions: Prisma.$NoteVersionPayload<ExtArgs>[]
      chartAssets: Prisma.$ChartAssetPayload<ExtArgs>[]
      suggestionGenerations: Prisma.$SuggestionGenerationPayload<ExtArgs>[]
      codeSelections: Prisma.$CodeSelectionPayload<ExtArgs>[]
      complianceIssues: Prisma.$ComplianceIssuePayload<ExtArgs>[]
      wizardStepStates: Prisma.$WizardStepStatePayload<ExtArgs>[]
      exportArtifacts: Prisma.$ExportArtifactPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      authSessions: Prisma.$AuthSessionPayload<ExtArgs>[]
      dispatchJobs: Prisma.$DispatchJobPayload<ExtArgs>[]
      userSettings: Prisma.$UserSettingsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      role: $Enums.UserRole
      passwordHash: string | null
      mfaEnabled: boolean
      mfaSecret: string | null
      mfaBackupCodesHash: Prisma.JsonValue | null
      mfaEnrolledAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointmentsCreated<T extends User$appointmentsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointmentsProvided<T extends User$appointmentsProvidedArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsProvidedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    encountersProvided<T extends User$encountersProvidedArgs<ExtArgs> = {}>(args?: Subset<T, User$encountersProvidedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notesCreated<T extends User$notesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$notesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notesUpdated<T extends User$notesUpdatedArgs<ExtArgs> = {}>(args?: Subset<T, User$notesUpdatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    noteVersions<T extends User$noteVersionsArgs<ExtArgs> = {}>(args?: Subset<T, User$noteVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chartAssets<T extends User$chartAssetsArgs<ExtArgs> = {}>(args?: Subset<T, User$chartAssetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suggestionGenerations<T extends User$suggestionGenerationsArgs<ExtArgs> = {}>(args?: Subset<T, User$suggestionGenerationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionGenerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    codeSelections<T extends User$codeSelectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$codeSelectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSelectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    complianceIssues<T extends User$complianceIssuesArgs<ExtArgs> = {}>(args?: Subset<T, User$complianceIssuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wizardStepStates<T extends User$wizardStepStatesArgs<ExtArgs> = {}>(args?: Subset<T, User$wizardStepStatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WizardStepStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exportArtifacts<T extends User$exportArtifactsArgs<ExtArgs> = {}>(args?: Subset<T, User$exportArtifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    authSessions<T extends User$authSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$authSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dispatchJobs<T extends User$dispatchJobsArgs<ExtArgs> = {}>(args?: Subset<T, User$dispatchJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSettings<T extends User$userSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$userSettingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly mfaEnabled: FieldRef<"User", 'Boolean'>
    readonly mfaSecret: FieldRef<"User", 'String'>
    readonly mfaBackupCodesHash: FieldRef<"User", 'Json'>
    readonly mfaEnrolledAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.appointmentsCreated
   */
  export type User$appointmentsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.appointmentsProvided
   */
  export type User$appointmentsProvidedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.encountersProvided
   */
  export type User$encountersProvidedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * User.notesCreated
   */
  export type User$notesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * User.notesUpdated
   */
  export type User$notesUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * User.noteVersions
   */
  export type User$noteVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteVersion
     */
    select?: NoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteVersion
     */
    omit?: NoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteVersionInclude<ExtArgs> | null
    where?: NoteVersionWhereInput
    orderBy?: NoteVersionOrderByWithRelationInput | NoteVersionOrderByWithRelationInput[]
    cursor?: NoteVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteVersionScalarFieldEnum | NoteVersionScalarFieldEnum[]
  }

  /**
   * User.chartAssets
   */
  export type User$chartAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetInclude<ExtArgs> | null
    where?: ChartAssetWhereInput
    orderBy?: ChartAssetOrderByWithRelationInput | ChartAssetOrderByWithRelationInput[]
    cursor?: ChartAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChartAssetScalarFieldEnum | ChartAssetScalarFieldEnum[]
  }

  /**
   * User.suggestionGenerations
   */
  export type User$suggestionGenerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGeneration
     */
    select?: SuggestionGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestionGeneration
     */
    omit?: SuggestionGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionGenerationInclude<ExtArgs> | null
    where?: SuggestionGenerationWhereInput
    orderBy?: SuggestionGenerationOrderByWithRelationInput | SuggestionGenerationOrderByWithRelationInput[]
    cursor?: SuggestionGenerationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuggestionGenerationScalarFieldEnum | SuggestionGenerationScalarFieldEnum[]
  }

  /**
   * User.codeSelections
   */
  export type User$codeSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionInclude<ExtArgs> | null
    where?: CodeSelectionWhereInput
    orderBy?: CodeSelectionOrderByWithRelationInput | CodeSelectionOrderByWithRelationInput[]
    cursor?: CodeSelectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CodeSelectionScalarFieldEnum | CodeSelectionScalarFieldEnum[]
  }

  /**
   * User.complianceIssues
   */
  export type User$complianceIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceIssue
     */
    select?: ComplianceIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceIssue
     */
    omit?: ComplianceIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceIssueInclude<ExtArgs> | null
    where?: ComplianceIssueWhereInput
    orderBy?: ComplianceIssueOrderByWithRelationInput | ComplianceIssueOrderByWithRelationInput[]
    cursor?: ComplianceIssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplianceIssueScalarFieldEnum | ComplianceIssueScalarFieldEnum[]
  }

  /**
   * User.wizardStepStates
   */
  export type User$wizardStepStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateInclude<ExtArgs> | null
    where?: WizardStepStateWhereInput
    orderBy?: WizardStepStateOrderByWithRelationInput | WizardStepStateOrderByWithRelationInput[]
    cursor?: WizardStepStateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WizardStepStateScalarFieldEnum | WizardStepStateScalarFieldEnum[]
  }

  /**
   * User.exportArtifacts
   */
  export type User$exportArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactInclude<ExtArgs> | null
    where?: ExportArtifactWhereInput
    orderBy?: ExportArtifactOrderByWithRelationInput | ExportArtifactOrderByWithRelationInput[]
    cursor?: ExportArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExportArtifactScalarFieldEnum | ExportArtifactScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.authSessions
   */
  export type User$authSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    where?: AuthSessionWhereInput
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    cursor?: AuthSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * User.dispatchJobs
   */
  export type User$dispatchJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobInclude<ExtArgs> | null
    where?: DispatchJobWhereInput
    orderBy?: DispatchJobOrderByWithRelationInput | DispatchJobOrderByWithRelationInput[]
    cursor?: DispatchJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispatchJobScalarFieldEnum | DispatchJobScalarFieldEnum[]
  }

  /**
   * User.userSettings
   */
  export type User$userSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    id: number
    userId: number
    payload: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    payload?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    id: string
    userId: string
    payload: JsonValue
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    payload?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    payload?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    payload?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    payload?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "payload" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["userSettings"]>
  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      payload: Prisma.JsonValue
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings and returns the data updated in the database.
     * @param {UserSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserSettings.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */
  interface UserSettingsFieldRefs {
    readonly id: FieldRef<"UserSettings", 'String'>
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly payload: FieldRef<"UserSettings", 'Json'>
    readonly updatedById: FieldRef<"UserSettings", 'String'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSettings updateManyAndReturn
   */
  export type UserSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to delete.
     */
    limit?: number
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    externalId: string | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    externalId: string | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    externalId: number
    firstName: number
    lastName: number
    dateOfBirth: number
    email: number
    phone: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    externalId?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    externalId?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    externalId?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    email?: true
    phone?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    externalId: string
    firstName: string
    lastName: string
    dateOfBirth: Date | null
    email: string | null
    phone: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    email?: boolean
    phone?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    encounters?: boolean | Patient$encountersArgs<ExtArgs>
    chartAssets?: boolean | Patient$chartAssetsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    email?: boolean
    phone?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    email?: boolean
    phone?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    externalId?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    email?: boolean
    phone?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "firstName" | "lastName" | "dateOfBirth" | "email" | "phone" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    encounters?: boolean | Patient$encountersArgs<ExtArgs>
    chartAssets?: boolean | Patient$chartAssetsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
      chartAssets: Prisma.$ChartAssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: string
      firstName: string
      lastName: string
      dateOfBirth: Date | null
      email: string | null
      phone: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends Patient$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    encounters<T extends Patient$encountersArgs<ExtArgs> = {}>(args?: Subset<T, Patient$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chartAssets<T extends Patient$chartAssetsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$chartAssetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly externalId: FieldRef<"Patient", 'String'>
    readonly firstName: FieldRef<"Patient", 'String'>
    readonly lastName: FieldRef<"Patient", 'String'>
    readonly dateOfBirth: FieldRef<"Patient", 'DateTime'>
    readonly email: FieldRef<"Patient", 'String'>
    readonly phone: FieldRef<"Patient", 'String'>
    readonly metadata: FieldRef<"Patient", 'Json'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.appointments
   */
  export type Patient$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Patient.encounters
   */
  export type Patient$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Patient.chartAssets
   */
  export type Patient$chartAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetInclude<ExtArgs> | null
    where?: ChartAssetWhereInput
    orderBy?: ChartAssetOrderByWithRelationInput | ChartAssetOrderByWithRelationInput[]
    cursor?: ChartAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChartAssetScalarFieldEnum | ChartAssetScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    durationMinutes: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    durationMinutes: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    externalId: string | null
    patientId: string | null
    providerId: string | null
    createdById: string | null
    scheduledAt: Date | null
    durationMinutes: number | null
    appointmentType: string | null
    location: string | null
    status: $Enums.AppointmentStatus | null
    priority: $Enums.AppointmentPriority | null
    isVirtual: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    externalId: string | null
    patientId: string | null
    providerId: string | null
    createdById: string | null
    scheduledAt: Date | null
    durationMinutes: number | null
    appointmentType: string | null
    location: string | null
    status: $Enums.AppointmentStatus | null
    priority: $Enums.AppointmentPriority | null
    isVirtual: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    externalId: number
    patientId: number
    providerId: number
    createdById: number
    scheduledAt: number
    durationMinutes: number
    appointmentType: number
    location: number
    status: number
    priority: number
    isVirtual: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    durationMinutes?: true
  }

  export type AppointmentSumAggregateInputType = {
    durationMinutes?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    externalId?: true
    patientId?: true
    providerId?: true
    createdById?: true
    scheduledAt?: true
    durationMinutes?: true
    appointmentType?: true
    location?: true
    status?: true
    priority?: true
    isVirtual?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    externalId?: true
    patientId?: true
    providerId?: true
    createdById?: true
    scheduledAt?: true
    durationMinutes?: true
    appointmentType?: true
    location?: true
    status?: true
    priority?: true
    isVirtual?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    externalId?: true
    patientId?: true
    providerId?: true
    createdById?: true
    scheduledAt?: true
    durationMinutes?: true
    appointmentType?: true
    location?: true
    status?: true
    priority?: true
    isVirtual?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    externalId: string
    patientId: string
    providerId: string | null
    createdById: string | null
    scheduledAt: Date
    durationMinutes: number
    appointmentType: string
    location: string | null
    status: $Enums.AppointmentStatus
    priority: $Enums.AppointmentPriority
    isVirtual: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    patientId?: boolean
    providerId?: boolean
    createdById?: boolean
    scheduledAt?: boolean
    durationMinutes?: boolean
    appointmentType?: boolean
    location?: boolean
    status?: boolean
    priority?: boolean
    isVirtual?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    provider?: boolean | Appointment$providerArgs<ExtArgs>
    createdBy?: boolean | Appointment$createdByArgs<ExtArgs>
    encounter?: boolean | Appointment$encounterArgs<ExtArgs>
    chartAssets?: boolean | Appointment$chartAssetsArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    patientId?: boolean
    providerId?: boolean
    createdById?: boolean
    scheduledAt?: boolean
    durationMinutes?: boolean
    appointmentType?: boolean
    location?: boolean
    status?: boolean
    priority?: boolean
    isVirtual?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    provider?: boolean | Appointment$providerArgs<ExtArgs>
    createdBy?: boolean | Appointment$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    patientId?: boolean
    providerId?: boolean
    createdById?: boolean
    scheduledAt?: boolean
    durationMinutes?: boolean
    appointmentType?: boolean
    location?: boolean
    status?: boolean
    priority?: boolean
    isVirtual?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    provider?: boolean | Appointment$providerArgs<ExtArgs>
    createdBy?: boolean | Appointment$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    externalId?: boolean
    patientId?: boolean
    providerId?: boolean
    createdById?: boolean
    scheduledAt?: boolean
    durationMinutes?: boolean
    appointmentType?: boolean
    location?: boolean
    status?: boolean
    priority?: boolean
    isVirtual?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "patientId" | "providerId" | "createdById" | "scheduledAt" | "durationMinutes" | "appointmentType" | "location" | "status" | "priority" | "isVirtual" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    provider?: boolean | Appointment$providerArgs<ExtArgs>
    createdBy?: boolean | Appointment$createdByArgs<ExtArgs>
    encounter?: boolean | Appointment$encounterArgs<ExtArgs>
    chartAssets?: boolean | Appointment$chartAssetsArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    provider?: boolean | Appointment$providerArgs<ExtArgs>
    createdBy?: boolean | Appointment$createdByArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    provider?: boolean | Appointment$providerArgs<ExtArgs>
    createdBy?: boolean | Appointment$createdByArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      provider: Prisma.$UserPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      encounter: Prisma.$EncounterPayload<ExtArgs> | null
      chartAssets: Prisma.$ChartAssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: string
      patientId: string
      providerId: string | null
      createdById: string | null
      scheduledAt: Date
      durationMinutes: number
      appointmentType: string
      location: string | null
      status: $Enums.AppointmentStatus
      priority: $Enums.AppointmentPriority
      isVirtual: boolean
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provider<T extends Appointment$providerArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$providerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Appointment$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    encounter<T extends Appointment$encounterArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$encounterArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    chartAssets<T extends Appointment$chartAssetsArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$chartAssetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly externalId: FieldRef<"Appointment", 'String'>
    readonly patientId: FieldRef<"Appointment", 'String'>
    readonly providerId: FieldRef<"Appointment", 'String'>
    readonly createdById: FieldRef<"Appointment", 'String'>
    readonly scheduledAt: FieldRef<"Appointment", 'DateTime'>
    readonly durationMinutes: FieldRef<"Appointment", 'Int'>
    readonly appointmentType: FieldRef<"Appointment", 'String'>
    readonly location: FieldRef<"Appointment", 'String'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly priority: FieldRef<"Appointment", 'AppointmentPriority'>
    readonly isVirtual: FieldRef<"Appointment", 'Boolean'>
    readonly notes: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.provider
   */
  export type Appointment$providerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Appointment.createdBy
   */
  export type Appointment$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Appointment.encounter
   */
  export type Appointment$encounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
  }

  /**
   * Appointment.chartAssets
   */
  export type Appointment$chartAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetInclude<ExtArgs> | null
    where?: ChartAssetWhereInput
    orderBy?: ChartAssetOrderByWithRelationInput | ChartAssetOrderByWithRelationInput[]
    cursor?: ChartAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChartAssetScalarFieldEnum | ChartAssetScalarFieldEnum[]
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Encounter
   */

  export type AggregateEncounter = {
    _count: EncounterCountAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  export type EncounterMinAggregateOutputType = {
    id: string | null
    externalId: string | null
    appointmentId: string | null
    patientId: string | null
    providerId: string | null
    status: $Enums.EncounterStatus | null
    startedAt: Date | null
    stoppedAt: Date | null
    hiddenDraftCreated: Date | null
    draftUnhiddenAt: Date | null
    finalizedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EncounterMaxAggregateOutputType = {
    id: string | null
    externalId: string | null
    appointmentId: string | null
    patientId: string | null
    providerId: string | null
    status: $Enums.EncounterStatus | null
    startedAt: Date | null
    stoppedAt: Date | null
    hiddenDraftCreated: Date | null
    draftUnhiddenAt: Date | null
    finalizedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EncounterCountAggregateOutputType = {
    id: number
    externalId: number
    appointmentId: number
    patientId: number
    providerId: number
    status: number
    startedAt: number
    stoppedAt: number
    hiddenDraftCreated: number
    draftUnhiddenAt: number
    finalizedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EncounterMinAggregateInputType = {
    id?: true
    externalId?: true
    appointmentId?: true
    patientId?: true
    providerId?: true
    status?: true
    startedAt?: true
    stoppedAt?: true
    hiddenDraftCreated?: true
    draftUnhiddenAt?: true
    finalizedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EncounterMaxAggregateInputType = {
    id?: true
    externalId?: true
    appointmentId?: true
    patientId?: true
    providerId?: true
    status?: true
    startedAt?: true
    stoppedAt?: true
    hiddenDraftCreated?: true
    draftUnhiddenAt?: true
    finalizedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EncounterCountAggregateInputType = {
    id?: true
    externalId?: true
    appointmentId?: true
    patientId?: true
    providerId?: true
    status?: true
    startedAt?: true
    stoppedAt?: true
    hiddenDraftCreated?: true
    draftUnhiddenAt?: true
    finalizedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EncounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounter to aggregate.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Encounters
    **/
    _count?: true | EncounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterMaxAggregateInputType
  }

  export type GetEncounterAggregateType<T extends EncounterAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounter[P]>
      : GetScalarType<T[P], AggregateEncounter[P]>
  }




  export type EncounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithAggregationInput | EncounterOrderByWithAggregationInput[]
    by: EncounterScalarFieldEnum[] | EncounterScalarFieldEnum
    having?: EncounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterCountAggregateInputType | true
    _min?: EncounterMinAggregateInputType
    _max?: EncounterMaxAggregateInputType
  }

  export type EncounterGroupByOutputType = {
    id: string
    externalId: string
    appointmentId: string | null
    patientId: string
    providerId: string | null
    status: $Enums.EncounterStatus
    startedAt: Date | null
    stoppedAt: Date | null
    hiddenDraftCreated: Date | null
    draftUnhiddenAt: Date | null
    finalizedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EncounterCountAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  type GetEncounterGroupByPayload<T extends EncounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterGroupByOutputType[P]>
        }
      >
    >


  export type EncounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    appointmentId?: boolean
    patientId?: boolean
    providerId?: boolean
    status?: boolean
    startedAt?: boolean
    stoppedAt?: boolean
    hiddenDraftCreated?: boolean
    draftUnhiddenAt?: boolean
    finalizedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | Encounter$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    provider?: boolean | Encounter$providerArgs<ExtArgs>
    note?: boolean | Encounter$noteArgs<ExtArgs>
    transcriptSegments?: boolean | Encounter$transcriptSegmentsArgs<ExtArgs>
    chartAssets?: boolean | Encounter$chartAssetsArgs<ExtArgs>
    suggestionCycles?: boolean | Encounter$suggestionCyclesArgs<ExtArgs>
    codeSuggestions?: boolean | Encounter$codeSuggestionsArgs<ExtArgs>
    codeSelections?: boolean | Encounter$codeSelectionsArgs<ExtArgs>
    complianceIssues?: boolean | Encounter$complianceIssuesArgs<ExtArgs>
    wizardRuns?: boolean | Encounter$wizardRunsArgs<ExtArgs>
    wizardStepStates?: boolean | Encounter$wizardStepStatesArgs<ExtArgs>
    exportArtifacts?: boolean | Encounter$exportArtifactsArgs<ExtArgs>
    auditLogs?: boolean | Encounter$auditLogsArgs<ExtArgs>
    dispatchJobs?: boolean | Encounter$dispatchJobsArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    appointmentId?: boolean
    patientId?: boolean
    providerId?: boolean
    status?: boolean
    startedAt?: boolean
    stoppedAt?: boolean
    hiddenDraftCreated?: boolean
    draftUnhiddenAt?: boolean
    finalizedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | Encounter$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    provider?: boolean | Encounter$providerArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    appointmentId?: boolean
    patientId?: boolean
    providerId?: boolean
    status?: boolean
    startedAt?: boolean
    stoppedAt?: boolean
    hiddenDraftCreated?: boolean
    draftUnhiddenAt?: boolean
    finalizedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | Encounter$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    provider?: boolean | Encounter$providerArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectScalar = {
    id?: boolean
    externalId?: boolean
    appointmentId?: boolean
    patientId?: boolean
    providerId?: boolean
    status?: boolean
    startedAt?: boolean
    stoppedAt?: boolean
    hiddenDraftCreated?: boolean
    draftUnhiddenAt?: boolean
    finalizedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EncounterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "appointmentId" | "patientId" | "providerId" | "status" | "startedAt" | "stoppedAt" | "hiddenDraftCreated" | "draftUnhiddenAt" | "finalizedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["encounter"]>
  export type EncounterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | Encounter$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    provider?: boolean | Encounter$providerArgs<ExtArgs>
    note?: boolean | Encounter$noteArgs<ExtArgs>
    transcriptSegments?: boolean | Encounter$transcriptSegmentsArgs<ExtArgs>
    chartAssets?: boolean | Encounter$chartAssetsArgs<ExtArgs>
    suggestionCycles?: boolean | Encounter$suggestionCyclesArgs<ExtArgs>
    codeSuggestions?: boolean | Encounter$codeSuggestionsArgs<ExtArgs>
    codeSelections?: boolean | Encounter$codeSelectionsArgs<ExtArgs>
    complianceIssues?: boolean | Encounter$complianceIssuesArgs<ExtArgs>
    wizardRuns?: boolean | Encounter$wizardRunsArgs<ExtArgs>
    wizardStepStates?: boolean | Encounter$wizardStepStatesArgs<ExtArgs>
    exportArtifacts?: boolean | Encounter$exportArtifactsArgs<ExtArgs>
    auditLogs?: boolean | Encounter$auditLogsArgs<ExtArgs>
    dispatchJobs?: boolean | Encounter$dispatchJobsArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncounterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | Encounter$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    provider?: boolean | Encounter$providerArgs<ExtArgs>
  }
  export type EncounterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | Encounter$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    provider?: boolean | Encounter$providerArgs<ExtArgs>
  }

  export type $EncounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Encounter"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs>
      provider: Prisma.$UserPayload<ExtArgs> | null
      note: Prisma.$NotePayload<ExtArgs> | null
      transcriptSegments: Prisma.$TranscriptSegmentPayload<ExtArgs>[]
      chartAssets: Prisma.$ChartAssetPayload<ExtArgs>[]
      suggestionCycles: Prisma.$SuggestionGenerationPayload<ExtArgs>[]
      codeSuggestions: Prisma.$CodeSuggestionPayload<ExtArgs>[]
      codeSelections: Prisma.$CodeSelectionPayload<ExtArgs>[]
      complianceIssues: Prisma.$ComplianceIssuePayload<ExtArgs>[]
      wizardRuns: Prisma.$WizardRunPayload<ExtArgs>[]
      wizardStepStates: Prisma.$WizardStepStatePayload<ExtArgs>[]
      exportArtifacts: Prisma.$ExportArtifactPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      dispatchJobs: Prisma.$DispatchJobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: string
      appointmentId: string | null
      patientId: string
      providerId: string | null
      status: $Enums.EncounterStatus
      startedAt: Date | null
      stoppedAt: Date | null
      hiddenDraftCreated: Date | null
      draftUnhiddenAt: Date | null
      finalizedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["encounter"]>
    composites: {}
  }

  type EncounterGetPayload<S extends boolean | null | undefined | EncounterDefaultArgs> = $Result.GetResult<Prisma.$EncounterPayload, S>

  type EncounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncounterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncounterCountAggregateInputType | true
    }

  export interface EncounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Encounter'], meta: { name: 'Encounter' } }
    /**
     * Find zero or one Encounter that matches the filter.
     * @param {EncounterFindUniqueArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterFindUniqueArgs>(args: SelectSubset<T, EncounterFindUniqueArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Encounter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncounterFindUniqueOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Encounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterFindFirstArgs>(args?: SelectSubset<T, EncounterFindFirstArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Encounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Encounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encounters
     * const encounters = await prisma.encounter.findMany()
     * 
     * // Get first 10 Encounters
     * const encounters = await prisma.encounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterWithIdOnly = await prisma.encounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterFindManyArgs>(args?: SelectSubset<T, EncounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Encounter.
     * @param {EncounterCreateArgs} args - Arguments to create a Encounter.
     * @example
     * // Create one Encounter
     * const Encounter = await prisma.encounter.create({
     *   data: {
     *     // ... data to create a Encounter
     *   }
     * })
     * 
     */
    create<T extends EncounterCreateArgs>(args: SelectSubset<T, EncounterCreateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Encounters.
     * @param {EncounterCreateManyArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterCreateManyArgs>(args?: SelectSubset<T, EncounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Encounters and returns the data saved in the database.
     * @param {EncounterCreateManyAndReturnArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Encounters and only return the `id`
     * const encounterWithIdOnly = await prisma.encounter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Encounter.
     * @param {EncounterDeleteArgs} args - Arguments to delete one Encounter.
     * @example
     * // Delete one Encounter
     * const Encounter = await prisma.encounter.delete({
     *   where: {
     *     // ... filter to delete one Encounter
     *   }
     * })
     * 
     */
    delete<T extends EncounterDeleteArgs>(args: SelectSubset<T, EncounterDeleteArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Encounter.
     * @param {EncounterUpdateArgs} args - Arguments to update one Encounter.
     * @example
     * // Update one Encounter
     * const encounter = await prisma.encounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterUpdateArgs>(args: SelectSubset<T, EncounterUpdateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Encounters.
     * @param {EncounterDeleteManyArgs} args - Arguments to filter Encounters to delete.
     * @example
     * // Delete a few Encounters
     * const { count } = await prisma.encounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterDeleteManyArgs>(args?: SelectSubset<T, EncounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encounters
     * const encounter = await prisma.encounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterUpdateManyArgs>(args: SelectSubset<T, EncounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encounters and returns the data updated in the database.
     * @param {EncounterUpdateManyAndReturnArgs} args - Arguments to update many Encounters.
     * @example
     * // Update many Encounters
     * const encounter = await prisma.encounter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Encounters and only return the `id`
     * const encounterWithIdOnly = await prisma.encounter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncounterUpdateManyAndReturnArgs>(args: SelectSubset<T, EncounterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Encounter.
     * @param {EncounterUpsertArgs} args - Arguments to update or create a Encounter.
     * @example
     * // Update or create a Encounter
     * const encounter = await prisma.encounter.upsert({
     *   create: {
     *     // ... data to create a Encounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encounter we want to update
     *   }
     * })
     */
    upsert<T extends EncounterUpsertArgs>(args: SelectSubset<T, EncounterUpsertArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterCountArgs} args - Arguments to filter Encounters to count.
     * @example
     * // Count the number of Encounters
     * const count = await prisma.encounter.count({
     *   where: {
     *     // ... the filter for the Encounters we want to count
     *   }
     * })
    **/
    count<T extends EncounterCountArgs>(
      args?: Subset<T, EncounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterAggregateArgs>(args: Subset<T, EncounterAggregateArgs>): Prisma.PrismaPromise<GetEncounterAggregateType<T>>

    /**
     * Group by Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterGroupByArgs['orderBy'] }
        : { orderBy?: EncounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Encounter model
   */
  readonly fields: EncounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Encounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends Encounter$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provider<T extends Encounter$providerArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$providerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    note<T extends Encounter$noteArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$noteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transcriptSegments<T extends Encounter$transcriptSegmentsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$transcriptSegmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptSegmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chartAssets<T extends Encounter$chartAssetsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$chartAssetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suggestionCycles<T extends Encounter$suggestionCyclesArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$suggestionCyclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionGenerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    codeSuggestions<T extends Encounter$codeSuggestionsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$codeSuggestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    codeSelections<T extends Encounter$codeSelectionsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$codeSelectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSelectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    complianceIssues<T extends Encounter$complianceIssuesArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$complianceIssuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wizardRuns<T extends Encounter$wizardRunsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$wizardRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WizardRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wizardStepStates<T extends Encounter$wizardStepStatesArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$wizardStepStatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WizardStepStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exportArtifacts<T extends Encounter$exportArtifactsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$exportArtifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Encounter$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dispatchJobs<T extends Encounter$dispatchJobsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$dispatchJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Encounter model
   */
  interface EncounterFieldRefs {
    readonly id: FieldRef<"Encounter", 'String'>
    readonly externalId: FieldRef<"Encounter", 'String'>
    readonly appointmentId: FieldRef<"Encounter", 'String'>
    readonly patientId: FieldRef<"Encounter", 'String'>
    readonly providerId: FieldRef<"Encounter", 'String'>
    readonly status: FieldRef<"Encounter", 'EncounterStatus'>
    readonly startedAt: FieldRef<"Encounter", 'DateTime'>
    readonly stoppedAt: FieldRef<"Encounter", 'DateTime'>
    readonly hiddenDraftCreated: FieldRef<"Encounter", 'DateTime'>
    readonly draftUnhiddenAt: FieldRef<"Encounter", 'DateTime'>
    readonly finalizedAt: FieldRef<"Encounter", 'DateTime'>
    readonly createdAt: FieldRef<"Encounter", 'DateTime'>
    readonly updatedAt: FieldRef<"Encounter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Encounter findUnique
   */
  export type EncounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findUniqueOrThrow
   */
  export type EncounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findFirst
   */
  export type EncounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findFirstOrThrow
   */
  export type EncounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findMany
   */
  export type EncounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounters to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter create
   */
  export type EncounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to create a Encounter.
     */
    data: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
  }

  /**
   * Encounter createMany
   */
  export type EncounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Encounter createManyAndReturn
   */
  export type EncounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encounter update
   */
  export type EncounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to update a Encounter.
     */
    data: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
    /**
     * Choose, which Encounter to update.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter updateMany
   */
  export type EncounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Encounters.
     */
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyInput>
    /**
     * Filter which Encounters to update
     */
    where?: EncounterWhereInput
    /**
     * Limit how many Encounters to update.
     */
    limit?: number
  }

  /**
   * Encounter updateManyAndReturn
   */
  export type EncounterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * The data used to update Encounters.
     */
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyInput>
    /**
     * Filter which Encounters to update
     */
    where?: EncounterWhereInput
    /**
     * Limit how many Encounters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encounter upsert
   */
  export type EncounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The filter to search for the Encounter to update in case it exists.
     */
    where: EncounterWhereUniqueInput
    /**
     * In case the Encounter found by the `where` argument doesn't exist, create a new Encounter with this data.
     */
    create: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
    /**
     * In case the Encounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
  }

  /**
   * Encounter delete
   */
  export type EncounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter which Encounter to delete.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter deleteMany
   */
  export type EncounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounters to delete
     */
    where?: EncounterWhereInput
    /**
     * Limit how many Encounters to delete.
     */
    limit?: number
  }

  /**
   * Encounter.appointment
   */
  export type Encounter$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * Encounter.provider
   */
  export type Encounter$providerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Encounter.note
   */
  export type Encounter$noteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
  }

  /**
   * Encounter.transcriptSegments
   */
  export type Encounter$transcriptSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null
    where?: TranscriptSegmentWhereInput
    orderBy?: TranscriptSegmentOrderByWithRelationInput | TranscriptSegmentOrderByWithRelationInput[]
    cursor?: TranscriptSegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranscriptSegmentScalarFieldEnum | TranscriptSegmentScalarFieldEnum[]
  }

  /**
   * Encounter.chartAssets
   */
  export type Encounter$chartAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetInclude<ExtArgs> | null
    where?: ChartAssetWhereInput
    orderBy?: ChartAssetOrderByWithRelationInput | ChartAssetOrderByWithRelationInput[]
    cursor?: ChartAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChartAssetScalarFieldEnum | ChartAssetScalarFieldEnum[]
  }

  /**
   * Encounter.suggestionCycles
   */
  export type Encounter$suggestionCyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGeneration
     */
    select?: SuggestionGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestionGeneration
     */
    omit?: SuggestionGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionGenerationInclude<ExtArgs> | null
    where?: SuggestionGenerationWhereInput
    orderBy?: SuggestionGenerationOrderByWithRelationInput | SuggestionGenerationOrderByWithRelationInput[]
    cursor?: SuggestionGenerationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuggestionGenerationScalarFieldEnum | SuggestionGenerationScalarFieldEnum[]
  }

  /**
   * Encounter.codeSuggestions
   */
  export type Encounter$codeSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionInclude<ExtArgs> | null
    where?: CodeSuggestionWhereInput
    orderBy?: CodeSuggestionOrderByWithRelationInput | CodeSuggestionOrderByWithRelationInput[]
    cursor?: CodeSuggestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CodeSuggestionScalarFieldEnum | CodeSuggestionScalarFieldEnum[]
  }

  /**
   * Encounter.codeSelections
   */
  export type Encounter$codeSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionInclude<ExtArgs> | null
    where?: CodeSelectionWhereInput
    orderBy?: CodeSelectionOrderByWithRelationInput | CodeSelectionOrderByWithRelationInput[]
    cursor?: CodeSelectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CodeSelectionScalarFieldEnum | CodeSelectionScalarFieldEnum[]
  }

  /**
   * Encounter.complianceIssues
   */
  export type Encounter$complianceIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceIssue
     */
    select?: ComplianceIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceIssue
     */
    omit?: ComplianceIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceIssueInclude<ExtArgs> | null
    where?: ComplianceIssueWhereInput
    orderBy?: ComplianceIssueOrderByWithRelationInput | ComplianceIssueOrderByWithRelationInput[]
    cursor?: ComplianceIssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplianceIssueScalarFieldEnum | ComplianceIssueScalarFieldEnum[]
  }

  /**
   * Encounter.wizardRuns
   */
  export type Encounter$wizardRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardRun
     */
    select?: WizardRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardRun
     */
    omit?: WizardRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardRunInclude<ExtArgs> | null
    where?: WizardRunWhereInput
    orderBy?: WizardRunOrderByWithRelationInput | WizardRunOrderByWithRelationInput[]
    cursor?: WizardRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WizardRunScalarFieldEnum | WizardRunScalarFieldEnum[]
  }

  /**
   * Encounter.wizardStepStates
   */
  export type Encounter$wizardStepStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateInclude<ExtArgs> | null
    where?: WizardStepStateWhereInput
    orderBy?: WizardStepStateOrderByWithRelationInput | WizardStepStateOrderByWithRelationInput[]
    cursor?: WizardStepStateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WizardStepStateScalarFieldEnum | WizardStepStateScalarFieldEnum[]
  }

  /**
   * Encounter.exportArtifacts
   */
  export type Encounter$exportArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactInclude<ExtArgs> | null
    where?: ExportArtifactWhereInput
    orderBy?: ExportArtifactOrderByWithRelationInput | ExportArtifactOrderByWithRelationInput[]
    cursor?: ExportArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExportArtifactScalarFieldEnum | ExportArtifactScalarFieldEnum[]
  }

  /**
   * Encounter.auditLogs
   */
  export type Encounter$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Encounter.dispatchJobs
   */
  export type Encounter$dispatchJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobInclude<ExtArgs> | null
    where?: DispatchJobWhereInput
    orderBy?: DispatchJobOrderByWithRelationInput | DispatchJobOrderByWithRelationInput[]
    cursor?: DispatchJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispatchJobScalarFieldEnum | DispatchJobScalarFieldEnum[]
  }

  /**
   * Encounter without action
   */
  export type EncounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
  }


  /**
   * Model Note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteMinAggregateOutputType = {
    id: string | null
    encounterId: string | null
    status: $Enums.NoteStatus | null
    visibility: $Enums.NoteVisibility | null
    content: string | null
    patientSummary: string | null
    createdById: string | null
    updatedById: string | null
    finalizedAt: Date | null
    lockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoteMaxAggregateOutputType = {
    id: string | null
    encounterId: string | null
    status: $Enums.NoteStatus | null
    visibility: $Enums.NoteVisibility | null
    content: string | null
    patientSummary: string | null
    createdById: string | null
    updatedById: string | null
    finalizedAt: Date | null
    lockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoteCountAggregateOutputType = {
    id: number
    encounterId: number
    status: number
    visibility: number
    content: number
    patientSummary: number
    createdById: number
    updatedById: number
    finalizedAt: number
    lockedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NoteMinAggregateInputType = {
    id?: true
    encounterId?: true
    status?: true
    visibility?: true
    content?: true
    patientSummary?: true
    createdById?: true
    updatedById?: true
    finalizedAt?: true
    lockedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoteMaxAggregateInputType = {
    id?: true
    encounterId?: true
    status?: true
    visibility?: true
    content?: true
    patientSummary?: true
    createdById?: true
    updatedById?: true
    finalizedAt?: true
    lockedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoteCountAggregateInputType = {
    id?: true
    encounterId?: true
    status?: true
    visibility?: true
    content?: true
    patientSummary?: true
    createdById?: true
    updatedById?: true
    finalizedAt?: true
    lockedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithAggregationInput | NoteOrderByWithAggregationInput[]
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum
    having?: NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }

  export type NoteGroupByOutputType = {
    id: string
    encounterId: string
    status: $Enums.NoteStatus
    visibility: $Enums.NoteVisibility
    content: string
    patientSummary: string
    createdById: string | null
    updatedById: string | null
    finalizedAt: Date | null
    lockedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    status?: boolean
    visibility?: boolean
    content?: boolean
    patientSummary?: boolean
    createdById?: boolean
    updatedById?: boolean
    finalizedAt?: boolean
    lockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    createdBy?: boolean | Note$createdByArgs<ExtArgs>
    updatedBy?: boolean | Note$updatedByArgs<ExtArgs>
    versions?: boolean | Note$versionsArgs<ExtArgs>
    exportArtifacts?: boolean | Note$exportArtifactsArgs<ExtArgs>
    dispatchJobs?: boolean | Note$dispatchJobsArgs<ExtArgs>
    _count?: boolean | NoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    status?: boolean
    visibility?: boolean
    content?: boolean
    patientSummary?: boolean
    createdById?: boolean
    updatedById?: boolean
    finalizedAt?: boolean
    lockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    createdBy?: boolean | Note$createdByArgs<ExtArgs>
    updatedBy?: boolean | Note$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    status?: boolean
    visibility?: boolean
    content?: boolean
    patientSummary?: boolean
    createdById?: boolean
    updatedById?: boolean
    finalizedAt?: boolean
    lockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    createdBy?: boolean | Note$createdByArgs<ExtArgs>
    updatedBy?: boolean | Note$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectScalar = {
    id?: boolean
    encounterId?: boolean
    status?: boolean
    visibility?: boolean
    content?: boolean
    patientSummary?: boolean
    createdById?: boolean
    updatedById?: boolean
    finalizedAt?: boolean
    lockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "encounterId" | "status" | "visibility" | "content" | "patientSummary" | "createdById" | "updatedById" | "finalizedAt" | "lockedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["note"]>
  export type NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    createdBy?: boolean | Note$createdByArgs<ExtArgs>
    updatedBy?: boolean | Note$updatedByArgs<ExtArgs>
    versions?: boolean | Note$versionsArgs<ExtArgs>
    exportArtifacts?: boolean | Note$exportArtifactsArgs<ExtArgs>
    dispatchJobs?: boolean | Note$dispatchJobsArgs<ExtArgs>
    _count?: boolean | NoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    createdBy?: boolean | Note$createdByArgs<ExtArgs>
    updatedBy?: boolean | Note$updatedByArgs<ExtArgs>
  }
  export type NoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    createdBy?: boolean | Note$createdByArgs<ExtArgs>
    updatedBy?: boolean | Note$updatedByArgs<ExtArgs>
  }

  export type $NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      versions: Prisma.$NoteVersionPayload<ExtArgs>[]
      exportArtifacts: Prisma.$ExportArtifactPayload<ExtArgs>[]
      dispatchJobs: Prisma.$DispatchJobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      encounterId: string
      status: $Enums.NoteStatus
      visibility: $Enums.NoteVisibility
      content: string
      patientSummary: string
      createdById: string | null
      updatedById: string | null
      finalizedAt: Date | null
      lockedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["note"]>
    composites: {}
  }

  type NoteGetPayload<S extends boolean | null | undefined | NoteDefaultArgs> = $Result.GetResult<Prisma.$NotePayload, S>

  type NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoteCountAggregateInputType | true
    }

  export interface NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note'], meta: { name: 'Note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteFindUniqueArgs>(args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Note that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteFindFirstArgs>(args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteWithIdOnly = await prisma.note.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteFindManyArgs>(args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
     */
    create<T extends NoteCreateArgs>(args: SelectSubset<T, NoteCreateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notes.
     * @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteCreateManyArgs>(args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {NoteCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const noteWithIdOnly = await prisma.note.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoteCreateManyAndReturnArgs>(args?: SelectSubset<T, NoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
     */
    delete<T extends NoteDeleteArgs>(args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteUpdateArgs>(args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteDeleteManyArgs>(args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteUpdateManyArgs>(args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes and returns the data updated in the database.
     * @param {NoteUpdateManyAndReturnArgs} args - Arguments to update many Notes.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notes and only return the `id`
     * const noteWithIdOnly = await prisma.note.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NoteUpdateManyAndReturnArgs>(args: SelectSubset<T, NoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
     */
    upsert<T extends NoteUpsertArgs>(args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note model
   */
  readonly fields: NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Note$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Note$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Note$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Note$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    versions<T extends Note$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Note$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exportArtifacts<T extends Note$exportArtifactsArgs<ExtArgs> = {}>(args?: Subset<T, Note$exportArtifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dispatchJobs<T extends Note$dispatchJobsArgs<ExtArgs> = {}>(args?: Subset<T, Note$dispatchJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Note model
   */
  interface NoteFieldRefs {
    readonly id: FieldRef<"Note", 'String'>
    readonly encounterId: FieldRef<"Note", 'String'>
    readonly status: FieldRef<"Note", 'NoteStatus'>
    readonly visibility: FieldRef<"Note", 'NoteVisibility'>
    readonly content: FieldRef<"Note", 'String'>
    readonly patientSummary: FieldRef<"Note", 'String'>
    readonly createdById: FieldRef<"Note", 'String'>
    readonly updatedById: FieldRef<"Note", 'String'>
    readonly finalizedAt: FieldRef<"Note", 'DateTime'>
    readonly lockedAt: FieldRef<"Note", 'DateTime'>
    readonly createdAt: FieldRef<"Note", 'DateTime'>
    readonly updatedAt: FieldRef<"Note", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Note findUnique
   */
  export type NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findFirst
   */
  export type NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findMany
   */
  export type NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note create
   */
  export type NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Note.
     */
    data: XOR<NoteCreateInput, NoteUncheckedCreateInput>
  }

  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Note createManyAndReturn
   */
  export type NoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Note update
   */
  export type NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to update.
     */
    limit?: number
  }

  /**
   * Note updateManyAndReturn
   */
  export type NoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Note upsert
   */
  export type NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
  }

  /**
   * Note delete
   */
  export type NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to delete.
     */
    limit?: number
  }

  /**
   * Note.createdBy
   */
  export type Note$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Note.updatedBy
   */
  export type Note$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Note.versions
   */
  export type Note$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteVersion
     */
    select?: NoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteVersion
     */
    omit?: NoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteVersionInclude<ExtArgs> | null
    where?: NoteVersionWhereInput
    orderBy?: NoteVersionOrderByWithRelationInput | NoteVersionOrderByWithRelationInput[]
    cursor?: NoteVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteVersionScalarFieldEnum | NoteVersionScalarFieldEnum[]
  }

  /**
   * Note.exportArtifacts
   */
  export type Note$exportArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactInclude<ExtArgs> | null
    where?: ExportArtifactWhereInput
    orderBy?: ExportArtifactOrderByWithRelationInput | ExportArtifactOrderByWithRelationInput[]
    cursor?: ExportArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExportArtifactScalarFieldEnum | ExportArtifactScalarFieldEnum[]
  }

  /**
   * Note.dispatchJobs
   */
  export type Note$dispatchJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobInclude<ExtArgs> | null
    where?: DispatchJobWhereInput
    orderBy?: DispatchJobOrderByWithRelationInput | DispatchJobOrderByWithRelationInput[]
    cursor?: DispatchJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispatchJobScalarFieldEnum | DispatchJobScalarFieldEnum[]
  }

  /**
   * Note without action
   */
  export type NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
  }


  /**
   * Model NoteVersion
   */

  export type AggregateNoteVersion = {
    _count: NoteVersionCountAggregateOutputType | null
    _avg: NoteVersionAvgAggregateOutputType | null
    _sum: NoteVersionSumAggregateOutputType | null
    _min: NoteVersionMinAggregateOutputType | null
    _max: NoteVersionMaxAggregateOutputType | null
  }

  export type NoteVersionAvgAggregateOutputType = {
    versionNumber: number | null
  }

  export type NoteVersionSumAggregateOutputType = {
    versionNumber: number | null
  }

  export type NoteVersionMinAggregateOutputType = {
    id: string | null
    noteId: string | null
    versionNumber: number | null
    source: string | null
    content: string | null
    patientSummary: string | null
    traceId: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type NoteVersionMaxAggregateOutputType = {
    id: string | null
    noteId: string | null
    versionNumber: number | null
    source: string | null
    content: string | null
    patientSummary: string | null
    traceId: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type NoteVersionCountAggregateOutputType = {
    id: number
    noteId: number
    versionNumber: number
    source: number
    content: number
    patientSummary: number
    traceId: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type NoteVersionAvgAggregateInputType = {
    versionNumber?: true
  }

  export type NoteVersionSumAggregateInputType = {
    versionNumber?: true
  }

  export type NoteVersionMinAggregateInputType = {
    id?: true
    noteId?: true
    versionNumber?: true
    source?: true
    content?: true
    patientSummary?: true
    traceId?: true
    createdById?: true
    createdAt?: true
  }

  export type NoteVersionMaxAggregateInputType = {
    id?: true
    noteId?: true
    versionNumber?: true
    source?: true
    content?: true
    patientSummary?: true
    traceId?: true
    createdById?: true
    createdAt?: true
  }

  export type NoteVersionCountAggregateInputType = {
    id?: true
    noteId?: true
    versionNumber?: true
    source?: true
    content?: true
    patientSummary?: true
    traceId?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type NoteVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoteVersion to aggregate.
     */
    where?: NoteVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteVersions to fetch.
     */
    orderBy?: NoteVersionOrderByWithRelationInput | NoteVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NoteVersions
    **/
    _count?: true | NoteVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoteVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoteVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteVersionMaxAggregateInputType
  }

  export type GetNoteVersionAggregateType<T extends NoteVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateNoteVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoteVersion[P]>
      : GetScalarType<T[P], AggregateNoteVersion[P]>
  }




  export type NoteVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteVersionWhereInput
    orderBy?: NoteVersionOrderByWithAggregationInput | NoteVersionOrderByWithAggregationInput[]
    by: NoteVersionScalarFieldEnum[] | NoteVersionScalarFieldEnum
    having?: NoteVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteVersionCountAggregateInputType | true
    _avg?: NoteVersionAvgAggregateInputType
    _sum?: NoteVersionSumAggregateInputType
    _min?: NoteVersionMinAggregateInputType
    _max?: NoteVersionMaxAggregateInputType
  }

  export type NoteVersionGroupByOutputType = {
    id: string
    noteId: string
    versionNumber: number
    source: string
    content: string
    patientSummary: string
    traceId: string | null
    createdById: string | null
    createdAt: Date
    _count: NoteVersionCountAggregateOutputType | null
    _avg: NoteVersionAvgAggregateOutputType | null
    _sum: NoteVersionSumAggregateOutputType | null
    _min: NoteVersionMinAggregateOutputType | null
    _max: NoteVersionMaxAggregateOutputType | null
  }

  type GetNoteVersionGroupByPayload<T extends NoteVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteVersionGroupByOutputType[P]>
            : GetScalarType<T[P], NoteVersionGroupByOutputType[P]>
        }
      >
    >


  export type NoteVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    versionNumber?: boolean
    source?: boolean
    content?: boolean
    patientSummary?: boolean
    traceId?: boolean
    createdById?: boolean
    createdAt?: boolean
    note?: boolean | NoteDefaultArgs<ExtArgs>
    createdBy?: boolean | NoteVersion$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["noteVersion"]>

  export type NoteVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    versionNumber?: boolean
    source?: boolean
    content?: boolean
    patientSummary?: boolean
    traceId?: boolean
    createdById?: boolean
    createdAt?: boolean
    note?: boolean | NoteDefaultArgs<ExtArgs>
    createdBy?: boolean | NoteVersion$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["noteVersion"]>

  export type NoteVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    versionNumber?: boolean
    source?: boolean
    content?: boolean
    patientSummary?: boolean
    traceId?: boolean
    createdById?: boolean
    createdAt?: boolean
    note?: boolean | NoteDefaultArgs<ExtArgs>
    createdBy?: boolean | NoteVersion$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["noteVersion"]>

  export type NoteVersionSelectScalar = {
    id?: boolean
    noteId?: boolean
    versionNumber?: boolean
    source?: boolean
    content?: boolean
    patientSummary?: boolean
    traceId?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type NoteVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "noteId" | "versionNumber" | "source" | "content" | "patientSummary" | "traceId" | "createdById" | "createdAt", ExtArgs["result"]["noteVersion"]>
  export type NoteVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | NoteDefaultArgs<ExtArgs>
    createdBy?: boolean | NoteVersion$createdByArgs<ExtArgs>
  }
  export type NoteVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | NoteDefaultArgs<ExtArgs>
    createdBy?: boolean | NoteVersion$createdByArgs<ExtArgs>
  }
  export type NoteVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | NoteDefaultArgs<ExtArgs>
    createdBy?: boolean | NoteVersion$createdByArgs<ExtArgs>
  }

  export type $NoteVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NoteVersion"
    objects: {
      note: Prisma.$NotePayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      noteId: string
      versionNumber: number
      source: string
      content: string
      patientSummary: string
      traceId: string | null
      createdById: string | null
      createdAt: Date
    }, ExtArgs["result"]["noteVersion"]>
    composites: {}
  }

  type NoteVersionGetPayload<S extends boolean | null | undefined | NoteVersionDefaultArgs> = $Result.GetResult<Prisma.$NoteVersionPayload, S>

  type NoteVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoteVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoteVersionCountAggregateInputType | true
    }

  export interface NoteVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NoteVersion'], meta: { name: 'NoteVersion' } }
    /**
     * Find zero or one NoteVersion that matches the filter.
     * @param {NoteVersionFindUniqueArgs} args - Arguments to find a NoteVersion
     * @example
     * // Get one NoteVersion
     * const noteVersion = await prisma.noteVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteVersionFindUniqueArgs>(args: SelectSubset<T, NoteVersionFindUniqueArgs<ExtArgs>>): Prisma__NoteVersionClient<$Result.GetResult<Prisma.$NoteVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NoteVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoteVersionFindUniqueOrThrowArgs} args - Arguments to find a NoteVersion
     * @example
     * // Get one NoteVersion
     * const noteVersion = await prisma.noteVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteVersionClient<$Result.GetResult<Prisma.$NoteVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NoteVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteVersionFindFirstArgs} args - Arguments to find a NoteVersion
     * @example
     * // Get one NoteVersion
     * const noteVersion = await prisma.noteVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteVersionFindFirstArgs>(args?: SelectSubset<T, NoteVersionFindFirstArgs<ExtArgs>>): Prisma__NoteVersionClient<$Result.GetResult<Prisma.$NoteVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NoteVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteVersionFindFirstOrThrowArgs} args - Arguments to find a NoteVersion
     * @example
     * // Get one NoteVersion
     * const noteVersion = await prisma.noteVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteVersionClient<$Result.GetResult<Prisma.$NoteVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NoteVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoteVersions
     * const noteVersions = await prisma.noteVersion.findMany()
     * 
     * // Get first 10 NoteVersions
     * const noteVersions = await prisma.noteVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteVersionWithIdOnly = await prisma.noteVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteVersionFindManyArgs>(args?: SelectSubset<T, NoteVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NoteVersion.
     * @param {NoteVersionCreateArgs} args - Arguments to create a NoteVersion.
     * @example
     * // Create one NoteVersion
     * const NoteVersion = await prisma.noteVersion.create({
     *   data: {
     *     // ... data to create a NoteVersion
     *   }
     * })
     * 
     */
    create<T extends NoteVersionCreateArgs>(args: SelectSubset<T, NoteVersionCreateArgs<ExtArgs>>): Prisma__NoteVersionClient<$Result.GetResult<Prisma.$NoteVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NoteVersions.
     * @param {NoteVersionCreateManyArgs} args - Arguments to create many NoteVersions.
     * @example
     * // Create many NoteVersions
     * const noteVersion = await prisma.noteVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteVersionCreateManyArgs>(args?: SelectSubset<T, NoteVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NoteVersions and returns the data saved in the database.
     * @param {NoteVersionCreateManyAndReturnArgs} args - Arguments to create many NoteVersions.
     * @example
     * // Create many NoteVersions
     * const noteVersion = await prisma.noteVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NoteVersions and only return the `id`
     * const noteVersionWithIdOnly = await prisma.noteVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoteVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, NoteVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NoteVersion.
     * @param {NoteVersionDeleteArgs} args - Arguments to delete one NoteVersion.
     * @example
     * // Delete one NoteVersion
     * const NoteVersion = await prisma.noteVersion.delete({
     *   where: {
     *     // ... filter to delete one NoteVersion
     *   }
     * })
     * 
     */
    delete<T extends NoteVersionDeleteArgs>(args: SelectSubset<T, NoteVersionDeleteArgs<ExtArgs>>): Prisma__NoteVersionClient<$Result.GetResult<Prisma.$NoteVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NoteVersion.
     * @param {NoteVersionUpdateArgs} args - Arguments to update one NoteVersion.
     * @example
     * // Update one NoteVersion
     * const noteVersion = await prisma.noteVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteVersionUpdateArgs>(args: SelectSubset<T, NoteVersionUpdateArgs<ExtArgs>>): Prisma__NoteVersionClient<$Result.GetResult<Prisma.$NoteVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NoteVersions.
     * @param {NoteVersionDeleteManyArgs} args - Arguments to filter NoteVersions to delete.
     * @example
     * // Delete a few NoteVersions
     * const { count } = await prisma.noteVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteVersionDeleteManyArgs>(args?: SelectSubset<T, NoteVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoteVersions
     * const noteVersion = await prisma.noteVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteVersionUpdateManyArgs>(args: SelectSubset<T, NoteVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteVersions and returns the data updated in the database.
     * @param {NoteVersionUpdateManyAndReturnArgs} args - Arguments to update many NoteVersions.
     * @example
     * // Update many NoteVersions
     * const noteVersion = await prisma.noteVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NoteVersions and only return the `id`
     * const noteVersionWithIdOnly = await prisma.noteVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NoteVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, NoteVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NoteVersion.
     * @param {NoteVersionUpsertArgs} args - Arguments to update or create a NoteVersion.
     * @example
     * // Update or create a NoteVersion
     * const noteVersion = await prisma.noteVersion.upsert({
     *   create: {
     *     // ... data to create a NoteVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoteVersion we want to update
     *   }
     * })
     */
    upsert<T extends NoteVersionUpsertArgs>(args: SelectSubset<T, NoteVersionUpsertArgs<ExtArgs>>): Prisma__NoteVersionClient<$Result.GetResult<Prisma.$NoteVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NoteVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteVersionCountArgs} args - Arguments to filter NoteVersions to count.
     * @example
     * // Count the number of NoteVersions
     * const count = await prisma.noteVersion.count({
     *   where: {
     *     // ... the filter for the NoteVersions we want to count
     *   }
     * })
    **/
    count<T extends NoteVersionCountArgs>(
      args?: Subset<T, NoteVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoteVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteVersionAggregateArgs>(args: Subset<T, NoteVersionAggregateArgs>): Prisma.PrismaPromise<GetNoteVersionAggregateType<T>>

    /**
     * Group by NoteVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteVersionGroupByArgs['orderBy'] }
        : { orderBy?: NoteVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NoteVersion model
   */
  readonly fields: NoteVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NoteVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    note<T extends NoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NoteDefaultArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends NoteVersion$createdByArgs<ExtArgs> = {}>(args?: Subset<T, NoteVersion$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NoteVersion model
   */
  interface NoteVersionFieldRefs {
    readonly id: FieldRef<"NoteVersion", 'String'>
    readonly noteId: FieldRef<"NoteVersion", 'String'>
    readonly versionNumber: FieldRef<"NoteVersion", 'Int'>
    readonly source: FieldRef<"NoteVersion", 'String'>
    readonly content: FieldRef<"NoteVersion", 'String'>
    readonly patientSummary: FieldRef<"NoteVersion", 'String'>
    readonly traceId: FieldRef<"NoteVersion", 'String'>
    readonly createdById: FieldRef<"NoteVersion", 'String'>
    readonly createdAt: FieldRef<"NoteVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NoteVersion findUnique
   */
  export type NoteVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteVersion
     */
    select?: NoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteVersion
     */
    omit?: NoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteVersionInclude<ExtArgs> | null
    /**
     * Filter, which NoteVersion to fetch.
     */
    where: NoteVersionWhereUniqueInput
  }

  /**
   * NoteVersion findUniqueOrThrow
   */
  export type NoteVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteVersion
     */
    select?: NoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteVersion
     */
    omit?: NoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteVersionInclude<ExtArgs> | null
    /**
     * Filter, which NoteVersion to fetch.
     */
    where: NoteVersionWhereUniqueInput
  }

  /**
   * NoteVersion findFirst
   */
  export type NoteVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteVersion
     */
    select?: NoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteVersion
     */
    omit?: NoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteVersionInclude<ExtArgs> | null
    /**
     * Filter, which NoteVersion to fetch.
     */
    where?: NoteVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteVersions to fetch.
     */
    orderBy?: NoteVersionOrderByWithRelationInput | NoteVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoteVersions.
     */
    cursor?: NoteVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoteVersions.
     */
    distinct?: NoteVersionScalarFieldEnum | NoteVersionScalarFieldEnum[]
  }

  /**
   * NoteVersion findFirstOrThrow
   */
  export type NoteVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteVersion
     */
    select?: NoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteVersion
     */
    omit?: NoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteVersionInclude<ExtArgs> | null
    /**
     * Filter, which NoteVersion to fetch.
     */
    where?: NoteVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteVersions to fetch.
     */
    orderBy?: NoteVersionOrderByWithRelationInput | NoteVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoteVersions.
     */
    cursor?: NoteVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoteVersions.
     */
    distinct?: NoteVersionScalarFieldEnum | NoteVersionScalarFieldEnum[]
  }

  /**
   * NoteVersion findMany
   */
  export type NoteVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteVersion
     */
    select?: NoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteVersion
     */
    omit?: NoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteVersionInclude<ExtArgs> | null
    /**
     * Filter, which NoteVersions to fetch.
     */
    where?: NoteVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteVersions to fetch.
     */
    orderBy?: NoteVersionOrderByWithRelationInput | NoteVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NoteVersions.
     */
    cursor?: NoteVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteVersions.
     */
    skip?: number
    distinct?: NoteVersionScalarFieldEnum | NoteVersionScalarFieldEnum[]
  }

  /**
   * NoteVersion create
   */
  export type NoteVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteVersion
     */
    select?: NoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteVersion
     */
    omit?: NoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a NoteVersion.
     */
    data: XOR<NoteVersionCreateInput, NoteVersionUncheckedCreateInput>
  }

  /**
   * NoteVersion createMany
   */
  export type NoteVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NoteVersions.
     */
    data: NoteVersionCreateManyInput | NoteVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NoteVersion createManyAndReturn
   */
  export type NoteVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteVersion
     */
    select?: NoteVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NoteVersion
     */
    omit?: NoteVersionOmit<ExtArgs> | null
    /**
     * The data used to create many NoteVersions.
     */
    data: NoteVersionCreateManyInput | NoteVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NoteVersion update
   */
  export type NoteVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteVersion
     */
    select?: NoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteVersion
     */
    omit?: NoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a NoteVersion.
     */
    data: XOR<NoteVersionUpdateInput, NoteVersionUncheckedUpdateInput>
    /**
     * Choose, which NoteVersion to update.
     */
    where: NoteVersionWhereUniqueInput
  }

  /**
   * NoteVersion updateMany
   */
  export type NoteVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NoteVersions.
     */
    data: XOR<NoteVersionUpdateManyMutationInput, NoteVersionUncheckedUpdateManyInput>
    /**
     * Filter which NoteVersions to update
     */
    where?: NoteVersionWhereInput
    /**
     * Limit how many NoteVersions to update.
     */
    limit?: number
  }

  /**
   * NoteVersion updateManyAndReturn
   */
  export type NoteVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteVersion
     */
    select?: NoteVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NoteVersion
     */
    omit?: NoteVersionOmit<ExtArgs> | null
    /**
     * The data used to update NoteVersions.
     */
    data: XOR<NoteVersionUpdateManyMutationInput, NoteVersionUncheckedUpdateManyInput>
    /**
     * Filter which NoteVersions to update
     */
    where?: NoteVersionWhereInput
    /**
     * Limit how many NoteVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NoteVersion upsert
   */
  export type NoteVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteVersion
     */
    select?: NoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteVersion
     */
    omit?: NoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the NoteVersion to update in case it exists.
     */
    where: NoteVersionWhereUniqueInput
    /**
     * In case the NoteVersion found by the `where` argument doesn't exist, create a new NoteVersion with this data.
     */
    create: XOR<NoteVersionCreateInput, NoteVersionUncheckedCreateInput>
    /**
     * In case the NoteVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteVersionUpdateInput, NoteVersionUncheckedUpdateInput>
  }

  /**
   * NoteVersion delete
   */
  export type NoteVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteVersion
     */
    select?: NoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteVersion
     */
    omit?: NoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteVersionInclude<ExtArgs> | null
    /**
     * Filter which NoteVersion to delete.
     */
    where: NoteVersionWhereUniqueInput
  }

  /**
   * NoteVersion deleteMany
   */
  export type NoteVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoteVersions to delete
     */
    where?: NoteVersionWhereInput
    /**
     * Limit how many NoteVersions to delete.
     */
    limit?: number
  }

  /**
   * NoteVersion.createdBy
   */
  export type NoteVersion$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * NoteVersion without action
   */
  export type NoteVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteVersion
     */
    select?: NoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteVersion
     */
    omit?: NoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteVersionInclude<ExtArgs> | null
  }


  /**
   * Model TranscriptSegment
   */

  export type AggregateTranscriptSegment = {
    _count: TranscriptSegmentCountAggregateOutputType | null
    _avg: TranscriptSegmentAvgAggregateOutputType | null
    _sum: TranscriptSegmentSumAggregateOutputType | null
    _min: TranscriptSegmentMinAggregateOutputType | null
    _max: TranscriptSegmentMaxAggregateOutputType | null
  }

  export type TranscriptSegmentAvgAggregateOutputType = {
    startMs: number | null
    endMs: number | null
    confidence: number | null
  }

  export type TranscriptSegmentSumAggregateOutputType = {
    startMs: number | null
    endMs: number | null
    confidence: number | null
  }

  export type TranscriptSegmentMinAggregateOutputType = {
    id: string | null
    encounterId: string | null
    speaker: string | null
    speakerLabel: string | null
    text: string | null
    startMs: number | null
    endMs: number | null
    source: $Enums.TranscriptSource | null
    confidence: number | null
    createdAt: Date | null
  }

  export type TranscriptSegmentMaxAggregateOutputType = {
    id: string | null
    encounterId: string | null
    speaker: string | null
    speakerLabel: string | null
    text: string | null
    startMs: number | null
    endMs: number | null
    source: $Enums.TranscriptSource | null
    confidence: number | null
    createdAt: Date | null
  }

  export type TranscriptSegmentCountAggregateOutputType = {
    id: number
    encounterId: number
    speaker: number
    speakerLabel: number
    text: number
    startMs: number
    endMs: number
    source: number
    confidence: number
    createdAt: number
    _all: number
  }


  export type TranscriptSegmentAvgAggregateInputType = {
    startMs?: true
    endMs?: true
    confidence?: true
  }

  export type TranscriptSegmentSumAggregateInputType = {
    startMs?: true
    endMs?: true
    confidence?: true
  }

  export type TranscriptSegmentMinAggregateInputType = {
    id?: true
    encounterId?: true
    speaker?: true
    speakerLabel?: true
    text?: true
    startMs?: true
    endMs?: true
    source?: true
    confidence?: true
    createdAt?: true
  }

  export type TranscriptSegmentMaxAggregateInputType = {
    id?: true
    encounterId?: true
    speaker?: true
    speakerLabel?: true
    text?: true
    startMs?: true
    endMs?: true
    source?: true
    confidence?: true
    createdAt?: true
  }

  export type TranscriptSegmentCountAggregateInputType = {
    id?: true
    encounterId?: true
    speaker?: true
    speakerLabel?: true
    text?: true
    startMs?: true
    endMs?: true
    source?: true
    confidence?: true
    createdAt?: true
    _all?: true
  }

  export type TranscriptSegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranscriptSegment to aggregate.
     */
    where?: TranscriptSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptSegments to fetch.
     */
    orderBy?: TranscriptSegmentOrderByWithRelationInput | TranscriptSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranscriptSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TranscriptSegments
    **/
    _count?: true | TranscriptSegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranscriptSegmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranscriptSegmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptSegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptSegmentMaxAggregateInputType
  }

  export type GetTranscriptSegmentAggregateType<T extends TranscriptSegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscriptSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscriptSegment[P]>
      : GetScalarType<T[P], AggregateTranscriptSegment[P]>
  }




  export type TranscriptSegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptSegmentWhereInput
    orderBy?: TranscriptSegmentOrderByWithAggregationInput | TranscriptSegmentOrderByWithAggregationInput[]
    by: TranscriptSegmentScalarFieldEnum[] | TranscriptSegmentScalarFieldEnum
    having?: TranscriptSegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptSegmentCountAggregateInputType | true
    _avg?: TranscriptSegmentAvgAggregateInputType
    _sum?: TranscriptSegmentSumAggregateInputType
    _min?: TranscriptSegmentMinAggregateInputType
    _max?: TranscriptSegmentMaxAggregateInputType
  }

  export type TranscriptSegmentGroupByOutputType = {
    id: string
    encounterId: string
    speaker: string
    speakerLabel: string | null
    text: string
    startMs: number
    endMs: number
    source: $Enums.TranscriptSource
    confidence: number | null
    createdAt: Date
    _count: TranscriptSegmentCountAggregateOutputType | null
    _avg: TranscriptSegmentAvgAggregateOutputType | null
    _sum: TranscriptSegmentSumAggregateOutputType | null
    _min: TranscriptSegmentMinAggregateOutputType | null
    _max: TranscriptSegmentMaxAggregateOutputType | null
  }

  type GetTranscriptSegmentGroupByPayload<T extends TranscriptSegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranscriptSegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptSegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptSegmentGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptSegmentGroupByOutputType[P]>
        }
      >
    >


  export type TranscriptSegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    speaker?: boolean
    speakerLabel?: boolean
    text?: boolean
    startMs?: boolean
    endMs?: boolean
    source?: boolean
    confidence?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcriptSegment"]>

  export type TranscriptSegmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    speaker?: boolean
    speakerLabel?: boolean
    text?: boolean
    startMs?: boolean
    endMs?: boolean
    source?: boolean
    confidence?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcriptSegment"]>

  export type TranscriptSegmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    speaker?: boolean
    speakerLabel?: boolean
    text?: boolean
    startMs?: boolean
    endMs?: boolean
    source?: boolean
    confidence?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcriptSegment"]>

  export type TranscriptSegmentSelectScalar = {
    id?: boolean
    encounterId?: boolean
    speaker?: boolean
    speakerLabel?: boolean
    text?: boolean
    startMs?: boolean
    endMs?: boolean
    source?: boolean
    confidence?: boolean
    createdAt?: boolean
  }

  export type TranscriptSegmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "encounterId" | "speaker" | "speakerLabel" | "text" | "startMs" | "endMs" | "source" | "confidence" | "createdAt", ExtArgs["result"]["transcriptSegment"]>
  export type TranscriptSegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }
  export type TranscriptSegmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }
  export type TranscriptSegmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }

  export type $TranscriptSegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TranscriptSegment"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      encounterId: string
      speaker: string
      speakerLabel: string | null
      text: string
      startMs: number
      endMs: number
      source: $Enums.TranscriptSource
      confidence: number | null
      createdAt: Date
    }, ExtArgs["result"]["transcriptSegment"]>
    composites: {}
  }

  type TranscriptSegmentGetPayload<S extends boolean | null | undefined | TranscriptSegmentDefaultArgs> = $Result.GetResult<Prisma.$TranscriptSegmentPayload, S>

  type TranscriptSegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TranscriptSegmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TranscriptSegmentCountAggregateInputType | true
    }

  export interface TranscriptSegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TranscriptSegment'], meta: { name: 'TranscriptSegment' } }
    /**
     * Find zero or one TranscriptSegment that matches the filter.
     * @param {TranscriptSegmentFindUniqueArgs} args - Arguments to find a TranscriptSegment
     * @example
     * // Get one TranscriptSegment
     * const transcriptSegment = await prisma.transcriptSegment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranscriptSegmentFindUniqueArgs>(args: SelectSubset<T, TranscriptSegmentFindUniqueArgs<ExtArgs>>): Prisma__TranscriptSegmentClient<$Result.GetResult<Prisma.$TranscriptSegmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TranscriptSegment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TranscriptSegmentFindUniqueOrThrowArgs} args - Arguments to find a TranscriptSegment
     * @example
     * // Get one TranscriptSegment
     * const transcriptSegment = await prisma.transcriptSegment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranscriptSegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TranscriptSegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranscriptSegmentClient<$Result.GetResult<Prisma.$TranscriptSegmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TranscriptSegment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptSegmentFindFirstArgs} args - Arguments to find a TranscriptSegment
     * @example
     * // Get one TranscriptSegment
     * const transcriptSegment = await prisma.transcriptSegment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranscriptSegmentFindFirstArgs>(args?: SelectSubset<T, TranscriptSegmentFindFirstArgs<ExtArgs>>): Prisma__TranscriptSegmentClient<$Result.GetResult<Prisma.$TranscriptSegmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TranscriptSegment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptSegmentFindFirstOrThrowArgs} args - Arguments to find a TranscriptSegment
     * @example
     * // Get one TranscriptSegment
     * const transcriptSegment = await prisma.transcriptSegment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranscriptSegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TranscriptSegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranscriptSegmentClient<$Result.GetResult<Prisma.$TranscriptSegmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TranscriptSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptSegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranscriptSegments
     * const transcriptSegments = await prisma.transcriptSegment.findMany()
     * 
     * // Get first 10 TranscriptSegments
     * const transcriptSegments = await prisma.transcriptSegment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transcriptSegmentWithIdOnly = await prisma.transcriptSegment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranscriptSegmentFindManyArgs>(args?: SelectSubset<T, TranscriptSegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptSegmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TranscriptSegment.
     * @param {TranscriptSegmentCreateArgs} args - Arguments to create a TranscriptSegment.
     * @example
     * // Create one TranscriptSegment
     * const TranscriptSegment = await prisma.transcriptSegment.create({
     *   data: {
     *     // ... data to create a TranscriptSegment
     *   }
     * })
     * 
     */
    create<T extends TranscriptSegmentCreateArgs>(args: SelectSubset<T, TranscriptSegmentCreateArgs<ExtArgs>>): Prisma__TranscriptSegmentClient<$Result.GetResult<Prisma.$TranscriptSegmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TranscriptSegments.
     * @param {TranscriptSegmentCreateManyArgs} args - Arguments to create many TranscriptSegments.
     * @example
     * // Create many TranscriptSegments
     * const transcriptSegment = await prisma.transcriptSegment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranscriptSegmentCreateManyArgs>(args?: SelectSubset<T, TranscriptSegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TranscriptSegments and returns the data saved in the database.
     * @param {TranscriptSegmentCreateManyAndReturnArgs} args - Arguments to create many TranscriptSegments.
     * @example
     * // Create many TranscriptSegments
     * const transcriptSegment = await prisma.transcriptSegment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TranscriptSegments and only return the `id`
     * const transcriptSegmentWithIdOnly = await prisma.transcriptSegment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TranscriptSegmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TranscriptSegmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptSegmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TranscriptSegment.
     * @param {TranscriptSegmentDeleteArgs} args - Arguments to delete one TranscriptSegment.
     * @example
     * // Delete one TranscriptSegment
     * const TranscriptSegment = await prisma.transcriptSegment.delete({
     *   where: {
     *     // ... filter to delete one TranscriptSegment
     *   }
     * })
     * 
     */
    delete<T extends TranscriptSegmentDeleteArgs>(args: SelectSubset<T, TranscriptSegmentDeleteArgs<ExtArgs>>): Prisma__TranscriptSegmentClient<$Result.GetResult<Prisma.$TranscriptSegmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TranscriptSegment.
     * @param {TranscriptSegmentUpdateArgs} args - Arguments to update one TranscriptSegment.
     * @example
     * // Update one TranscriptSegment
     * const transcriptSegment = await prisma.transcriptSegment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranscriptSegmentUpdateArgs>(args: SelectSubset<T, TranscriptSegmentUpdateArgs<ExtArgs>>): Prisma__TranscriptSegmentClient<$Result.GetResult<Prisma.$TranscriptSegmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TranscriptSegments.
     * @param {TranscriptSegmentDeleteManyArgs} args - Arguments to filter TranscriptSegments to delete.
     * @example
     * // Delete a few TranscriptSegments
     * const { count } = await prisma.transcriptSegment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranscriptSegmentDeleteManyArgs>(args?: SelectSubset<T, TranscriptSegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranscriptSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptSegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranscriptSegments
     * const transcriptSegment = await prisma.transcriptSegment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranscriptSegmentUpdateManyArgs>(args: SelectSubset<T, TranscriptSegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranscriptSegments and returns the data updated in the database.
     * @param {TranscriptSegmentUpdateManyAndReturnArgs} args - Arguments to update many TranscriptSegments.
     * @example
     * // Update many TranscriptSegments
     * const transcriptSegment = await prisma.transcriptSegment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TranscriptSegments and only return the `id`
     * const transcriptSegmentWithIdOnly = await prisma.transcriptSegment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TranscriptSegmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TranscriptSegmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptSegmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TranscriptSegment.
     * @param {TranscriptSegmentUpsertArgs} args - Arguments to update or create a TranscriptSegment.
     * @example
     * // Update or create a TranscriptSegment
     * const transcriptSegment = await prisma.transcriptSegment.upsert({
     *   create: {
     *     // ... data to create a TranscriptSegment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranscriptSegment we want to update
     *   }
     * })
     */
    upsert<T extends TranscriptSegmentUpsertArgs>(args: SelectSubset<T, TranscriptSegmentUpsertArgs<ExtArgs>>): Prisma__TranscriptSegmentClient<$Result.GetResult<Prisma.$TranscriptSegmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TranscriptSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptSegmentCountArgs} args - Arguments to filter TranscriptSegments to count.
     * @example
     * // Count the number of TranscriptSegments
     * const count = await prisma.transcriptSegment.count({
     *   where: {
     *     // ... the filter for the TranscriptSegments we want to count
     *   }
     * })
    **/
    count<T extends TranscriptSegmentCountArgs>(
      args?: Subset<T, TranscriptSegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptSegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TranscriptSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptSegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptSegmentAggregateArgs>(args: Subset<T, TranscriptSegmentAggregateArgs>): Prisma.PrismaPromise<GetTranscriptSegmentAggregateType<T>>

    /**
     * Group by TranscriptSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptSegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptSegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptSegmentGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptSegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptSegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TranscriptSegment model
   */
  readonly fields: TranscriptSegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TranscriptSegment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranscriptSegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TranscriptSegment model
   */
  interface TranscriptSegmentFieldRefs {
    readonly id: FieldRef<"TranscriptSegment", 'String'>
    readonly encounterId: FieldRef<"TranscriptSegment", 'String'>
    readonly speaker: FieldRef<"TranscriptSegment", 'String'>
    readonly speakerLabel: FieldRef<"TranscriptSegment", 'String'>
    readonly text: FieldRef<"TranscriptSegment", 'String'>
    readonly startMs: FieldRef<"TranscriptSegment", 'Int'>
    readonly endMs: FieldRef<"TranscriptSegment", 'Int'>
    readonly source: FieldRef<"TranscriptSegment", 'TranscriptSource'>
    readonly confidence: FieldRef<"TranscriptSegment", 'Float'>
    readonly createdAt: FieldRef<"TranscriptSegment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TranscriptSegment findUnique
   */
  export type TranscriptSegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptSegment to fetch.
     */
    where: TranscriptSegmentWhereUniqueInput
  }

  /**
   * TranscriptSegment findUniqueOrThrow
   */
  export type TranscriptSegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptSegment to fetch.
     */
    where: TranscriptSegmentWhereUniqueInput
  }

  /**
   * TranscriptSegment findFirst
   */
  export type TranscriptSegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptSegment to fetch.
     */
    where?: TranscriptSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptSegments to fetch.
     */
    orderBy?: TranscriptSegmentOrderByWithRelationInput | TranscriptSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptSegments.
     */
    cursor?: TranscriptSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptSegments.
     */
    distinct?: TranscriptSegmentScalarFieldEnum | TranscriptSegmentScalarFieldEnum[]
  }

  /**
   * TranscriptSegment findFirstOrThrow
   */
  export type TranscriptSegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptSegment to fetch.
     */
    where?: TranscriptSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptSegments to fetch.
     */
    orderBy?: TranscriptSegmentOrderByWithRelationInput | TranscriptSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptSegments.
     */
    cursor?: TranscriptSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptSegments.
     */
    distinct?: TranscriptSegmentScalarFieldEnum | TranscriptSegmentScalarFieldEnum[]
  }

  /**
   * TranscriptSegment findMany
   */
  export type TranscriptSegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptSegments to fetch.
     */
    where?: TranscriptSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptSegments to fetch.
     */
    orderBy?: TranscriptSegmentOrderByWithRelationInput | TranscriptSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TranscriptSegments.
     */
    cursor?: TranscriptSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptSegments.
     */
    skip?: number
    distinct?: TranscriptSegmentScalarFieldEnum | TranscriptSegmentScalarFieldEnum[]
  }

  /**
   * TranscriptSegment create
   */
  export type TranscriptSegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TranscriptSegment.
     */
    data: XOR<TranscriptSegmentCreateInput, TranscriptSegmentUncheckedCreateInput>
  }

  /**
   * TranscriptSegment createMany
   */
  export type TranscriptSegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TranscriptSegments.
     */
    data: TranscriptSegmentCreateManyInput | TranscriptSegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TranscriptSegment createManyAndReturn
   */
  export type TranscriptSegmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null
    /**
     * The data used to create many TranscriptSegments.
     */
    data: TranscriptSegmentCreateManyInput | TranscriptSegmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TranscriptSegment update
   */
  export type TranscriptSegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TranscriptSegment.
     */
    data: XOR<TranscriptSegmentUpdateInput, TranscriptSegmentUncheckedUpdateInput>
    /**
     * Choose, which TranscriptSegment to update.
     */
    where: TranscriptSegmentWhereUniqueInput
  }

  /**
   * TranscriptSegment updateMany
   */
  export type TranscriptSegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TranscriptSegments.
     */
    data: XOR<TranscriptSegmentUpdateManyMutationInput, TranscriptSegmentUncheckedUpdateManyInput>
    /**
     * Filter which TranscriptSegments to update
     */
    where?: TranscriptSegmentWhereInput
    /**
     * Limit how many TranscriptSegments to update.
     */
    limit?: number
  }

  /**
   * TranscriptSegment updateManyAndReturn
   */
  export type TranscriptSegmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null
    /**
     * The data used to update TranscriptSegments.
     */
    data: XOR<TranscriptSegmentUpdateManyMutationInput, TranscriptSegmentUncheckedUpdateManyInput>
    /**
     * Filter which TranscriptSegments to update
     */
    where?: TranscriptSegmentWhereInput
    /**
     * Limit how many TranscriptSegments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TranscriptSegment upsert
   */
  export type TranscriptSegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TranscriptSegment to update in case it exists.
     */
    where: TranscriptSegmentWhereUniqueInput
    /**
     * In case the TranscriptSegment found by the `where` argument doesn't exist, create a new TranscriptSegment with this data.
     */
    create: XOR<TranscriptSegmentCreateInput, TranscriptSegmentUncheckedCreateInput>
    /**
     * In case the TranscriptSegment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranscriptSegmentUpdateInput, TranscriptSegmentUncheckedUpdateInput>
  }

  /**
   * TranscriptSegment delete
   */
  export type TranscriptSegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null
    /**
     * Filter which TranscriptSegment to delete.
     */
    where: TranscriptSegmentWhereUniqueInput
  }

  /**
   * TranscriptSegment deleteMany
   */
  export type TranscriptSegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranscriptSegments to delete
     */
    where?: TranscriptSegmentWhereInput
    /**
     * Limit how many TranscriptSegments to delete.
     */
    limit?: number
  }

  /**
   * TranscriptSegment without action
   */
  export type TranscriptSegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptSegment
     */
    select?: TranscriptSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptSegment
     */
    omit?: TranscriptSegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptSegmentInclude<ExtArgs> | null
  }


  /**
   * Model ChartAsset
   */

  export type AggregateChartAsset = {
    _count: ChartAssetCountAggregateOutputType | null
    _avg: ChartAssetAvgAggregateOutputType | null
    _sum: ChartAssetSumAggregateOutputType | null
    _min: ChartAssetMinAggregateOutputType | null
    _max: ChartAssetMaxAggregateOutputType | null
  }

  export type ChartAssetAvgAggregateOutputType = {
    sizeBytes: number | null
  }

  export type ChartAssetSumAggregateOutputType = {
    sizeBytes: number | null
  }

  export type ChartAssetMinAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    encounterId: string | null
    patientId: string | null
    fileName: string | null
    mimeType: string | null
    sizeBytes: number | null
    storagePath: string | null
    rawText: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type ChartAssetMaxAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    encounterId: string | null
    patientId: string | null
    fileName: string | null
    mimeType: string | null
    sizeBytes: number | null
    storagePath: string | null
    rawText: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type ChartAssetCountAggregateOutputType = {
    id: number
    appointmentId: number
    encounterId: number
    patientId: number
    fileName: number
    mimeType: number
    sizeBytes: number
    storagePath: number
    extractedJson: number
    rawText: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type ChartAssetAvgAggregateInputType = {
    sizeBytes?: true
  }

  export type ChartAssetSumAggregateInputType = {
    sizeBytes?: true
  }

  export type ChartAssetMinAggregateInputType = {
    id?: true
    appointmentId?: true
    encounterId?: true
    patientId?: true
    fileName?: true
    mimeType?: true
    sizeBytes?: true
    storagePath?: true
    rawText?: true
    createdById?: true
    createdAt?: true
  }

  export type ChartAssetMaxAggregateInputType = {
    id?: true
    appointmentId?: true
    encounterId?: true
    patientId?: true
    fileName?: true
    mimeType?: true
    sizeBytes?: true
    storagePath?: true
    rawText?: true
    createdById?: true
    createdAt?: true
  }

  export type ChartAssetCountAggregateInputType = {
    id?: true
    appointmentId?: true
    encounterId?: true
    patientId?: true
    fileName?: true
    mimeType?: true
    sizeBytes?: true
    storagePath?: true
    extractedJson?: true
    rawText?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type ChartAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartAsset to aggregate.
     */
    where?: ChartAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartAssets to fetch.
     */
    orderBy?: ChartAssetOrderByWithRelationInput | ChartAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChartAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChartAssets
    **/
    _count?: true | ChartAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChartAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChartAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChartAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChartAssetMaxAggregateInputType
  }

  export type GetChartAssetAggregateType<T extends ChartAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateChartAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChartAsset[P]>
      : GetScalarType<T[P], AggregateChartAsset[P]>
  }




  export type ChartAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartAssetWhereInput
    orderBy?: ChartAssetOrderByWithAggregationInput | ChartAssetOrderByWithAggregationInput[]
    by: ChartAssetScalarFieldEnum[] | ChartAssetScalarFieldEnum
    having?: ChartAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChartAssetCountAggregateInputType | true
    _avg?: ChartAssetAvgAggregateInputType
    _sum?: ChartAssetSumAggregateInputType
    _min?: ChartAssetMinAggregateInputType
    _max?: ChartAssetMaxAggregateInputType
  }

  export type ChartAssetGroupByOutputType = {
    id: string
    appointmentId: string | null
    encounterId: string | null
    patientId: string | null
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson: JsonValue | null
    rawText: string | null
    createdById: string | null
    createdAt: Date
    _count: ChartAssetCountAggregateOutputType | null
    _avg: ChartAssetAvgAggregateOutputType | null
    _sum: ChartAssetSumAggregateOutputType | null
    _min: ChartAssetMinAggregateOutputType | null
    _max: ChartAssetMaxAggregateOutputType | null
  }

  type GetChartAssetGroupByPayload<T extends ChartAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChartAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChartAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChartAssetGroupByOutputType[P]>
            : GetScalarType<T[P], ChartAssetGroupByOutputType[P]>
        }
      >
    >


  export type ChartAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    encounterId?: boolean
    patientId?: boolean
    fileName?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    storagePath?: boolean
    extractedJson?: boolean
    rawText?: boolean
    createdById?: boolean
    createdAt?: boolean
    appointment?: boolean | ChartAsset$appointmentArgs<ExtArgs>
    encounter?: boolean | ChartAsset$encounterArgs<ExtArgs>
    patient?: boolean | ChartAsset$patientArgs<ExtArgs>
    createdBy?: boolean | ChartAsset$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["chartAsset"]>

  export type ChartAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    encounterId?: boolean
    patientId?: boolean
    fileName?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    storagePath?: boolean
    extractedJson?: boolean
    rawText?: boolean
    createdById?: boolean
    createdAt?: boolean
    appointment?: boolean | ChartAsset$appointmentArgs<ExtArgs>
    encounter?: boolean | ChartAsset$encounterArgs<ExtArgs>
    patient?: boolean | ChartAsset$patientArgs<ExtArgs>
    createdBy?: boolean | ChartAsset$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["chartAsset"]>

  export type ChartAssetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    encounterId?: boolean
    patientId?: boolean
    fileName?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    storagePath?: boolean
    extractedJson?: boolean
    rawText?: boolean
    createdById?: boolean
    createdAt?: boolean
    appointment?: boolean | ChartAsset$appointmentArgs<ExtArgs>
    encounter?: boolean | ChartAsset$encounterArgs<ExtArgs>
    patient?: boolean | ChartAsset$patientArgs<ExtArgs>
    createdBy?: boolean | ChartAsset$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["chartAsset"]>

  export type ChartAssetSelectScalar = {
    id?: boolean
    appointmentId?: boolean
    encounterId?: boolean
    patientId?: boolean
    fileName?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    storagePath?: boolean
    extractedJson?: boolean
    rawText?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type ChartAssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appointmentId" | "encounterId" | "patientId" | "fileName" | "mimeType" | "sizeBytes" | "storagePath" | "extractedJson" | "rawText" | "createdById" | "createdAt", ExtArgs["result"]["chartAsset"]>
  export type ChartAssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | ChartAsset$appointmentArgs<ExtArgs>
    encounter?: boolean | ChartAsset$encounterArgs<ExtArgs>
    patient?: boolean | ChartAsset$patientArgs<ExtArgs>
    createdBy?: boolean | ChartAsset$createdByArgs<ExtArgs>
  }
  export type ChartAssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | ChartAsset$appointmentArgs<ExtArgs>
    encounter?: boolean | ChartAsset$encounterArgs<ExtArgs>
    patient?: boolean | ChartAsset$patientArgs<ExtArgs>
    createdBy?: boolean | ChartAsset$createdByArgs<ExtArgs>
  }
  export type ChartAssetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | ChartAsset$appointmentArgs<ExtArgs>
    encounter?: boolean | ChartAsset$encounterArgs<ExtArgs>
    patient?: boolean | ChartAsset$patientArgs<ExtArgs>
    createdBy?: boolean | ChartAsset$createdByArgs<ExtArgs>
  }

  export type $ChartAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChartAsset"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      encounter: Prisma.$EncounterPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      appointmentId: string | null
      encounterId: string | null
      patientId: string | null
      fileName: string
      mimeType: string
      sizeBytes: number
      storagePath: string
      extractedJson: Prisma.JsonValue | null
      rawText: string | null
      createdById: string | null
      createdAt: Date
    }, ExtArgs["result"]["chartAsset"]>
    composites: {}
  }

  type ChartAssetGetPayload<S extends boolean | null | undefined | ChartAssetDefaultArgs> = $Result.GetResult<Prisma.$ChartAssetPayload, S>

  type ChartAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChartAssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChartAssetCountAggregateInputType | true
    }

  export interface ChartAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChartAsset'], meta: { name: 'ChartAsset' } }
    /**
     * Find zero or one ChartAsset that matches the filter.
     * @param {ChartAssetFindUniqueArgs} args - Arguments to find a ChartAsset
     * @example
     * // Get one ChartAsset
     * const chartAsset = await prisma.chartAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChartAssetFindUniqueArgs>(args: SelectSubset<T, ChartAssetFindUniqueArgs<ExtArgs>>): Prisma__ChartAssetClient<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChartAsset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChartAssetFindUniqueOrThrowArgs} args - Arguments to find a ChartAsset
     * @example
     * // Get one ChartAsset
     * const chartAsset = await prisma.chartAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChartAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, ChartAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChartAssetClient<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChartAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartAssetFindFirstArgs} args - Arguments to find a ChartAsset
     * @example
     * // Get one ChartAsset
     * const chartAsset = await prisma.chartAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChartAssetFindFirstArgs>(args?: SelectSubset<T, ChartAssetFindFirstArgs<ExtArgs>>): Prisma__ChartAssetClient<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChartAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartAssetFindFirstOrThrowArgs} args - Arguments to find a ChartAsset
     * @example
     * // Get one ChartAsset
     * const chartAsset = await prisma.chartAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChartAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, ChartAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChartAssetClient<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChartAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChartAssets
     * const chartAssets = await prisma.chartAsset.findMany()
     * 
     * // Get first 10 ChartAssets
     * const chartAssets = await prisma.chartAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chartAssetWithIdOnly = await prisma.chartAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChartAssetFindManyArgs>(args?: SelectSubset<T, ChartAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChartAsset.
     * @param {ChartAssetCreateArgs} args - Arguments to create a ChartAsset.
     * @example
     * // Create one ChartAsset
     * const ChartAsset = await prisma.chartAsset.create({
     *   data: {
     *     // ... data to create a ChartAsset
     *   }
     * })
     * 
     */
    create<T extends ChartAssetCreateArgs>(args: SelectSubset<T, ChartAssetCreateArgs<ExtArgs>>): Prisma__ChartAssetClient<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChartAssets.
     * @param {ChartAssetCreateManyArgs} args - Arguments to create many ChartAssets.
     * @example
     * // Create many ChartAssets
     * const chartAsset = await prisma.chartAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChartAssetCreateManyArgs>(args?: SelectSubset<T, ChartAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChartAssets and returns the data saved in the database.
     * @param {ChartAssetCreateManyAndReturnArgs} args - Arguments to create many ChartAssets.
     * @example
     * // Create many ChartAssets
     * const chartAsset = await prisma.chartAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChartAssets and only return the `id`
     * const chartAssetWithIdOnly = await prisma.chartAsset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChartAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, ChartAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChartAsset.
     * @param {ChartAssetDeleteArgs} args - Arguments to delete one ChartAsset.
     * @example
     * // Delete one ChartAsset
     * const ChartAsset = await prisma.chartAsset.delete({
     *   where: {
     *     // ... filter to delete one ChartAsset
     *   }
     * })
     * 
     */
    delete<T extends ChartAssetDeleteArgs>(args: SelectSubset<T, ChartAssetDeleteArgs<ExtArgs>>): Prisma__ChartAssetClient<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChartAsset.
     * @param {ChartAssetUpdateArgs} args - Arguments to update one ChartAsset.
     * @example
     * // Update one ChartAsset
     * const chartAsset = await prisma.chartAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChartAssetUpdateArgs>(args: SelectSubset<T, ChartAssetUpdateArgs<ExtArgs>>): Prisma__ChartAssetClient<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChartAssets.
     * @param {ChartAssetDeleteManyArgs} args - Arguments to filter ChartAssets to delete.
     * @example
     * // Delete a few ChartAssets
     * const { count } = await prisma.chartAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChartAssetDeleteManyArgs>(args?: SelectSubset<T, ChartAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChartAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChartAssets
     * const chartAsset = await prisma.chartAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChartAssetUpdateManyArgs>(args: SelectSubset<T, ChartAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChartAssets and returns the data updated in the database.
     * @param {ChartAssetUpdateManyAndReturnArgs} args - Arguments to update many ChartAssets.
     * @example
     * // Update many ChartAssets
     * const chartAsset = await prisma.chartAsset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChartAssets and only return the `id`
     * const chartAssetWithIdOnly = await prisma.chartAsset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChartAssetUpdateManyAndReturnArgs>(args: SelectSubset<T, ChartAssetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChartAsset.
     * @param {ChartAssetUpsertArgs} args - Arguments to update or create a ChartAsset.
     * @example
     * // Update or create a ChartAsset
     * const chartAsset = await prisma.chartAsset.upsert({
     *   create: {
     *     // ... data to create a ChartAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChartAsset we want to update
     *   }
     * })
     */
    upsert<T extends ChartAssetUpsertArgs>(args: SelectSubset<T, ChartAssetUpsertArgs<ExtArgs>>): Prisma__ChartAssetClient<$Result.GetResult<Prisma.$ChartAssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChartAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartAssetCountArgs} args - Arguments to filter ChartAssets to count.
     * @example
     * // Count the number of ChartAssets
     * const count = await prisma.chartAsset.count({
     *   where: {
     *     // ... the filter for the ChartAssets we want to count
     *   }
     * })
    **/
    count<T extends ChartAssetCountArgs>(
      args?: Subset<T, ChartAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChartAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChartAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChartAssetAggregateArgs>(args: Subset<T, ChartAssetAggregateArgs>): Prisma.PrismaPromise<GetChartAssetAggregateType<T>>

    /**
     * Group by ChartAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChartAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChartAssetGroupByArgs['orderBy'] }
        : { orderBy?: ChartAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChartAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChartAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChartAsset model
   */
  readonly fields: ChartAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChartAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChartAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends ChartAsset$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, ChartAsset$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    encounter<T extends ChartAsset$encounterArgs<ExtArgs> = {}>(args?: Subset<T, ChartAsset$encounterArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends ChartAsset$patientArgs<ExtArgs> = {}>(args?: Subset<T, ChartAsset$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends ChartAsset$createdByArgs<ExtArgs> = {}>(args?: Subset<T, ChartAsset$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChartAsset model
   */
  interface ChartAssetFieldRefs {
    readonly id: FieldRef<"ChartAsset", 'String'>
    readonly appointmentId: FieldRef<"ChartAsset", 'String'>
    readonly encounterId: FieldRef<"ChartAsset", 'String'>
    readonly patientId: FieldRef<"ChartAsset", 'String'>
    readonly fileName: FieldRef<"ChartAsset", 'String'>
    readonly mimeType: FieldRef<"ChartAsset", 'String'>
    readonly sizeBytes: FieldRef<"ChartAsset", 'Int'>
    readonly storagePath: FieldRef<"ChartAsset", 'String'>
    readonly extractedJson: FieldRef<"ChartAsset", 'Json'>
    readonly rawText: FieldRef<"ChartAsset", 'String'>
    readonly createdById: FieldRef<"ChartAsset", 'String'>
    readonly createdAt: FieldRef<"ChartAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChartAsset findUnique
   */
  export type ChartAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetInclude<ExtArgs> | null
    /**
     * Filter, which ChartAsset to fetch.
     */
    where: ChartAssetWhereUniqueInput
  }

  /**
   * ChartAsset findUniqueOrThrow
   */
  export type ChartAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetInclude<ExtArgs> | null
    /**
     * Filter, which ChartAsset to fetch.
     */
    where: ChartAssetWhereUniqueInput
  }

  /**
   * ChartAsset findFirst
   */
  export type ChartAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetInclude<ExtArgs> | null
    /**
     * Filter, which ChartAsset to fetch.
     */
    where?: ChartAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartAssets to fetch.
     */
    orderBy?: ChartAssetOrderByWithRelationInput | ChartAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartAssets.
     */
    cursor?: ChartAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartAssets.
     */
    distinct?: ChartAssetScalarFieldEnum | ChartAssetScalarFieldEnum[]
  }

  /**
   * ChartAsset findFirstOrThrow
   */
  export type ChartAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetInclude<ExtArgs> | null
    /**
     * Filter, which ChartAsset to fetch.
     */
    where?: ChartAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartAssets to fetch.
     */
    orderBy?: ChartAssetOrderByWithRelationInput | ChartAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartAssets.
     */
    cursor?: ChartAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartAssets.
     */
    distinct?: ChartAssetScalarFieldEnum | ChartAssetScalarFieldEnum[]
  }

  /**
   * ChartAsset findMany
   */
  export type ChartAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetInclude<ExtArgs> | null
    /**
     * Filter, which ChartAssets to fetch.
     */
    where?: ChartAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartAssets to fetch.
     */
    orderBy?: ChartAssetOrderByWithRelationInput | ChartAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChartAssets.
     */
    cursor?: ChartAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartAssets.
     */
    skip?: number
    distinct?: ChartAssetScalarFieldEnum | ChartAssetScalarFieldEnum[]
  }

  /**
   * ChartAsset create
   */
  export type ChartAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetInclude<ExtArgs> | null
    /**
     * The data needed to create a ChartAsset.
     */
    data: XOR<ChartAssetCreateInput, ChartAssetUncheckedCreateInput>
  }

  /**
   * ChartAsset createMany
   */
  export type ChartAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChartAssets.
     */
    data: ChartAssetCreateManyInput | ChartAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChartAsset createManyAndReturn
   */
  export type ChartAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * The data used to create many ChartAssets.
     */
    data: ChartAssetCreateManyInput | ChartAssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChartAsset update
   */
  export type ChartAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetInclude<ExtArgs> | null
    /**
     * The data needed to update a ChartAsset.
     */
    data: XOR<ChartAssetUpdateInput, ChartAssetUncheckedUpdateInput>
    /**
     * Choose, which ChartAsset to update.
     */
    where: ChartAssetWhereUniqueInput
  }

  /**
   * ChartAsset updateMany
   */
  export type ChartAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChartAssets.
     */
    data: XOR<ChartAssetUpdateManyMutationInput, ChartAssetUncheckedUpdateManyInput>
    /**
     * Filter which ChartAssets to update
     */
    where?: ChartAssetWhereInput
    /**
     * Limit how many ChartAssets to update.
     */
    limit?: number
  }

  /**
   * ChartAsset updateManyAndReturn
   */
  export type ChartAssetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * The data used to update ChartAssets.
     */
    data: XOR<ChartAssetUpdateManyMutationInput, ChartAssetUncheckedUpdateManyInput>
    /**
     * Filter which ChartAssets to update
     */
    where?: ChartAssetWhereInput
    /**
     * Limit how many ChartAssets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChartAsset upsert
   */
  export type ChartAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetInclude<ExtArgs> | null
    /**
     * The filter to search for the ChartAsset to update in case it exists.
     */
    where: ChartAssetWhereUniqueInput
    /**
     * In case the ChartAsset found by the `where` argument doesn't exist, create a new ChartAsset with this data.
     */
    create: XOR<ChartAssetCreateInput, ChartAssetUncheckedCreateInput>
    /**
     * In case the ChartAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChartAssetUpdateInput, ChartAssetUncheckedUpdateInput>
  }

  /**
   * ChartAsset delete
   */
  export type ChartAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetInclude<ExtArgs> | null
    /**
     * Filter which ChartAsset to delete.
     */
    where: ChartAssetWhereUniqueInput
  }

  /**
   * ChartAsset deleteMany
   */
  export type ChartAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartAssets to delete
     */
    where?: ChartAssetWhereInput
    /**
     * Limit how many ChartAssets to delete.
     */
    limit?: number
  }

  /**
   * ChartAsset.appointment
   */
  export type ChartAsset$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * ChartAsset.encounter
   */
  export type ChartAsset$encounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
  }

  /**
   * ChartAsset.patient
   */
  export type ChartAsset$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * ChartAsset.createdBy
   */
  export type ChartAsset$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ChartAsset without action
   */
  export type ChartAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartAsset
     */
    select?: ChartAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartAsset
     */
    omit?: ChartAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartAssetInclude<ExtArgs> | null
  }


  /**
   * Model SuggestionGeneration
   */

  export type AggregateSuggestionGeneration = {
    _count: SuggestionGenerationCountAggregateOutputType | null
    _avg: SuggestionGenerationAvgAggregateOutputType | null
    _sum: SuggestionGenerationSumAggregateOutputType | null
    _min: SuggestionGenerationMinAggregateOutputType | null
    _max: SuggestionGenerationMaxAggregateOutputType | null
  }

  export type SuggestionGenerationAvgAggregateOutputType = {
    textDelta: number | null
    transcriptDelta: number | null
  }

  export type SuggestionGenerationSumAggregateOutputType = {
    textDelta: number | null
    transcriptDelta: number | null
  }

  export type SuggestionGenerationMinAggregateOutputType = {
    id: string | null
    encounterId: string | null
    trigger: string | null
    textDelta: number | null
    transcriptDelta: number | null
    inputHash: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type SuggestionGenerationMaxAggregateOutputType = {
    id: string | null
    encounterId: string | null
    trigger: string | null
    textDelta: number | null
    transcriptDelta: number | null
    inputHash: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type SuggestionGenerationCountAggregateOutputType = {
    id: number
    encounterId: number
    trigger: number
    textDelta: number
    transcriptDelta: number
    inputHash: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type SuggestionGenerationAvgAggregateInputType = {
    textDelta?: true
    transcriptDelta?: true
  }

  export type SuggestionGenerationSumAggregateInputType = {
    textDelta?: true
    transcriptDelta?: true
  }

  export type SuggestionGenerationMinAggregateInputType = {
    id?: true
    encounterId?: true
    trigger?: true
    textDelta?: true
    transcriptDelta?: true
    inputHash?: true
    createdById?: true
    createdAt?: true
  }

  export type SuggestionGenerationMaxAggregateInputType = {
    id?: true
    encounterId?: true
    trigger?: true
    textDelta?: true
    transcriptDelta?: true
    inputHash?: true
    createdById?: true
    createdAt?: true
  }

  export type SuggestionGenerationCountAggregateInputType = {
    id?: true
    encounterId?: true
    trigger?: true
    textDelta?: true
    transcriptDelta?: true
    inputHash?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type SuggestionGenerationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuggestionGeneration to aggregate.
     */
    where?: SuggestionGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestionGenerations to fetch.
     */
    orderBy?: SuggestionGenerationOrderByWithRelationInput | SuggestionGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuggestionGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestionGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestionGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuggestionGenerations
    **/
    _count?: true | SuggestionGenerationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SuggestionGenerationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SuggestionGenerationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuggestionGenerationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuggestionGenerationMaxAggregateInputType
  }

  export type GetSuggestionGenerationAggregateType<T extends SuggestionGenerationAggregateArgs> = {
        [P in keyof T & keyof AggregateSuggestionGeneration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuggestionGeneration[P]>
      : GetScalarType<T[P], AggregateSuggestionGeneration[P]>
  }




  export type SuggestionGenerationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuggestionGenerationWhereInput
    orderBy?: SuggestionGenerationOrderByWithAggregationInput | SuggestionGenerationOrderByWithAggregationInput[]
    by: SuggestionGenerationScalarFieldEnum[] | SuggestionGenerationScalarFieldEnum
    having?: SuggestionGenerationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuggestionGenerationCountAggregateInputType | true
    _avg?: SuggestionGenerationAvgAggregateInputType
    _sum?: SuggestionGenerationSumAggregateInputType
    _min?: SuggestionGenerationMinAggregateInputType
    _max?: SuggestionGenerationMaxAggregateInputType
  }

  export type SuggestionGenerationGroupByOutputType = {
    id: string
    encounterId: string
    trigger: string
    textDelta: number
    transcriptDelta: number
    inputHash: string | null
    createdById: string | null
    createdAt: Date
    _count: SuggestionGenerationCountAggregateOutputType | null
    _avg: SuggestionGenerationAvgAggregateOutputType | null
    _sum: SuggestionGenerationSumAggregateOutputType | null
    _min: SuggestionGenerationMinAggregateOutputType | null
    _max: SuggestionGenerationMaxAggregateOutputType | null
  }

  type GetSuggestionGenerationGroupByPayload<T extends SuggestionGenerationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuggestionGenerationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuggestionGenerationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuggestionGenerationGroupByOutputType[P]>
            : GetScalarType<T[P], SuggestionGenerationGroupByOutputType[P]>
        }
      >
    >


  export type SuggestionGenerationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    trigger?: boolean
    textDelta?: boolean
    transcriptDelta?: boolean
    inputHash?: boolean
    createdById?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    createdBy?: boolean | SuggestionGeneration$createdByArgs<ExtArgs>
    suggestions?: boolean | SuggestionGeneration$suggestionsArgs<ExtArgs>
    _count?: boolean | SuggestionGenerationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suggestionGeneration"]>

  export type SuggestionGenerationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    trigger?: boolean
    textDelta?: boolean
    transcriptDelta?: boolean
    inputHash?: boolean
    createdById?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    createdBy?: boolean | SuggestionGeneration$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["suggestionGeneration"]>

  export type SuggestionGenerationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    trigger?: boolean
    textDelta?: boolean
    transcriptDelta?: boolean
    inputHash?: boolean
    createdById?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    createdBy?: boolean | SuggestionGeneration$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["suggestionGeneration"]>

  export type SuggestionGenerationSelectScalar = {
    id?: boolean
    encounterId?: boolean
    trigger?: boolean
    textDelta?: boolean
    transcriptDelta?: boolean
    inputHash?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type SuggestionGenerationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "encounterId" | "trigger" | "textDelta" | "transcriptDelta" | "inputHash" | "createdById" | "createdAt", ExtArgs["result"]["suggestionGeneration"]>
  export type SuggestionGenerationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    createdBy?: boolean | SuggestionGeneration$createdByArgs<ExtArgs>
    suggestions?: boolean | SuggestionGeneration$suggestionsArgs<ExtArgs>
    _count?: boolean | SuggestionGenerationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SuggestionGenerationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    createdBy?: boolean | SuggestionGeneration$createdByArgs<ExtArgs>
  }
  export type SuggestionGenerationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    createdBy?: boolean | SuggestionGeneration$createdByArgs<ExtArgs>
  }

  export type $SuggestionGenerationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuggestionGeneration"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      suggestions: Prisma.$CodeSuggestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      encounterId: string
      trigger: string
      textDelta: number
      transcriptDelta: number
      inputHash: string | null
      createdById: string | null
      createdAt: Date
    }, ExtArgs["result"]["suggestionGeneration"]>
    composites: {}
  }

  type SuggestionGenerationGetPayload<S extends boolean | null | undefined | SuggestionGenerationDefaultArgs> = $Result.GetResult<Prisma.$SuggestionGenerationPayload, S>

  type SuggestionGenerationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuggestionGenerationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuggestionGenerationCountAggregateInputType | true
    }

  export interface SuggestionGenerationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuggestionGeneration'], meta: { name: 'SuggestionGeneration' } }
    /**
     * Find zero or one SuggestionGeneration that matches the filter.
     * @param {SuggestionGenerationFindUniqueArgs} args - Arguments to find a SuggestionGeneration
     * @example
     * // Get one SuggestionGeneration
     * const suggestionGeneration = await prisma.suggestionGeneration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuggestionGenerationFindUniqueArgs>(args: SelectSubset<T, SuggestionGenerationFindUniqueArgs<ExtArgs>>): Prisma__SuggestionGenerationClient<$Result.GetResult<Prisma.$SuggestionGenerationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SuggestionGeneration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuggestionGenerationFindUniqueOrThrowArgs} args - Arguments to find a SuggestionGeneration
     * @example
     * // Get one SuggestionGeneration
     * const suggestionGeneration = await prisma.suggestionGeneration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuggestionGenerationFindUniqueOrThrowArgs>(args: SelectSubset<T, SuggestionGenerationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuggestionGenerationClient<$Result.GetResult<Prisma.$SuggestionGenerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuggestionGeneration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionGenerationFindFirstArgs} args - Arguments to find a SuggestionGeneration
     * @example
     * // Get one SuggestionGeneration
     * const suggestionGeneration = await prisma.suggestionGeneration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuggestionGenerationFindFirstArgs>(args?: SelectSubset<T, SuggestionGenerationFindFirstArgs<ExtArgs>>): Prisma__SuggestionGenerationClient<$Result.GetResult<Prisma.$SuggestionGenerationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuggestionGeneration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionGenerationFindFirstOrThrowArgs} args - Arguments to find a SuggestionGeneration
     * @example
     * // Get one SuggestionGeneration
     * const suggestionGeneration = await prisma.suggestionGeneration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuggestionGenerationFindFirstOrThrowArgs>(args?: SelectSubset<T, SuggestionGenerationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuggestionGenerationClient<$Result.GetResult<Prisma.$SuggestionGenerationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SuggestionGenerations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionGenerationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuggestionGenerations
     * const suggestionGenerations = await prisma.suggestionGeneration.findMany()
     * 
     * // Get first 10 SuggestionGenerations
     * const suggestionGenerations = await prisma.suggestionGeneration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const suggestionGenerationWithIdOnly = await prisma.suggestionGeneration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuggestionGenerationFindManyArgs>(args?: SelectSubset<T, SuggestionGenerationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionGenerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SuggestionGeneration.
     * @param {SuggestionGenerationCreateArgs} args - Arguments to create a SuggestionGeneration.
     * @example
     * // Create one SuggestionGeneration
     * const SuggestionGeneration = await prisma.suggestionGeneration.create({
     *   data: {
     *     // ... data to create a SuggestionGeneration
     *   }
     * })
     * 
     */
    create<T extends SuggestionGenerationCreateArgs>(args: SelectSubset<T, SuggestionGenerationCreateArgs<ExtArgs>>): Prisma__SuggestionGenerationClient<$Result.GetResult<Prisma.$SuggestionGenerationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SuggestionGenerations.
     * @param {SuggestionGenerationCreateManyArgs} args - Arguments to create many SuggestionGenerations.
     * @example
     * // Create many SuggestionGenerations
     * const suggestionGeneration = await prisma.suggestionGeneration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuggestionGenerationCreateManyArgs>(args?: SelectSubset<T, SuggestionGenerationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuggestionGenerations and returns the data saved in the database.
     * @param {SuggestionGenerationCreateManyAndReturnArgs} args - Arguments to create many SuggestionGenerations.
     * @example
     * // Create many SuggestionGenerations
     * const suggestionGeneration = await prisma.suggestionGeneration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuggestionGenerations and only return the `id`
     * const suggestionGenerationWithIdOnly = await prisma.suggestionGeneration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuggestionGenerationCreateManyAndReturnArgs>(args?: SelectSubset<T, SuggestionGenerationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionGenerationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SuggestionGeneration.
     * @param {SuggestionGenerationDeleteArgs} args - Arguments to delete one SuggestionGeneration.
     * @example
     * // Delete one SuggestionGeneration
     * const SuggestionGeneration = await prisma.suggestionGeneration.delete({
     *   where: {
     *     // ... filter to delete one SuggestionGeneration
     *   }
     * })
     * 
     */
    delete<T extends SuggestionGenerationDeleteArgs>(args: SelectSubset<T, SuggestionGenerationDeleteArgs<ExtArgs>>): Prisma__SuggestionGenerationClient<$Result.GetResult<Prisma.$SuggestionGenerationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SuggestionGeneration.
     * @param {SuggestionGenerationUpdateArgs} args - Arguments to update one SuggestionGeneration.
     * @example
     * // Update one SuggestionGeneration
     * const suggestionGeneration = await prisma.suggestionGeneration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuggestionGenerationUpdateArgs>(args: SelectSubset<T, SuggestionGenerationUpdateArgs<ExtArgs>>): Prisma__SuggestionGenerationClient<$Result.GetResult<Prisma.$SuggestionGenerationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SuggestionGenerations.
     * @param {SuggestionGenerationDeleteManyArgs} args - Arguments to filter SuggestionGenerations to delete.
     * @example
     * // Delete a few SuggestionGenerations
     * const { count } = await prisma.suggestionGeneration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuggestionGenerationDeleteManyArgs>(args?: SelectSubset<T, SuggestionGenerationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuggestionGenerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionGenerationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuggestionGenerations
     * const suggestionGeneration = await prisma.suggestionGeneration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuggestionGenerationUpdateManyArgs>(args: SelectSubset<T, SuggestionGenerationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuggestionGenerations and returns the data updated in the database.
     * @param {SuggestionGenerationUpdateManyAndReturnArgs} args - Arguments to update many SuggestionGenerations.
     * @example
     * // Update many SuggestionGenerations
     * const suggestionGeneration = await prisma.suggestionGeneration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SuggestionGenerations and only return the `id`
     * const suggestionGenerationWithIdOnly = await prisma.suggestionGeneration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SuggestionGenerationUpdateManyAndReturnArgs>(args: SelectSubset<T, SuggestionGenerationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionGenerationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SuggestionGeneration.
     * @param {SuggestionGenerationUpsertArgs} args - Arguments to update or create a SuggestionGeneration.
     * @example
     * // Update or create a SuggestionGeneration
     * const suggestionGeneration = await prisma.suggestionGeneration.upsert({
     *   create: {
     *     // ... data to create a SuggestionGeneration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuggestionGeneration we want to update
     *   }
     * })
     */
    upsert<T extends SuggestionGenerationUpsertArgs>(args: SelectSubset<T, SuggestionGenerationUpsertArgs<ExtArgs>>): Prisma__SuggestionGenerationClient<$Result.GetResult<Prisma.$SuggestionGenerationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SuggestionGenerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionGenerationCountArgs} args - Arguments to filter SuggestionGenerations to count.
     * @example
     * // Count the number of SuggestionGenerations
     * const count = await prisma.suggestionGeneration.count({
     *   where: {
     *     // ... the filter for the SuggestionGenerations we want to count
     *   }
     * })
    **/
    count<T extends SuggestionGenerationCountArgs>(
      args?: Subset<T, SuggestionGenerationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuggestionGenerationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuggestionGeneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionGenerationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuggestionGenerationAggregateArgs>(args: Subset<T, SuggestionGenerationAggregateArgs>): Prisma.PrismaPromise<GetSuggestionGenerationAggregateType<T>>

    /**
     * Group by SuggestionGeneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionGenerationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuggestionGenerationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuggestionGenerationGroupByArgs['orderBy'] }
        : { orderBy?: SuggestionGenerationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuggestionGenerationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuggestionGenerationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuggestionGeneration model
   */
  readonly fields: SuggestionGenerationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuggestionGeneration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuggestionGenerationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends SuggestionGeneration$createdByArgs<ExtArgs> = {}>(args?: Subset<T, SuggestionGeneration$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    suggestions<T extends SuggestionGeneration$suggestionsArgs<ExtArgs> = {}>(args?: Subset<T, SuggestionGeneration$suggestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuggestionGeneration model
   */
  interface SuggestionGenerationFieldRefs {
    readonly id: FieldRef<"SuggestionGeneration", 'String'>
    readonly encounterId: FieldRef<"SuggestionGeneration", 'String'>
    readonly trigger: FieldRef<"SuggestionGeneration", 'String'>
    readonly textDelta: FieldRef<"SuggestionGeneration", 'Int'>
    readonly transcriptDelta: FieldRef<"SuggestionGeneration", 'Int'>
    readonly inputHash: FieldRef<"SuggestionGeneration", 'String'>
    readonly createdById: FieldRef<"SuggestionGeneration", 'String'>
    readonly createdAt: FieldRef<"SuggestionGeneration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SuggestionGeneration findUnique
   */
  export type SuggestionGenerationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGeneration
     */
    select?: SuggestionGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestionGeneration
     */
    omit?: SuggestionGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionGenerationInclude<ExtArgs> | null
    /**
     * Filter, which SuggestionGeneration to fetch.
     */
    where: SuggestionGenerationWhereUniqueInput
  }

  /**
   * SuggestionGeneration findUniqueOrThrow
   */
  export type SuggestionGenerationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGeneration
     */
    select?: SuggestionGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestionGeneration
     */
    omit?: SuggestionGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionGenerationInclude<ExtArgs> | null
    /**
     * Filter, which SuggestionGeneration to fetch.
     */
    where: SuggestionGenerationWhereUniqueInput
  }

  /**
   * SuggestionGeneration findFirst
   */
  export type SuggestionGenerationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGeneration
     */
    select?: SuggestionGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestionGeneration
     */
    omit?: SuggestionGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionGenerationInclude<ExtArgs> | null
    /**
     * Filter, which SuggestionGeneration to fetch.
     */
    where?: SuggestionGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestionGenerations to fetch.
     */
    orderBy?: SuggestionGenerationOrderByWithRelationInput | SuggestionGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuggestionGenerations.
     */
    cursor?: SuggestionGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestionGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestionGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuggestionGenerations.
     */
    distinct?: SuggestionGenerationScalarFieldEnum | SuggestionGenerationScalarFieldEnum[]
  }

  /**
   * SuggestionGeneration findFirstOrThrow
   */
  export type SuggestionGenerationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGeneration
     */
    select?: SuggestionGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestionGeneration
     */
    omit?: SuggestionGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionGenerationInclude<ExtArgs> | null
    /**
     * Filter, which SuggestionGeneration to fetch.
     */
    where?: SuggestionGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestionGenerations to fetch.
     */
    orderBy?: SuggestionGenerationOrderByWithRelationInput | SuggestionGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuggestionGenerations.
     */
    cursor?: SuggestionGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestionGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestionGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuggestionGenerations.
     */
    distinct?: SuggestionGenerationScalarFieldEnum | SuggestionGenerationScalarFieldEnum[]
  }

  /**
   * SuggestionGeneration findMany
   */
  export type SuggestionGenerationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGeneration
     */
    select?: SuggestionGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestionGeneration
     */
    omit?: SuggestionGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionGenerationInclude<ExtArgs> | null
    /**
     * Filter, which SuggestionGenerations to fetch.
     */
    where?: SuggestionGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestionGenerations to fetch.
     */
    orderBy?: SuggestionGenerationOrderByWithRelationInput | SuggestionGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuggestionGenerations.
     */
    cursor?: SuggestionGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestionGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestionGenerations.
     */
    skip?: number
    distinct?: SuggestionGenerationScalarFieldEnum | SuggestionGenerationScalarFieldEnum[]
  }

  /**
   * SuggestionGeneration create
   */
  export type SuggestionGenerationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGeneration
     */
    select?: SuggestionGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestionGeneration
     */
    omit?: SuggestionGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionGenerationInclude<ExtArgs> | null
    /**
     * The data needed to create a SuggestionGeneration.
     */
    data: XOR<SuggestionGenerationCreateInput, SuggestionGenerationUncheckedCreateInput>
  }

  /**
   * SuggestionGeneration createMany
   */
  export type SuggestionGenerationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuggestionGenerations.
     */
    data: SuggestionGenerationCreateManyInput | SuggestionGenerationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuggestionGeneration createManyAndReturn
   */
  export type SuggestionGenerationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGeneration
     */
    select?: SuggestionGenerationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestionGeneration
     */
    omit?: SuggestionGenerationOmit<ExtArgs> | null
    /**
     * The data used to create many SuggestionGenerations.
     */
    data: SuggestionGenerationCreateManyInput | SuggestionGenerationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionGenerationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuggestionGeneration update
   */
  export type SuggestionGenerationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGeneration
     */
    select?: SuggestionGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestionGeneration
     */
    omit?: SuggestionGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionGenerationInclude<ExtArgs> | null
    /**
     * The data needed to update a SuggestionGeneration.
     */
    data: XOR<SuggestionGenerationUpdateInput, SuggestionGenerationUncheckedUpdateInput>
    /**
     * Choose, which SuggestionGeneration to update.
     */
    where: SuggestionGenerationWhereUniqueInput
  }

  /**
   * SuggestionGeneration updateMany
   */
  export type SuggestionGenerationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuggestionGenerations.
     */
    data: XOR<SuggestionGenerationUpdateManyMutationInput, SuggestionGenerationUncheckedUpdateManyInput>
    /**
     * Filter which SuggestionGenerations to update
     */
    where?: SuggestionGenerationWhereInput
    /**
     * Limit how many SuggestionGenerations to update.
     */
    limit?: number
  }

  /**
   * SuggestionGeneration updateManyAndReturn
   */
  export type SuggestionGenerationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGeneration
     */
    select?: SuggestionGenerationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestionGeneration
     */
    omit?: SuggestionGenerationOmit<ExtArgs> | null
    /**
     * The data used to update SuggestionGenerations.
     */
    data: XOR<SuggestionGenerationUpdateManyMutationInput, SuggestionGenerationUncheckedUpdateManyInput>
    /**
     * Filter which SuggestionGenerations to update
     */
    where?: SuggestionGenerationWhereInput
    /**
     * Limit how many SuggestionGenerations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionGenerationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuggestionGeneration upsert
   */
  export type SuggestionGenerationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGeneration
     */
    select?: SuggestionGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestionGeneration
     */
    omit?: SuggestionGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionGenerationInclude<ExtArgs> | null
    /**
     * The filter to search for the SuggestionGeneration to update in case it exists.
     */
    where: SuggestionGenerationWhereUniqueInput
    /**
     * In case the SuggestionGeneration found by the `where` argument doesn't exist, create a new SuggestionGeneration with this data.
     */
    create: XOR<SuggestionGenerationCreateInput, SuggestionGenerationUncheckedCreateInput>
    /**
     * In case the SuggestionGeneration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuggestionGenerationUpdateInput, SuggestionGenerationUncheckedUpdateInput>
  }

  /**
   * SuggestionGeneration delete
   */
  export type SuggestionGenerationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGeneration
     */
    select?: SuggestionGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestionGeneration
     */
    omit?: SuggestionGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionGenerationInclude<ExtArgs> | null
    /**
     * Filter which SuggestionGeneration to delete.
     */
    where: SuggestionGenerationWhereUniqueInput
  }

  /**
   * SuggestionGeneration deleteMany
   */
  export type SuggestionGenerationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuggestionGenerations to delete
     */
    where?: SuggestionGenerationWhereInput
    /**
     * Limit how many SuggestionGenerations to delete.
     */
    limit?: number
  }

  /**
   * SuggestionGeneration.createdBy
   */
  export type SuggestionGeneration$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SuggestionGeneration.suggestions
   */
  export type SuggestionGeneration$suggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionInclude<ExtArgs> | null
    where?: CodeSuggestionWhereInput
    orderBy?: CodeSuggestionOrderByWithRelationInput | CodeSuggestionOrderByWithRelationInput[]
    cursor?: CodeSuggestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CodeSuggestionScalarFieldEnum | CodeSuggestionScalarFieldEnum[]
  }

  /**
   * SuggestionGeneration without action
   */
  export type SuggestionGenerationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestionGeneration
     */
    select?: SuggestionGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuggestionGeneration
     */
    omit?: SuggestionGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionGenerationInclude<ExtArgs> | null
  }


  /**
   * Model CodeSuggestion
   */

  export type AggregateCodeSuggestion = {
    _count: CodeSuggestionCountAggregateOutputType | null
    _avg: CodeSuggestionAvgAggregateOutputType | null
    _sum: CodeSuggestionSumAggregateOutputType | null
    _min: CodeSuggestionMinAggregateOutputType | null
    _max: CodeSuggestionMaxAggregateOutputType | null
  }

  export type CodeSuggestionAvgAggregateOutputType = {
    confidence: number | null
  }

  export type CodeSuggestionSumAggregateOutputType = {
    confidence: number | null
  }

  export type CodeSuggestionMinAggregateOutputType = {
    id: string | null
    encounterId: string | null
    generationId: string | null
    code: string | null
    codeType: string | null
    category: $Enums.SuggestionCategory | null
    title: string | null
    description: string | null
    rationale: string | null
    confidence: number | null
    status: $Enums.SuggestionStatus | null
    recommended: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CodeSuggestionMaxAggregateOutputType = {
    id: string | null
    encounterId: string | null
    generationId: string | null
    code: string | null
    codeType: string | null
    category: $Enums.SuggestionCategory | null
    title: string | null
    description: string | null
    rationale: string | null
    confidence: number | null
    status: $Enums.SuggestionStatus | null
    recommended: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CodeSuggestionCountAggregateOutputType = {
    id: number
    encounterId: number
    generationId: number
    code: number
    codeType: number
    category: number
    title: number
    description: number
    rationale: number
    confidence: number
    evidence: number
    status: number
    recommended: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CodeSuggestionAvgAggregateInputType = {
    confidence?: true
  }

  export type CodeSuggestionSumAggregateInputType = {
    confidence?: true
  }

  export type CodeSuggestionMinAggregateInputType = {
    id?: true
    encounterId?: true
    generationId?: true
    code?: true
    codeType?: true
    category?: true
    title?: true
    description?: true
    rationale?: true
    confidence?: true
    status?: true
    recommended?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CodeSuggestionMaxAggregateInputType = {
    id?: true
    encounterId?: true
    generationId?: true
    code?: true
    codeType?: true
    category?: true
    title?: true
    description?: true
    rationale?: true
    confidence?: true
    status?: true
    recommended?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CodeSuggestionCountAggregateInputType = {
    id?: true
    encounterId?: true
    generationId?: true
    code?: true
    codeType?: true
    category?: true
    title?: true
    description?: true
    rationale?: true
    confidence?: true
    evidence?: true
    status?: true
    recommended?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CodeSuggestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CodeSuggestion to aggregate.
     */
    where?: CodeSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeSuggestions to fetch.
     */
    orderBy?: CodeSuggestionOrderByWithRelationInput | CodeSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CodeSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodeSuggestions
    **/
    _count?: true | CodeSuggestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodeSuggestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodeSuggestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeSuggestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeSuggestionMaxAggregateInputType
  }

  export type GetCodeSuggestionAggregateType<T extends CodeSuggestionAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeSuggestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeSuggestion[P]>
      : GetScalarType<T[P], AggregateCodeSuggestion[P]>
  }




  export type CodeSuggestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeSuggestionWhereInput
    orderBy?: CodeSuggestionOrderByWithAggregationInput | CodeSuggestionOrderByWithAggregationInput[]
    by: CodeSuggestionScalarFieldEnum[] | CodeSuggestionScalarFieldEnum
    having?: CodeSuggestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeSuggestionCountAggregateInputType | true
    _avg?: CodeSuggestionAvgAggregateInputType
    _sum?: CodeSuggestionSumAggregateInputType
    _min?: CodeSuggestionMinAggregateInputType
    _max?: CodeSuggestionMaxAggregateInputType
  }

  export type CodeSuggestionGroupByOutputType = {
    id: string
    encounterId: string
    generationId: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    title: string
    description: string
    rationale: string
    confidence: number
    evidence: JsonValue | null
    status: $Enums.SuggestionStatus
    recommended: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CodeSuggestionCountAggregateOutputType | null
    _avg: CodeSuggestionAvgAggregateOutputType | null
    _sum: CodeSuggestionSumAggregateOutputType | null
    _min: CodeSuggestionMinAggregateOutputType | null
    _max: CodeSuggestionMaxAggregateOutputType | null
  }

  type GetCodeSuggestionGroupByPayload<T extends CodeSuggestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CodeSuggestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodeSuggestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodeSuggestionGroupByOutputType[P]>
            : GetScalarType<T[P], CodeSuggestionGroupByOutputType[P]>
        }
      >
    >


  export type CodeSuggestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    generationId?: boolean
    code?: boolean
    codeType?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    rationale?: boolean
    confidence?: boolean
    evidence?: boolean
    status?: boolean
    recommended?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    generation?: boolean | SuggestionGenerationDefaultArgs<ExtArgs>
    selections?: boolean | CodeSuggestion$selectionsArgs<ExtArgs>
    _count?: boolean | CodeSuggestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["codeSuggestion"]>

  export type CodeSuggestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    generationId?: boolean
    code?: boolean
    codeType?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    rationale?: boolean
    confidence?: boolean
    evidence?: boolean
    status?: boolean
    recommended?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    generation?: boolean | SuggestionGenerationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["codeSuggestion"]>

  export type CodeSuggestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    generationId?: boolean
    code?: boolean
    codeType?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    rationale?: boolean
    confidence?: boolean
    evidence?: boolean
    status?: boolean
    recommended?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    generation?: boolean | SuggestionGenerationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["codeSuggestion"]>

  export type CodeSuggestionSelectScalar = {
    id?: boolean
    encounterId?: boolean
    generationId?: boolean
    code?: boolean
    codeType?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    rationale?: boolean
    confidence?: boolean
    evidence?: boolean
    status?: boolean
    recommended?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CodeSuggestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "encounterId" | "generationId" | "code" | "codeType" | "category" | "title" | "description" | "rationale" | "confidence" | "evidence" | "status" | "recommended" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["codeSuggestion"]>
  export type CodeSuggestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    generation?: boolean | SuggestionGenerationDefaultArgs<ExtArgs>
    selections?: boolean | CodeSuggestion$selectionsArgs<ExtArgs>
    _count?: boolean | CodeSuggestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CodeSuggestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    generation?: boolean | SuggestionGenerationDefaultArgs<ExtArgs>
  }
  export type CodeSuggestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    generation?: boolean | SuggestionGenerationDefaultArgs<ExtArgs>
  }

  export type $CodeSuggestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CodeSuggestion"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      generation: Prisma.$SuggestionGenerationPayload<ExtArgs>
      selections: Prisma.$CodeSelectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      encounterId: string
      generationId: string
      code: string
      codeType: string
      category: $Enums.SuggestionCategory
      title: string
      description: string
      rationale: string
      confidence: number
      evidence: Prisma.JsonValue | null
      status: $Enums.SuggestionStatus
      recommended: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["codeSuggestion"]>
    composites: {}
  }

  type CodeSuggestionGetPayload<S extends boolean | null | undefined | CodeSuggestionDefaultArgs> = $Result.GetResult<Prisma.$CodeSuggestionPayload, S>

  type CodeSuggestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CodeSuggestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CodeSuggestionCountAggregateInputType | true
    }

  export interface CodeSuggestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CodeSuggestion'], meta: { name: 'CodeSuggestion' } }
    /**
     * Find zero or one CodeSuggestion that matches the filter.
     * @param {CodeSuggestionFindUniqueArgs} args - Arguments to find a CodeSuggestion
     * @example
     * // Get one CodeSuggestion
     * const codeSuggestion = await prisma.codeSuggestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CodeSuggestionFindUniqueArgs>(args: SelectSubset<T, CodeSuggestionFindUniqueArgs<ExtArgs>>): Prisma__CodeSuggestionClient<$Result.GetResult<Prisma.$CodeSuggestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CodeSuggestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CodeSuggestionFindUniqueOrThrowArgs} args - Arguments to find a CodeSuggestion
     * @example
     * // Get one CodeSuggestion
     * const codeSuggestion = await prisma.codeSuggestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CodeSuggestionFindUniqueOrThrowArgs>(args: SelectSubset<T, CodeSuggestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CodeSuggestionClient<$Result.GetResult<Prisma.$CodeSuggestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CodeSuggestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSuggestionFindFirstArgs} args - Arguments to find a CodeSuggestion
     * @example
     * // Get one CodeSuggestion
     * const codeSuggestion = await prisma.codeSuggestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CodeSuggestionFindFirstArgs>(args?: SelectSubset<T, CodeSuggestionFindFirstArgs<ExtArgs>>): Prisma__CodeSuggestionClient<$Result.GetResult<Prisma.$CodeSuggestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CodeSuggestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSuggestionFindFirstOrThrowArgs} args - Arguments to find a CodeSuggestion
     * @example
     * // Get one CodeSuggestion
     * const codeSuggestion = await prisma.codeSuggestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CodeSuggestionFindFirstOrThrowArgs>(args?: SelectSubset<T, CodeSuggestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CodeSuggestionClient<$Result.GetResult<Prisma.$CodeSuggestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CodeSuggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSuggestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeSuggestions
     * const codeSuggestions = await prisma.codeSuggestion.findMany()
     * 
     * // Get first 10 CodeSuggestions
     * const codeSuggestions = await prisma.codeSuggestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const codeSuggestionWithIdOnly = await prisma.codeSuggestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CodeSuggestionFindManyArgs>(args?: SelectSubset<T, CodeSuggestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CodeSuggestion.
     * @param {CodeSuggestionCreateArgs} args - Arguments to create a CodeSuggestion.
     * @example
     * // Create one CodeSuggestion
     * const CodeSuggestion = await prisma.codeSuggestion.create({
     *   data: {
     *     // ... data to create a CodeSuggestion
     *   }
     * })
     * 
     */
    create<T extends CodeSuggestionCreateArgs>(args: SelectSubset<T, CodeSuggestionCreateArgs<ExtArgs>>): Prisma__CodeSuggestionClient<$Result.GetResult<Prisma.$CodeSuggestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CodeSuggestions.
     * @param {CodeSuggestionCreateManyArgs} args - Arguments to create many CodeSuggestions.
     * @example
     * // Create many CodeSuggestions
     * const codeSuggestion = await prisma.codeSuggestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CodeSuggestionCreateManyArgs>(args?: SelectSubset<T, CodeSuggestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CodeSuggestions and returns the data saved in the database.
     * @param {CodeSuggestionCreateManyAndReturnArgs} args - Arguments to create many CodeSuggestions.
     * @example
     * // Create many CodeSuggestions
     * const codeSuggestion = await prisma.codeSuggestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CodeSuggestions and only return the `id`
     * const codeSuggestionWithIdOnly = await prisma.codeSuggestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CodeSuggestionCreateManyAndReturnArgs>(args?: SelectSubset<T, CodeSuggestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSuggestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CodeSuggestion.
     * @param {CodeSuggestionDeleteArgs} args - Arguments to delete one CodeSuggestion.
     * @example
     * // Delete one CodeSuggestion
     * const CodeSuggestion = await prisma.codeSuggestion.delete({
     *   where: {
     *     // ... filter to delete one CodeSuggestion
     *   }
     * })
     * 
     */
    delete<T extends CodeSuggestionDeleteArgs>(args: SelectSubset<T, CodeSuggestionDeleteArgs<ExtArgs>>): Prisma__CodeSuggestionClient<$Result.GetResult<Prisma.$CodeSuggestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CodeSuggestion.
     * @param {CodeSuggestionUpdateArgs} args - Arguments to update one CodeSuggestion.
     * @example
     * // Update one CodeSuggestion
     * const codeSuggestion = await prisma.codeSuggestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CodeSuggestionUpdateArgs>(args: SelectSubset<T, CodeSuggestionUpdateArgs<ExtArgs>>): Prisma__CodeSuggestionClient<$Result.GetResult<Prisma.$CodeSuggestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CodeSuggestions.
     * @param {CodeSuggestionDeleteManyArgs} args - Arguments to filter CodeSuggestions to delete.
     * @example
     * // Delete a few CodeSuggestions
     * const { count } = await prisma.codeSuggestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CodeSuggestionDeleteManyArgs>(args?: SelectSubset<T, CodeSuggestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeSuggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSuggestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeSuggestions
     * const codeSuggestion = await prisma.codeSuggestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CodeSuggestionUpdateManyArgs>(args: SelectSubset<T, CodeSuggestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeSuggestions and returns the data updated in the database.
     * @param {CodeSuggestionUpdateManyAndReturnArgs} args - Arguments to update many CodeSuggestions.
     * @example
     * // Update many CodeSuggestions
     * const codeSuggestion = await prisma.codeSuggestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CodeSuggestions and only return the `id`
     * const codeSuggestionWithIdOnly = await prisma.codeSuggestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CodeSuggestionUpdateManyAndReturnArgs>(args: SelectSubset<T, CodeSuggestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSuggestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CodeSuggestion.
     * @param {CodeSuggestionUpsertArgs} args - Arguments to update or create a CodeSuggestion.
     * @example
     * // Update or create a CodeSuggestion
     * const codeSuggestion = await prisma.codeSuggestion.upsert({
     *   create: {
     *     // ... data to create a CodeSuggestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeSuggestion we want to update
     *   }
     * })
     */
    upsert<T extends CodeSuggestionUpsertArgs>(args: SelectSubset<T, CodeSuggestionUpsertArgs<ExtArgs>>): Prisma__CodeSuggestionClient<$Result.GetResult<Prisma.$CodeSuggestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CodeSuggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSuggestionCountArgs} args - Arguments to filter CodeSuggestions to count.
     * @example
     * // Count the number of CodeSuggestions
     * const count = await prisma.codeSuggestion.count({
     *   where: {
     *     // ... the filter for the CodeSuggestions we want to count
     *   }
     * })
    **/
    count<T extends CodeSuggestionCountArgs>(
      args?: Subset<T, CodeSuggestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeSuggestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeSuggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSuggestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeSuggestionAggregateArgs>(args: Subset<T, CodeSuggestionAggregateArgs>): Prisma.PrismaPromise<GetCodeSuggestionAggregateType<T>>

    /**
     * Group by CodeSuggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSuggestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeSuggestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeSuggestionGroupByArgs['orderBy'] }
        : { orderBy?: CodeSuggestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeSuggestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeSuggestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CodeSuggestion model
   */
  readonly fields: CodeSuggestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CodeSuggestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CodeSuggestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    generation<T extends SuggestionGenerationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SuggestionGenerationDefaultArgs<ExtArgs>>): Prisma__SuggestionGenerationClient<$Result.GetResult<Prisma.$SuggestionGenerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    selections<T extends CodeSuggestion$selectionsArgs<ExtArgs> = {}>(args?: Subset<T, CodeSuggestion$selectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSelectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CodeSuggestion model
   */
  interface CodeSuggestionFieldRefs {
    readonly id: FieldRef<"CodeSuggestion", 'String'>
    readonly encounterId: FieldRef<"CodeSuggestion", 'String'>
    readonly generationId: FieldRef<"CodeSuggestion", 'String'>
    readonly code: FieldRef<"CodeSuggestion", 'String'>
    readonly codeType: FieldRef<"CodeSuggestion", 'String'>
    readonly category: FieldRef<"CodeSuggestion", 'SuggestionCategory'>
    readonly title: FieldRef<"CodeSuggestion", 'String'>
    readonly description: FieldRef<"CodeSuggestion", 'String'>
    readonly rationale: FieldRef<"CodeSuggestion", 'String'>
    readonly confidence: FieldRef<"CodeSuggestion", 'Float'>
    readonly evidence: FieldRef<"CodeSuggestion", 'Json'>
    readonly status: FieldRef<"CodeSuggestion", 'SuggestionStatus'>
    readonly recommended: FieldRef<"CodeSuggestion", 'Boolean'>
    readonly metadata: FieldRef<"CodeSuggestion", 'Json'>
    readonly createdAt: FieldRef<"CodeSuggestion", 'DateTime'>
    readonly updatedAt: FieldRef<"CodeSuggestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CodeSuggestion findUnique
   */
  export type CodeSuggestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which CodeSuggestion to fetch.
     */
    where: CodeSuggestionWhereUniqueInput
  }

  /**
   * CodeSuggestion findUniqueOrThrow
   */
  export type CodeSuggestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which CodeSuggestion to fetch.
     */
    where: CodeSuggestionWhereUniqueInput
  }

  /**
   * CodeSuggestion findFirst
   */
  export type CodeSuggestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which CodeSuggestion to fetch.
     */
    where?: CodeSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeSuggestions to fetch.
     */
    orderBy?: CodeSuggestionOrderByWithRelationInput | CodeSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeSuggestions.
     */
    cursor?: CodeSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeSuggestions.
     */
    distinct?: CodeSuggestionScalarFieldEnum | CodeSuggestionScalarFieldEnum[]
  }

  /**
   * CodeSuggestion findFirstOrThrow
   */
  export type CodeSuggestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which CodeSuggestion to fetch.
     */
    where?: CodeSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeSuggestions to fetch.
     */
    orderBy?: CodeSuggestionOrderByWithRelationInput | CodeSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeSuggestions.
     */
    cursor?: CodeSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeSuggestions.
     */
    distinct?: CodeSuggestionScalarFieldEnum | CodeSuggestionScalarFieldEnum[]
  }

  /**
   * CodeSuggestion findMany
   */
  export type CodeSuggestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which CodeSuggestions to fetch.
     */
    where?: CodeSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeSuggestions to fetch.
     */
    orderBy?: CodeSuggestionOrderByWithRelationInput | CodeSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodeSuggestions.
     */
    cursor?: CodeSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeSuggestions.
     */
    skip?: number
    distinct?: CodeSuggestionScalarFieldEnum | CodeSuggestionScalarFieldEnum[]
  }

  /**
   * CodeSuggestion create
   */
  export type CodeSuggestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionInclude<ExtArgs> | null
    /**
     * The data needed to create a CodeSuggestion.
     */
    data: XOR<CodeSuggestionCreateInput, CodeSuggestionUncheckedCreateInput>
  }

  /**
   * CodeSuggestion createMany
   */
  export type CodeSuggestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CodeSuggestions.
     */
    data: CodeSuggestionCreateManyInput | CodeSuggestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CodeSuggestion createManyAndReturn
   */
  export type CodeSuggestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * The data used to create many CodeSuggestions.
     */
    data: CodeSuggestionCreateManyInput | CodeSuggestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CodeSuggestion update
   */
  export type CodeSuggestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionInclude<ExtArgs> | null
    /**
     * The data needed to update a CodeSuggestion.
     */
    data: XOR<CodeSuggestionUpdateInput, CodeSuggestionUncheckedUpdateInput>
    /**
     * Choose, which CodeSuggestion to update.
     */
    where: CodeSuggestionWhereUniqueInput
  }

  /**
   * CodeSuggestion updateMany
   */
  export type CodeSuggestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CodeSuggestions.
     */
    data: XOR<CodeSuggestionUpdateManyMutationInput, CodeSuggestionUncheckedUpdateManyInput>
    /**
     * Filter which CodeSuggestions to update
     */
    where?: CodeSuggestionWhereInput
    /**
     * Limit how many CodeSuggestions to update.
     */
    limit?: number
  }

  /**
   * CodeSuggestion updateManyAndReturn
   */
  export type CodeSuggestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * The data used to update CodeSuggestions.
     */
    data: XOR<CodeSuggestionUpdateManyMutationInput, CodeSuggestionUncheckedUpdateManyInput>
    /**
     * Filter which CodeSuggestions to update
     */
    where?: CodeSuggestionWhereInput
    /**
     * Limit how many CodeSuggestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CodeSuggestion upsert
   */
  export type CodeSuggestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionInclude<ExtArgs> | null
    /**
     * The filter to search for the CodeSuggestion to update in case it exists.
     */
    where: CodeSuggestionWhereUniqueInput
    /**
     * In case the CodeSuggestion found by the `where` argument doesn't exist, create a new CodeSuggestion with this data.
     */
    create: XOR<CodeSuggestionCreateInput, CodeSuggestionUncheckedCreateInput>
    /**
     * In case the CodeSuggestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CodeSuggestionUpdateInput, CodeSuggestionUncheckedUpdateInput>
  }

  /**
   * CodeSuggestion delete
   */
  export type CodeSuggestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionInclude<ExtArgs> | null
    /**
     * Filter which CodeSuggestion to delete.
     */
    where: CodeSuggestionWhereUniqueInput
  }

  /**
   * CodeSuggestion deleteMany
   */
  export type CodeSuggestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CodeSuggestions to delete
     */
    where?: CodeSuggestionWhereInput
    /**
     * Limit how many CodeSuggestions to delete.
     */
    limit?: number
  }

  /**
   * CodeSuggestion.selections
   */
  export type CodeSuggestion$selectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionInclude<ExtArgs> | null
    where?: CodeSelectionWhereInput
    orderBy?: CodeSelectionOrderByWithRelationInput | CodeSelectionOrderByWithRelationInput[]
    cursor?: CodeSelectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CodeSelectionScalarFieldEnum | CodeSelectionScalarFieldEnum[]
  }

  /**
   * CodeSuggestion without action
   */
  export type CodeSuggestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionInclude<ExtArgs> | null
  }


  /**
   * Model CodeSelection
   */

  export type AggregateCodeSelection = {
    _count: CodeSelectionCountAggregateOutputType | null
    _min: CodeSelectionMinAggregateOutputType | null
    _max: CodeSelectionMaxAggregateOutputType | null
  }

  export type CodeSelectionMinAggregateOutputType = {
    id: string | null
    encounterId: string | null
    codeSuggestionId: string | null
    code: string | null
    codeType: string | null
    category: $Enums.SuggestionCategory | null
    action: $Enums.SelectionAction | null
    decisionReason: string | null
    actorId: string | null
    createdAt: Date | null
  }

  export type CodeSelectionMaxAggregateOutputType = {
    id: string | null
    encounterId: string | null
    codeSuggestionId: string | null
    code: string | null
    codeType: string | null
    category: $Enums.SuggestionCategory | null
    action: $Enums.SelectionAction | null
    decisionReason: string | null
    actorId: string | null
    createdAt: Date | null
  }

  export type CodeSelectionCountAggregateOutputType = {
    id: number
    encounterId: number
    codeSuggestionId: number
    code: number
    codeType: number
    category: number
    action: number
    decisionReason: number
    actorId: number
    createdAt: number
    _all: number
  }


  export type CodeSelectionMinAggregateInputType = {
    id?: true
    encounterId?: true
    codeSuggestionId?: true
    code?: true
    codeType?: true
    category?: true
    action?: true
    decisionReason?: true
    actorId?: true
    createdAt?: true
  }

  export type CodeSelectionMaxAggregateInputType = {
    id?: true
    encounterId?: true
    codeSuggestionId?: true
    code?: true
    codeType?: true
    category?: true
    action?: true
    decisionReason?: true
    actorId?: true
    createdAt?: true
  }

  export type CodeSelectionCountAggregateInputType = {
    id?: true
    encounterId?: true
    codeSuggestionId?: true
    code?: true
    codeType?: true
    category?: true
    action?: true
    decisionReason?: true
    actorId?: true
    createdAt?: true
    _all?: true
  }

  export type CodeSelectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CodeSelection to aggregate.
     */
    where?: CodeSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeSelections to fetch.
     */
    orderBy?: CodeSelectionOrderByWithRelationInput | CodeSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CodeSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeSelections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodeSelections
    **/
    _count?: true | CodeSelectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeSelectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeSelectionMaxAggregateInputType
  }

  export type GetCodeSelectionAggregateType<T extends CodeSelectionAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeSelection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeSelection[P]>
      : GetScalarType<T[P], AggregateCodeSelection[P]>
  }




  export type CodeSelectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeSelectionWhereInput
    orderBy?: CodeSelectionOrderByWithAggregationInput | CodeSelectionOrderByWithAggregationInput[]
    by: CodeSelectionScalarFieldEnum[] | CodeSelectionScalarFieldEnum
    having?: CodeSelectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeSelectionCountAggregateInputType | true
    _min?: CodeSelectionMinAggregateInputType
    _max?: CodeSelectionMaxAggregateInputType
  }

  export type CodeSelectionGroupByOutputType = {
    id: string
    encounterId: string
    codeSuggestionId: string | null
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    action: $Enums.SelectionAction
    decisionReason: string | null
    actorId: string | null
    createdAt: Date
    _count: CodeSelectionCountAggregateOutputType | null
    _min: CodeSelectionMinAggregateOutputType | null
    _max: CodeSelectionMaxAggregateOutputType | null
  }

  type GetCodeSelectionGroupByPayload<T extends CodeSelectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CodeSelectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodeSelectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodeSelectionGroupByOutputType[P]>
            : GetScalarType<T[P], CodeSelectionGroupByOutputType[P]>
        }
      >
    >


  export type CodeSelectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    codeSuggestionId?: boolean
    code?: boolean
    codeType?: boolean
    category?: boolean
    action?: boolean
    decisionReason?: boolean
    actorId?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    codeSuggestion?: boolean | CodeSelection$codeSuggestionArgs<ExtArgs>
    actor?: boolean | CodeSelection$actorArgs<ExtArgs>
  }, ExtArgs["result"]["codeSelection"]>

  export type CodeSelectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    codeSuggestionId?: boolean
    code?: boolean
    codeType?: boolean
    category?: boolean
    action?: boolean
    decisionReason?: boolean
    actorId?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    codeSuggestion?: boolean | CodeSelection$codeSuggestionArgs<ExtArgs>
    actor?: boolean | CodeSelection$actorArgs<ExtArgs>
  }, ExtArgs["result"]["codeSelection"]>

  export type CodeSelectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    codeSuggestionId?: boolean
    code?: boolean
    codeType?: boolean
    category?: boolean
    action?: boolean
    decisionReason?: boolean
    actorId?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    codeSuggestion?: boolean | CodeSelection$codeSuggestionArgs<ExtArgs>
    actor?: boolean | CodeSelection$actorArgs<ExtArgs>
  }, ExtArgs["result"]["codeSelection"]>

  export type CodeSelectionSelectScalar = {
    id?: boolean
    encounterId?: boolean
    codeSuggestionId?: boolean
    code?: boolean
    codeType?: boolean
    category?: boolean
    action?: boolean
    decisionReason?: boolean
    actorId?: boolean
    createdAt?: boolean
  }

  export type CodeSelectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "encounterId" | "codeSuggestionId" | "code" | "codeType" | "category" | "action" | "decisionReason" | "actorId" | "createdAt", ExtArgs["result"]["codeSelection"]>
  export type CodeSelectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    codeSuggestion?: boolean | CodeSelection$codeSuggestionArgs<ExtArgs>
    actor?: boolean | CodeSelection$actorArgs<ExtArgs>
  }
  export type CodeSelectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    codeSuggestion?: boolean | CodeSelection$codeSuggestionArgs<ExtArgs>
    actor?: boolean | CodeSelection$actorArgs<ExtArgs>
  }
  export type CodeSelectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    codeSuggestion?: boolean | CodeSelection$codeSuggestionArgs<ExtArgs>
    actor?: boolean | CodeSelection$actorArgs<ExtArgs>
  }

  export type $CodeSelectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CodeSelection"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      codeSuggestion: Prisma.$CodeSuggestionPayload<ExtArgs> | null
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      encounterId: string
      codeSuggestionId: string | null
      code: string
      codeType: string
      category: $Enums.SuggestionCategory
      action: $Enums.SelectionAction
      decisionReason: string | null
      actorId: string | null
      createdAt: Date
    }, ExtArgs["result"]["codeSelection"]>
    composites: {}
  }

  type CodeSelectionGetPayload<S extends boolean | null | undefined | CodeSelectionDefaultArgs> = $Result.GetResult<Prisma.$CodeSelectionPayload, S>

  type CodeSelectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CodeSelectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CodeSelectionCountAggregateInputType | true
    }

  export interface CodeSelectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CodeSelection'], meta: { name: 'CodeSelection' } }
    /**
     * Find zero or one CodeSelection that matches the filter.
     * @param {CodeSelectionFindUniqueArgs} args - Arguments to find a CodeSelection
     * @example
     * // Get one CodeSelection
     * const codeSelection = await prisma.codeSelection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CodeSelectionFindUniqueArgs>(args: SelectSubset<T, CodeSelectionFindUniqueArgs<ExtArgs>>): Prisma__CodeSelectionClient<$Result.GetResult<Prisma.$CodeSelectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CodeSelection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CodeSelectionFindUniqueOrThrowArgs} args - Arguments to find a CodeSelection
     * @example
     * // Get one CodeSelection
     * const codeSelection = await prisma.codeSelection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CodeSelectionFindUniqueOrThrowArgs>(args: SelectSubset<T, CodeSelectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CodeSelectionClient<$Result.GetResult<Prisma.$CodeSelectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CodeSelection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSelectionFindFirstArgs} args - Arguments to find a CodeSelection
     * @example
     * // Get one CodeSelection
     * const codeSelection = await prisma.codeSelection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CodeSelectionFindFirstArgs>(args?: SelectSubset<T, CodeSelectionFindFirstArgs<ExtArgs>>): Prisma__CodeSelectionClient<$Result.GetResult<Prisma.$CodeSelectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CodeSelection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSelectionFindFirstOrThrowArgs} args - Arguments to find a CodeSelection
     * @example
     * // Get one CodeSelection
     * const codeSelection = await prisma.codeSelection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CodeSelectionFindFirstOrThrowArgs>(args?: SelectSubset<T, CodeSelectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CodeSelectionClient<$Result.GetResult<Prisma.$CodeSelectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CodeSelections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSelectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeSelections
     * const codeSelections = await prisma.codeSelection.findMany()
     * 
     * // Get first 10 CodeSelections
     * const codeSelections = await prisma.codeSelection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const codeSelectionWithIdOnly = await prisma.codeSelection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CodeSelectionFindManyArgs>(args?: SelectSubset<T, CodeSelectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSelectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CodeSelection.
     * @param {CodeSelectionCreateArgs} args - Arguments to create a CodeSelection.
     * @example
     * // Create one CodeSelection
     * const CodeSelection = await prisma.codeSelection.create({
     *   data: {
     *     // ... data to create a CodeSelection
     *   }
     * })
     * 
     */
    create<T extends CodeSelectionCreateArgs>(args: SelectSubset<T, CodeSelectionCreateArgs<ExtArgs>>): Prisma__CodeSelectionClient<$Result.GetResult<Prisma.$CodeSelectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CodeSelections.
     * @param {CodeSelectionCreateManyArgs} args - Arguments to create many CodeSelections.
     * @example
     * // Create many CodeSelections
     * const codeSelection = await prisma.codeSelection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CodeSelectionCreateManyArgs>(args?: SelectSubset<T, CodeSelectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CodeSelections and returns the data saved in the database.
     * @param {CodeSelectionCreateManyAndReturnArgs} args - Arguments to create many CodeSelections.
     * @example
     * // Create many CodeSelections
     * const codeSelection = await prisma.codeSelection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CodeSelections and only return the `id`
     * const codeSelectionWithIdOnly = await prisma.codeSelection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CodeSelectionCreateManyAndReturnArgs>(args?: SelectSubset<T, CodeSelectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSelectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CodeSelection.
     * @param {CodeSelectionDeleteArgs} args - Arguments to delete one CodeSelection.
     * @example
     * // Delete one CodeSelection
     * const CodeSelection = await prisma.codeSelection.delete({
     *   where: {
     *     // ... filter to delete one CodeSelection
     *   }
     * })
     * 
     */
    delete<T extends CodeSelectionDeleteArgs>(args: SelectSubset<T, CodeSelectionDeleteArgs<ExtArgs>>): Prisma__CodeSelectionClient<$Result.GetResult<Prisma.$CodeSelectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CodeSelection.
     * @param {CodeSelectionUpdateArgs} args - Arguments to update one CodeSelection.
     * @example
     * // Update one CodeSelection
     * const codeSelection = await prisma.codeSelection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CodeSelectionUpdateArgs>(args: SelectSubset<T, CodeSelectionUpdateArgs<ExtArgs>>): Prisma__CodeSelectionClient<$Result.GetResult<Prisma.$CodeSelectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CodeSelections.
     * @param {CodeSelectionDeleteManyArgs} args - Arguments to filter CodeSelections to delete.
     * @example
     * // Delete a few CodeSelections
     * const { count } = await prisma.codeSelection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CodeSelectionDeleteManyArgs>(args?: SelectSubset<T, CodeSelectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeSelections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSelectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeSelections
     * const codeSelection = await prisma.codeSelection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CodeSelectionUpdateManyArgs>(args: SelectSubset<T, CodeSelectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeSelections and returns the data updated in the database.
     * @param {CodeSelectionUpdateManyAndReturnArgs} args - Arguments to update many CodeSelections.
     * @example
     * // Update many CodeSelections
     * const codeSelection = await prisma.codeSelection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CodeSelections and only return the `id`
     * const codeSelectionWithIdOnly = await prisma.codeSelection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CodeSelectionUpdateManyAndReturnArgs>(args: SelectSubset<T, CodeSelectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSelectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CodeSelection.
     * @param {CodeSelectionUpsertArgs} args - Arguments to update or create a CodeSelection.
     * @example
     * // Update or create a CodeSelection
     * const codeSelection = await prisma.codeSelection.upsert({
     *   create: {
     *     // ... data to create a CodeSelection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeSelection we want to update
     *   }
     * })
     */
    upsert<T extends CodeSelectionUpsertArgs>(args: SelectSubset<T, CodeSelectionUpsertArgs<ExtArgs>>): Prisma__CodeSelectionClient<$Result.GetResult<Prisma.$CodeSelectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CodeSelections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSelectionCountArgs} args - Arguments to filter CodeSelections to count.
     * @example
     * // Count the number of CodeSelections
     * const count = await prisma.codeSelection.count({
     *   where: {
     *     // ... the filter for the CodeSelections we want to count
     *   }
     * })
    **/
    count<T extends CodeSelectionCountArgs>(
      args?: Subset<T, CodeSelectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeSelectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeSelection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSelectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeSelectionAggregateArgs>(args: Subset<T, CodeSelectionAggregateArgs>): Prisma.PrismaPromise<GetCodeSelectionAggregateType<T>>

    /**
     * Group by CodeSelection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSelectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeSelectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeSelectionGroupByArgs['orderBy'] }
        : { orderBy?: CodeSelectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeSelectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeSelectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CodeSelection model
   */
  readonly fields: CodeSelectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CodeSelection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CodeSelectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    codeSuggestion<T extends CodeSelection$codeSuggestionArgs<ExtArgs> = {}>(args?: Subset<T, CodeSelection$codeSuggestionArgs<ExtArgs>>): Prisma__CodeSuggestionClient<$Result.GetResult<Prisma.$CodeSuggestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    actor<T extends CodeSelection$actorArgs<ExtArgs> = {}>(args?: Subset<T, CodeSelection$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CodeSelection model
   */
  interface CodeSelectionFieldRefs {
    readonly id: FieldRef<"CodeSelection", 'String'>
    readonly encounterId: FieldRef<"CodeSelection", 'String'>
    readonly codeSuggestionId: FieldRef<"CodeSelection", 'String'>
    readonly code: FieldRef<"CodeSelection", 'String'>
    readonly codeType: FieldRef<"CodeSelection", 'String'>
    readonly category: FieldRef<"CodeSelection", 'SuggestionCategory'>
    readonly action: FieldRef<"CodeSelection", 'SelectionAction'>
    readonly decisionReason: FieldRef<"CodeSelection", 'String'>
    readonly actorId: FieldRef<"CodeSelection", 'String'>
    readonly createdAt: FieldRef<"CodeSelection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CodeSelection findUnique
   */
  export type CodeSelectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionInclude<ExtArgs> | null
    /**
     * Filter, which CodeSelection to fetch.
     */
    where: CodeSelectionWhereUniqueInput
  }

  /**
   * CodeSelection findUniqueOrThrow
   */
  export type CodeSelectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionInclude<ExtArgs> | null
    /**
     * Filter, which CodeSelection to fetch.
     */
    where: CodeSelectionWhereUniqueInput
  }

  /**
   * CodeSelection findFirst
   */
  export type CodeSelectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionInclude<ExtArgs> | null
    /**
     * Filter, which CodeSelection to fetch.
     */
    where?: CodeSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeSelections to fetch.
     */
    orderBy?: CodeSelectionOrderByWithRelationInput | CodeSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeSelections.
     */
    cursor?: CodeSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeSelections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeSelections.
     */
    distinct?: CodeSelectionScalarFieldEnum | CodeSelectionScalarFieldEnum[]
  }

  /**
   * CodeSelection findFirstOrThrow
   */
  export type CodeSelectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionInclude<ExtArgs> | null
    /**
     * Filter, which CodeSelection to fetch.
     */
    where?: CodeSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeSelections to fetch.
     */
    orderBy?: CodeSelectionOrderByWithRelationInput | CodeSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeSelections.
     */
    cursor?: CodeSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeSelections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeSelections.
     */
    distinct?: CodeSelectionScalarFieldEnum | CodeSelectionScalarFieldEnum[]
  }

  /**
   * CodeSelection findMany
   */
  export type CodeSelectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionInclude<ExtArgs> | null
    /**
     * Filter, which CodeSelections to fetch.
     */
    where?: CodeSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeSelections to fetch.
     */
    orderBy?: CodeSelectionOrderByWithRelationInput | CodeSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodeSelections.
     */
    cursor?: CodeSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeSelections.
     */
    skip?: number
    distinct?: CodeSelectionScalarFieldEnum | CodeSelectionScalarFieldEnum[]
  }

  /**
   * CodeSelection create
   */
  export type CodeSelectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionInclude<ExtArgs> | null
    /**
     * The data needed to create a CodeSelection.
     */
    data: XOR<CodeSelectionCreateInput, CodeSelectionUncheckedCreateInput>
  }

  /**
   * CodeSelection createMany
   */
  export type CodeSelectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CodeSelections.
     */
    data: CodeSelectionCreateManyInput | CodeSelectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CodeSelection createManyAndReturn
   */
  export type CodeSelectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * The data used to create many CodeSelections.
     */
    data: CodeSelectionCreateManyInput | CodeSelectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CodeSelection update
   */
  export type CodeSelectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionInclude<ExtArgs> | null
    /**
     * The data needed to update a CodeSelection.
     */
    data: XOR<CodeSelectionUpdateInput, CodeSelectionUncheckedUpdateInput>
    /**
     * Choose, which CodeSelection to update.
     */
    where: CodeSelectionWhereUniqueInput
  }

  /**
   * CodeSelection updateMany
   */
  export type CodeSelectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CodeSelections.
     */
    data: XOR<CodeSelectionUpdateManyMutationInput, CodeSelectionUncheckedUpdateManyInput>
    /**
     * Filter which CodeSelections to update
     */
    where?: CodeSelectionWhereInput
    /**
     * Limit how many CodeSelections to update.
     */
    limit?: number
  }

  /**
   * CodeSelection updateManyAndReturn
   */
  export type CodeSelectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * The data used to update CodeSelections.
     */
    data: XOR<CodeSelectionUpdateManyMutationInput, CodeSelectionUncheckedUpdateManyInput>
    /**
     * Filter which CodeSelections to update
     */
    where?: CodeSelectionWhereInput
    /**
     * Limit how many CodeSelections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CodeSelection upsert
   */
  export type CodeSelectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionInclude<ExtArgs> | null
    /**
     * The filter to search for the CodeSelection to update in case it exists.
     */
    where: CodeSelectionWhereUniqueInput
    /**
     * In case the CodeSelection found by the `where` argument doesn't exist, create a new CodeSelection with this data.
     */
    create: XOR<CodeSelectionCreateInput, CodeSelectionUncheckedCreateInput>
    /**
     * In case the CodeSelection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CodeSelectionUpdateInput, CodeSelectionUncheckedUpdateInput>
  }

  /**
   * CodeSelection delete
   */
  export type CodeSelectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionInclude<ExtArgs> | null
    /**
     * Filter which CodeSelection to delete.
     */
    where: CodeSelectionWhereUniqueInput
  }

  /**
   * CodeSelection deleteMany
   */
  export type CodeSelectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CodeSelections to delete
     */
    where?: CodeSelectionWhereInput
    /**
     * Limit how many CodeSelections to delete.
     */
    limit?: number
  }

  /**
   * CodeSelection.codeSuggestion
   */
  export type CodeSelection$codeSuggestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSuggestion
     */
    select?: CodeSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSuggestion
     */
    omit?: CodeSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSuggestionInclude<ExtArgs> | null
    where?: CodeSuggestionWhereInput
  }

  /**
   * CodeSelection.actor
   */
  export type CodeSelection$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CodeSelection without action
   */
  export type CodeSelectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSelection
     */
    select?: CodeSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSelection
     */
    omit?: CodeSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSelectionInclude<ExtArgs> | null
  }


  /**
   * Model ComplianceIssue
   */

  export type AggregateComplianceIssue = {
    _count: ComplianceIssueCountAggregateOutputType | null
    _min: ComplianceIssueMinAggregateOutputType | null
    _max: ComplianceIssueMaxAggregateOutputType | null
  }

  export type ComplianceIssueMinAggregateOutputType = {
    id: string | null
    encounterId: string | null
    severity: $Enums.ComplianceSeverity | null
    status: $Enums.ComplianceStatus | null
    title: string | null
    description: string | null
    rationale: string | null
    remediation: string | null
    fingerprint: string | null
    actorId: string | null
    resolvedAt: Date | null
    dismissedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplianceIssueMaxAggregateOutputType = {
    id: string | null
    encounterId: string | null
    severity: $Enums.ComplianceSeverity | null
    status: $Enums.ComplianceStatus | null
    title: string | null
    description: string | null
    rationale: string | null
    remediation: string | null
    fingerprint: string | null
    actorId: string | null
    resolvedAt: Date | null
    dismissedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplianceIssueCountAggregateOutputType = {
    id: number
    encounterId: number
    severity: number
    status: number
    title: number
    description: number
    rationale: number
    remediation: number
    evidence: number
    fingerprint: number
    actorId: number
    resolvedAt: number
    dismissedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplianceIssueMinAggregateInputType = {
    id?: true
    encounterId?: true
    severity?: true
    status?: true
    title?: true
    description?: true
    rationale?: true
    remediation?: true
    fingerprint?: true
    actorId?: true
    resolvedAt?: true
    dismissedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplianceIssueMaxAggregateInputType = {
    id?: true
    encounterId?: true
    severity?: true
    status?: true
    title?: true
    description?: true
    rationale?: true
    remediation?: true
    fingerprint?: true
    actorId?: true
    resolvedAt?: true
    dismissedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplianceIssueCountAggregateInputType = {
    id?: true
    encounterId?: true
    severity?: true
    status?: true
    title?: true
    description?: true
    rationale?: true
    remediation?: true
    evidence?: true
    fingerprint?: true
    actorId?: true
    resolvedAt?: true
    dismissedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplianceIssueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceIssue to aggregate.
     */
    where?: ComplianceIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceIssues to fetch.
     */
    orderBy?: ComplianceIssueOrderByWithRelationInput | ComplianceIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplianceIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplianceIssues
    **/
    _count?: true | ComplianceIssueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplianceIssueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplianceIssueMaxAggregateInputType
  }

  export type GetComplianceIssueAggregateType<T extends ComplianceIssueAggregateArgs> = {
        [P in keyof T & keyof AggregateComplianceIssue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplianceIssue[P]>
      : GetScalarType<T[P], AggregateComplianceIssue[P]>
  }




  export type ComplianceIssueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceIssueWhereInput
    orderBy?: ComplianceIssueOrderByWithAggregationInput | ComplianceIssueOrderByWithAggregationInput[]
    by: ComplianceIssueScalarFieldEnum[] | ComplianceIssueScalarFieldEnum
    having?: ComplianceIssueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplianceIssueCountAggregateInputType | true
    _min?: ComplianceIssueMinAggregateInputType
    _max?: ComplianceIssueMaxAggregateInputType
  }

  export type ComplianceIssueGroupByOutputType = {
    id: string
    encounterId: string
    severity: $Enums.ComplianceSeverity
    status: $Enums.ComplianceStatus
    title: string
    description: string
    rationale: string
    remediation: string
    evidence: JsonValue | null
    fingerprint: string
    actorId: string | null
    resolvedAt: Date | null
    dismissedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ComplianceIssueCountAggregateOutputType | null
    _min: ComplianceIssueMinAggregateOutputType | null
    _max: ComplianceIssueMaxAggregateOutputType | null
  }

  type GetComplianceIssueGroupByPayload<T extends ComplianceIssueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplianceIssueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplianceIssueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplianceIssueGroupByOutputType[P]>
            : GetScalarType<T[P], ComplianceIssueGroupByOutputType[P]>
        }
      >
    >


  export type ComplianceIssueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    rationale?: boolean
    remediation?: boolean
    evidence?: boolean
    fingerprint?: boolean
    actorId?: boolean
    resolvedAt?: boolean
    dismissedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    actor?: boolean | ComplianceIssue$actorArgs<ExtArgs>
  }, ExtArgs["result"]["complianceIssue"]>

  export type ComplianceIssueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    rationale?: boolean
    remediation?: boolean
    evidence?: boolean
    fingerprint?: boolean
    actorId?: boolean
    resolvedAt?: boolean
    dismissedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    actor?: boolean | ComplianceIssue$actorArgs<ExtArgs>
  }, ExtArgs["result"]["complianceIssue"]>

  export type ComplianceIssueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    rationale?: boolean
    remediation?: boolean
    evidence?: boolean
    fingerprint?: boolean
    actorId?: boolean
    resolvedAt?: boolean
    dismissedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    actor?: boolean | ComplianceIssue$actorArgs<ExtArgs>
  }, ExtArgs["result"]["complianceIssue"]>

  export type ComplianceIssueSelectScalar = {
    id?: boolean
    encounterId?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    rationale?: boolean
    remediation?: boolean
    evidence?: boolean
    fingerprint?: boolean
    actorId?: boolean
    resolvedAt?: boolean
    dismissedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComplianceIssueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "encounterId" | "severity" | "status" | "title" | "description" | "rationale" | "remediation" | "evidence" | "fingerprint" | "actorId" | "resolvedAt" | "dismissedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["complianceIssue"]>
  export type ComplianceIssueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    actor?: boolean | ComplianceIssue$actorArgs<ExtArgs>
  }
  export type ComplianceIssueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    actor?: boolean | ComplianceIssue$actorArgs<ExtArgs>
  }
  export type ComplianceIssueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    actor?: boolean | ComplianceIssue$actorArgs<ExtArgs>
  }

  export type $ComplianceIssuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplianceIssue"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      encounterId: string
      severity: $Enums.ComplianceSeverity
      status: $Enums.ComplianceStatus
      title: string
      description: string
      rationale: string
      remediation: string
      evidence: Prisma.JsonValue | null
      fingerprint: string
      actorId: string | null
      resolvedAt: Date | null
      dismissedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complianceIssue"]>
    composites: {}
  }

  type ComplianceIssueGetPayload<S extends boolean | null | undefined | ComplianceIssueDefaultArgs> = $Result.GetResult<Prisma.$ComplianceIssuePayload, S>

  type ComplianceIssueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplianceIssueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplianceIssueCountAggregateInputType | true
    }

  export interface ComplianceIssueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplianceIssue'], meta: { name: 'ComplianceIssue' } }
    /**
     * Find zero or one ComplianceIssue that matches the filter.
     * @param {ComplianceIssueFindUniqueArgs} args - Arguments to find a ComplianceIssue
     * @example
     * // Get one ComplianceIssue
     * const complianceIssue = await prisma.complianceIssue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplianceIssueFindUniqueArgs>(args: SelectSubset<T, ComplianceIssueFindUniqueArgs<ExtArgs>>): Prisma__ComplianceIssueClient<$Result.GetResult<Prisma.$ComplianceIssuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComplianceIssue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplianceIssueFindUniqueOrThrowArgs} args - Arguments to find a ComplianceIssue
     * @example
     * // Get one ComplianceIssue
     * const complianceIssue = await prisma.complianceIssue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplianceIssueFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplianceIssueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplianceIssueClient<$Result.GetResult<Prisma.$ComplianceIssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplianceIssue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceIssueFindFirstArgs} args - Arguments to find a ComplianceIssue
     * @example
     * // Get one ComplianceIssue
     * const complianceIssue = await prisma.complianceIssue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplianceIssueFindFirstArgs>(args?: SelectSubset<T, ComplianceIssueFindFirstArgs<ExtArgs>>): Prisma__ComplianceIssueClient<$Result.GetResult<Prisma.$ComplianceIssuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplianceIssue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceIssueFindFirstOrThrowArgs} args - Arguments to find a ComplianceIssue
     * @example
     * // Get one ComplianceIssue
     * const complianceIssue = await prisma.complianceIssue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplianceIssueFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplianceIssueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplianceIssueClient<$Result.GetResult<Prisma.$ComplianceIssuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComplianceIssues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceIssueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplianceIssues
     * const complianceIssues = await prisma.complianceIssue.findMany()
     * 
     * // Get first 10 ComplianceIssues
     * const complianceIssues = await prisma.complianceIssue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complianceIssueWithIdOnly = await prisma.complianceIssue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplianceIssueFindManyArgs>(args?: SelectSubset<T, ComplianceIssueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComplianceIssue.
     * @param {ComplianceIssueCreateArgs} args - Arguments to create a ComplianceIssue.
     * @example
     * // Create one ComplianceIssue
     * const ComplianceIssue = await prisma.complianceIssue.create({
     *   data: {
     *     // ... data to create a ComplianceIssue
     *   }
     * })
     * 
     */
    create<T extends ComplianceIssueCreateArgs>(args: SelectSubset<T, ComplianceIssueCreateArgs<ExtArgs>>): Prisma__ComplianceIssueClient<$Result.GetResult<Prisma.$ComplianceIssuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComplianceIssues.
     * @param {ComplianceIssueCreateManyArgs} args - Arguments to create many ComplianceIssues.
     * @example
     * // Create many ComplianceIssues
     * const complianceIssue = await prisma.complianceIssue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplianceIssueCreateManyArgs>(args?: SelectSubset<T, ComplianceIssueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplianceIssues and returns the data saved in the database.
     * @param {ComplianceIssueCreateManyAndReturnArgs} args - Arguments to create many ComplianceIssues.
     * @example
     * // Create many ComplianceIssues
     * const complianceIssue = await prisma.complianceIssue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplianceIssues and only return the `id`
     * const complianceIssueWithIdOnly = await prisma.complianceIssue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplianceIssueCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplianceIssueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceIssuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComplianceIssue.
     * @param {ComplianceIssueDeleteArgs} args - Arguments to delete one ComplianceIssue.
     * @example
     * // Delete one ComplianceIssue
     * const ComplianceIssue = await prisma.complianceIssue.delete({
     *   where: {
     *     // ... filter to delete one ComplianceIssue
     *   }
     * })
     * 
     */
    delete<T extends ComplianceIssueDeleteArgs>(args: SelectSubset<T, ComplianceIssueDeleteArgs<ExtArgs>>): Prisma__ComplianceIssueClient<$Result.GetResult<Prisma.$ComplianceIssuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComplianceIssue.
     * @param {ComplianceIssueUpdateArgs} args - Arguments to update one ComplianceIssue.
     * @example
     * // Update one ComplianceIssue
     * const complianceIssue = await prisma.complianceIssue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplianceIssueUpdateArgs>(args: SelectSubset<T, ComplianceIssueUpdateArgs<ExtArgs>>): Prisma__ComplianceIssueClient<$Result.GetResult<Prisma.$ComplianceIssuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComplianceIssues.
     * @param {ComplianceIssueDeleteManyArgs} args - Arguments to filter ComplianceIssues to delete.
     * @example
     * // Delete a few ComplianceIssues
     * const { count } = await prisma.complianceIssue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplianceIssueDeleteManyArgs>(args?: SelectSubset<T, ComplianceIssueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceIssues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceIssueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplianceIssues
     * const complianceIssue = await prisma.complianceIssue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplianceIssueUpdateManyArgs>(args: SelectSubset<T, ComplianceIssueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceIssues and returns the data updated in the database.
     * @param {ComplianceIssueUpdateManyAndReturnArgs} args - Arguments to update many ComplianceIssues.
     * @example
     * // Update many ComplianceIssues
     * const complianceIssue = await prisma.complianceIssue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComplianceIssues and only return the `id`
     * const complianceIssueWithIdOnly = await prisma.complianceIssue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComplianceIssueUpdateManyAndReturnArgs>(args: SelectSubset<T, ComplianceIssueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceIssuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComplianceIssue.
     * @param {ComplianceIssueUpsertArgs} args - Arguments to update or create a ComplianceIssue.
     * @example
     * // Update or create a ComplianceIssue
     * const complianceIssue = await prisma.complianceIssue.upsert({
     *   create: {
     *     // ... data to create a ComplianceIssue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplianceIssue we want to update
     *   }
     * })
     */
    upsert<T extends ComplianceIssueUpsertArgs>(args: SelectSubset<T, ComplianceIssueUpsertArgs<ExtArgs>>): Prisma__ComplianceIssueClient<$Result.GetResult<Prisma.$ComplianceIssuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComplianceIssues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceIssueCountArgs} args - Arguments to filter ComplianceIssues to count.
     * @example
     * // Count the number of ComplianceIssues
     * const count = await prisma.complianceIssue.count({
     *   where: {
     *     // ... the filter for the ComplianceIssues we want to count
     *   }
     * })
    **/
    count<T extends ComplianceIssueCountArgs>(
      args?: Subset<T, ComplianceIssueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplianceIssueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplianceIssue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceIssueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplianceIssueAggregateArgs>(args: Subset<T, ComplianceIssueAggregateArgs>): Prisma.PrismaPromise<GetComplianceIssueAggregateType<T>>

    /**
     * Group by ComplianceIssue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceIssueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplianceIssueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplianceIssueGroupByArgs['orderBy'] }
        : { orderBy?: ComplianceIssueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplianceIssueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplianceIssueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplianceIssue model
   */
  readonly fields: ComplianceIssueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplianceIssue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplianceIssueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    actor<T extends ComplianceIssue$actorArgs<ExtArgs> = {}>(args?: Subset<T, ComplianceIssue$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplianceIssue model
   */
  interface ComplianceIssueFieldRefs {
    readonly id: FieldRef<"ComplianceIssue", 'String'>
    readonly encounterId: FieldRef<"ComplianceIssue", 'String'>
    readonly severity: FieldRef<"ComplianceIssue", 'ComplianceSeverity'>
    readonly status: FieldRef<"ComplianceIssue", 'ComplianceStatus'>
    readonly title: FieldRef<"ComplianceIssue", 'String'>
    readonly description: FieldRef<"ComplianceIssue", 'String'>
    readonly rationale: FieldRef<"ComplianceIssue", 'String'>
    readonly remediation: FieldRef<"ComplianceIssue", 'String'>
    readonly evidence: FieldRef<"ComplianceIssue", 'Json'>
    readonly fingerprint: FieldRef<"ComplianceIssue", 'String'>
    readonly actorId: FieldRef<"ComplianceIssue", 'String'>
    readonly resolvedAt: FieldRef<"ComplianceIssue", 'DateTime'>
    readonly dismissedAt: FieldRef<"ComplianceIssue", 'DateTime'>
    readonly createdAt: FieldRef<"ComplianceIssue", 'DateTime'>
    readonly updatedAt: FieldRef<"ComplianceIssue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplianceIssue findUnique
   */
  export type ComplianceIssueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceIssue
     */
    select?: ComplianceIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceIssue
     */
    omit?: ComplianceIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceIssueInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceIssue to fetch.
     */
    where: ComplianceIssueWhereUniqueInput
  }

  /**
   * ComplianceIssue findUniqueOrThrow
   */
  export type ComplianceIssueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceIssue
     */
    select?: ComplianceIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceIssue
     */
    omit?: ComplianceIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceIssueInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceIssue to fetch.
     */
    where: ComplianceIssueWhereUniqueInput
  }

  /**
   * ComplianceIssue findFirst
   */
  export type ComplianceIssueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceIssue
     */
    select?: ComplianceIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceIssue
     */
    omit?: ComplianceIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceIssueInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceIssue to fetch.
     */
    where?: ComplianceIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceIssues to fetch.
     */
    orderBy?: ComplianceIssueOrderByWithRelationInput | ComplianceIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceIssues.
     */
    cursor?: ComplianceIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceIssues.
     */
    distinct?: ComplianceIssueScalarFieldEnum | ComplianceIssueScalarFieldEnum[]
  }

  /**
   * ComplianceIssue findFirstOrThrow
   */
  export type ComplianceIssueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceIssue
     */
    select?: ComplianceIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceIssue
     */
    omit?: ComplianceIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceIssueInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceIssue to fetch.
     */
    where?: ComplianceIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceIssues to fetch.
     */
    orderBy?: ComplianceIssueOrderByWithRelationInput | ComplianceIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceIssues.
     */
    cursor?: ComplianceIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceIssues.
     */
    distinct?: ComplianceIssueScalarFieldEnum | ComplianceIssueScalarFieldEnum[]
  }

  /**
   * ComplianceIssue findMany
   */
  export type ComplianceIssueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceIssue
     */
    select?: ComplianceIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceIssue
     */
    omit?: ComplianceIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceIssueInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceIssues to fetch.
     */
    where?: ComplianceIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceIssues to fetch.
     */
    orderBy?: ComplianceIssueOrderByWithRelationInput | ComplianceIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplianceIssues.
     */
    cursor?: ComplianceIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceIssues.
     */
    skip?: number
    distinct?: ComplianceIssueScalarFieldEnum | ComplianceIssueScalarFieldEnum[]
  }

  /**
   * ComplianceIssue create
   */
  export type ComplianceIssueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceIssue
     */
    select?: ComplianceIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceIssue
     */
    omit?: ComplianceIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceIssueInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplianceIssue.
     */
    data: XOR<ComplianceIssueCreateInput, ComplianceIssueUncheckedCreateInput>
  }

  /**
   * ComplianceIssue createMany
   */
  export type ComplianceIssueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplianceIssues.
     */
    data: ComplianceIssueCreateManyInput | ComplianceIssueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplianceIssue createManyAndReturn
   */
  export type ComplianceIssueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceIssue
     */
    select?: ComplianceIssueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceIssue
     */
    omit?: ComplianceIssueOmit<ExtArgs> | null
    /**
     * The data used to create many ComplianceIssues.
     */
    data: ComplianceIssueCreateManyInput | ComplianceIssueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceIssueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplianceIssue update
   */
  export type ComplianceIssueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceIssue
     */
    select?: ComplianceIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceIssue
     */
    omit?: ComplianceIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceIssueInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplianceIssue.
     */
    data: XOR<ComplianceIssueUpdateInput, ComplianceIssueUncheckedUpdateInput>
    /**
     * Choose, which ComplianceIssue to update.
     */
    where: ComplianceIssueWhereUniqueInput
  }

  /**
   * ComplianceIssue updateMany
   */
  export type ComplianceIssueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplianceIssues.
     */
    data: XOR<ComplianceIssueUpdateManyMutationInput, ComplianceIssueUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceIssues to update
     */
    where?: ComplianceIssueWhereInput
    /**
     * Limit how many ComplianceIssues to update.
     */
    limit?: number
  }

  /**
   * ComplianceIssue updateManyAndReturn
   */
  export type ComplianceIssueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceIssue
     */
    select?: ComplianceIssueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceIssue
     */
    omit?: ComplianceIssueOmit<ExtArgs> | null
    /**
     * The data used to update ComplianceIssues.
     */
    data: XOR<ComplianceIssueUpdateManyMutationInput, ComplianceIssueUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceIssues to update
     */
    where?: ComplianceIssueWhereInput
    /**
     * Limit how many ComplianceIssues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceIssueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplianceIssue upsert
   */
  export type ComplianceIssueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceIssue
     */
    select?: ComplianceIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceIssue
     */
    omit?: ComplianceIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceIssueInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplianceIssue to update in case it exists.
     */
    where: ComplianceIssueWhereUniqueInput
    /**
     * In case the ComplianceIssue found by the `where` argument doesn't exist, create a new ComplianceIssue with this data.
     */
    create: XOR<ComplianceIssueCreateInput, ComplianceIssueUncheckedCreateInput>
    /**
     * In case the ComplianceIssue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplianceIssueUpdateInput, ComplianceIssueUncheckedUpdateInput>
  }

  /**
   * ComplianceIssue delete
   */
  export type ComplianceIssueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceIssue
     */
    select?: ComplianceIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceIssue
     */
    omit?: ComplianceIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceIssueInclude<ExtArgs> | null
    /**
     * Filter which ComplianceIssue to delete.
     */
    where: ComplianceIssueWhereUniqueInput
  }

  /**
   * ComplianceIssue deleteMany
   */
  export type ComplianceIssueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceIssues to delete
     */
    where?: ComplianceIssueWhereInput
    /**
     * Limit how many ComplianceIssues to delete.
     */
    limit?: number
  }

  /**
   * ComplianceIssue.actor
   */
  export type ComplianceIssue$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ComplianceIssue without action
   */
  export type ComplianceIssueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceIssue
     */
    select?: ComplianceIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceIssue
     */
    omit?: ComplianceIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceIssueInclude<ExtArgs> | null
  }


  /**
   * Model WizardRun
   */

  export type AggregateWizardRun = {
    _count: WizardRunCountAggregateOutputType | null
    _min: WizardRunMinAggregateOutputType | null
    _max: WizardRunMaxAggregateOutputType | null
  }

  export type WizardRunMinAggregateOutputType = {
    id: string | null
    encounterId: string | null
    status: $Enums.WizardRunStatus | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type WizardRunMaxAggregateOutputType = {
    id: string | null
    encounterId: string | null
    status: $Enums.WizardRunStatus | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type WizardRunCountAggregateOutputType = {
    id: number
    encounterId: number
    status: number
    runState: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type WizardRunMinAggregateInputType = {
    id?: true
    encounterId?: true
    status?: true
    startedAt?: true
    completedAt?: true
  }

  export type WizardRunMaxAggregateInputType = {
    id?: true
    encounterId?: true
    status?: true
    startedAt?: true
    completedAt?: true
  }

  export type WizardRunCountAggregateInputType = {
    id?: true
    encounterId?: true
    status?: true
    runState?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type WizardRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WizardRun to aggregate.
     */
    where?: WizardRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WizardRuns to fetch.
     */
    orderBy?: WizardRunOrderByWithRelationInput | WizardRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WizardRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WizardRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WizardRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WizardRuns
    **/
    _count?: true | WizardRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WizardRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WizardRunMaxAggregateInputType
  }

  export type GetWizardRunAggregateType<T extends WizardRunAggregateArgs> = {
        [P in keyof T & keyof AggregateWizardRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWizardRun[P]>
      : GetScalarType<T[P], AggregateWizardRun[P]>
  }




  export type WizardRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WizardRunWhereInput
    orderBy?: WizardRunOrderByWithAggregationInput | WizardRunOrderByWithAggregationInput[]
    by: WizardRunScalarFieldEnum[] | WizardRunScalarFieldEnum
    having?: WizardRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WizardRunCountAggregateInputType | true
    _min?: WizardRunMinAggregateInputType
    _max?: WizardRunMaxAggregateInputType
  }

  export type WizardRunGroupByOutputType = {
    id: string
    encounterId: string
    status: $Enums.WizardRunStatus
    runState: JsonValue | null
    startedAt: Date
    completedAt: Date | null
    _count: WizardRunCountAggregateOutputType | null
    _min: WizardRunMinAggregateOutputType | null
    _max: WizardRunMaxAggregateOutputType | null
  }

  type GetWizardRunGroupByPayload<T extends WizardRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WizardRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WizardRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WizardRunGroupByOutputType[P]>
            : GetScalarType<T[P], WizardRunGroupByOutputType[P]>
        }
      >
    >


  export type WizardRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    status?: boolean
    runState?: boolean
    startedAt?: boolean
    completedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    stepStates?: boolean | WizardRun$stepStatesArgs<ExtArgs>
    _count?: boolean | WizardRunCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wizardRun"]>

  export type WizardRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    status?: boolean
    runState?: boolean
    startedAt?: boolean
    completedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wizardRun"]>

  export type WizardRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    status?: boolean
    runState?: boolean
    startedAt?: boolean
    completedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wizardRun"]>

  export type WizardRunSelectScalar = {
    id?: boolean
    encounterId?: boolean
    status?: boolean
    runState?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type WizardRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "encounterId" | "status" | "runState" | "startedAt" | "completedAt", ExtArgs["result"]["wizardRun"]>
  export type WizardRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    stepStates?: boolean | WizardRun$stepStatesArgs<ExtArgs>
    _count?: boolean | WizardRunCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WizardRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }
  export type WizardRunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }

  export type $WizardRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WizardRun"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      stepStates: Prisma.$WizardStepStatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      encounterId: string
      status: $Enums.WizardRunStatus
      runState: Prisma.JsonValue | null
      startedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["wizardRun"]>
    composites: {}
  }

  type WizardRunGetPayload<S extends boolean | null | undefined | WizardRunDefaultArgs> = $Result.GetResult<Prisma.$WizardRunPayload, S>

  type WizardRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WizardRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WizardRunCountAggregateInputType | true
    }

  export interface WizardRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WizardRun'], meta: { name: 'WizardRun' } }
    /**
     * Find zero or one WizardRun that matches the filter.
     * @param {WizardRunFindUniqueArgs} args - Arguments to find a WizardRun
     * @example
     * // Get one WizardRun
     * const wizardRun = await prisma.wizardRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WizardRunFindUniqueArgs>(args: SelectSubset<T, WizardRunFindUniqueArgs<ExtArgs>>): Prisma__WizardRunClient<$Result.GetResult<Prisma.$WizardRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WizardRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WizardRunFindUniqueOrThrowArgs} args - Arguments to find a WizardRun
     * @example
     * // Get one WizardRun
     * const wizardRun = await prisma.wizardRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WizardRunFindUniqueOrThrowArgs>(args: SelectSubset<T, WizardRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WizardRunClient<$Result.GetResult<Prisma.$WizardRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WizardRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WizardRunFindFirstArgs} args - Arguments to find a WizardRun
     * @example
     * // Get one WizardRun
     * const wizardRun = await prisma.wizardRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WizardRunFindFirstArgs>(args?: SelectSubset<T, WizardRunFindFirstArgs<ExtArgs>>): Prisma__WizardRunClient<$Result.GetResult<Prisma.$WizardRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WizardRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WizardRunFindFirstOrThrowArgs} args - Arguments to find a WizardRun
     * @example
     * // Get one WizardRun
     * const wizardRun = await prisma.wizardRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WizardRunFindFirstOrThrowArgs>(args?: SelectSubset<T, WizardRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__WizardRunClient<$Result.GetResult<Prisma.$WizardRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WizardRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WizardRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WizardRuns
     * const wizardRuns = await prisma.wizardRun.findMany()
     * 
     * // Get first 10 WizardRuns
     * const wizardRuns = await prisma.wizardRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wizardRunWithIdOnly = await prisma.wizardRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WizardRunFindManyArgs>(args?: SelectSubset<T, WizardRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WizardRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WizardRun.
     * @param {WizardRunCreateArgs} args - Arguments to create a WizardRun.
     * @example
     * // Create one WizardRun
     * const WizardRun = await prisma.wizardRun.create({
     *   data: {
     *     // ... data to create a WizardRun
     *   }
     * })
     * 
     */
    create<T extends WizardRunCreateArgs>(args: SelectSubset<T, WizardRunCreateArgs<ExtArgs>>): Prisma__WizardRunClient<$Result.GetResult<Prisma.$WizardRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WizardRuns.
     * @param {WizardRunCreateManyArgs} args - Arguments to create many WizardRuns.
     * @example
     * // Create many WizardRuns
     * const wizardRun = await prisma.wizardRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WizardRunCreateManyArgs>(args?: SelectSubset<T, WizardRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WizardRuns and returns the data saved in the database.
     * @param {WizardRunCreateManyAndReturnArgs} args - Arguments to create many WizardRuns.
     * @example
     * // Create many WizardRuns
     * const wizardRun = await prisma.wizardRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WizardRuns and only return the `id`
     * const wizardRunWithIdOnly = await prisma.wizardRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WizardRunCreateManyAndReturnArgs>(args?: SelectSubset<T, WizardRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WizardRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WizardRun.
     * @param {WizardRunDeleteArgs} args - Arguments to delete one WizardRun.
     * @example
     * // Delete one WizardRun
     * const WizardRun = await prisma.wizardRun.delete({
     *   where: {
     *     // ... filter to delete one WizardRun
     *   }
     * })
     * 
     */
    delete<T extends WizardRunDeleteArgs>(args: SelectSubset<T, WizardRunDeleteArgs<ExtArgs>>): Prisma__WizardRunClient<$Result.GetResult<Prisma.$WizardRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WizardRun.
     * @param {WizardRunUpdateArgs} args - Arguments to update one WizardRun.
     * @example
     * // Update one WizardRun
     * const wizardRun = await prisma.wizardRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WizardRunUpdateArgs>(args: SelectSubset<T, WizardRunUpdateArgs<ExtArgs>>): Prisma__WizardRunClient<$Result.GetResult<Prisma.$WizardRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WizardRuns.
     * @param {WizardRunDeleteManyArgs} args - Arguments to filter WizardRuns to delete.
     * @example
     * // Delete a few WizardRuns
     * const { count } = await prisma.wizardRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WizardRunDeleteManyArgs>(args?: SelectSubset<T, WizardRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WizardRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WizardRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WizardRuns
     * const wizardRun = await prisma.wizardRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WizardRunUpdateManyArgs>(args: SelectSubset<T, WizardRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WizardRuns and returns the data updated in the database.
     * @param {WizardRunUpdateManyAndReturnArgs} args - Arguments to update many WizardRuns.
     * @example
     * // Update many WizardRuns
     * const wizardRun = await prisma.wizardRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WizardRuns and only return the `id`
     * const wizardRunWithIdOnly = await prisma.wizardRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WizardRunUpdateManyAndReturnArgs>(args: SelectSubset<T, WizardRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WizardRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WizardRun.
     * @param {WizardRunUpsertArgs} args - Arguments to update or create a WizardRun.
     * @example
     * // Update or create a WizardRun
     * const wizardRun = await prisma.wizardRun.upsert({
     *   create: {
     *     // ... data to create a WizardRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WizardRun we want to update
     *   }
     * })
     */
    upsert<T extends WizardRunUpsertArgs>(args: SelectSubset<T, WizardRunUpsertArgs<ExtArgs>>): Prisma__WizardRunClient<$Result.GetResult<Prisma.$WizardRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WizardRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WizardRunCountArgs} args - Arguments to filter WizardRuns to count.
     * @example
     * // Count the number of WizardRuns
     * const count = await prisma.wizardRun.count({
     *   where: {
     *     // ... the filter for the WizardRuns we want to count
     *   }
     * })
    **/
    count<T extends WizardRunCountArgs>(
      args?: Subset<T, WizardRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WizardRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WizardRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WizardRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WizardRunAggregateArgs>(args: Subset<T, WizardRunAggregateArgs>): Prisma.PrismaPromise<GetWizardRunAggregateType<T>>

    /**
     * Group by WizardRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WizardRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WizardRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WizardRunGroupByArgs['orderBy'] }
        : { orderBy?: WizardRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WizardRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWizardRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WizardRun model
   */
  readonly fields: WizardRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WizardRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WizardRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stepStates<T extends WizardRun$stepStatesArgs<ExtArgs> = {}>(args?: Subset<T, WizardRun$stepStatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WizardStepStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WizardRun model
   */
  interface WizardRunFieldRefs {
    readonly id: FieldRef<"WizardRun", 'String'>
    readonly encounterId: FieldRef<"WizardRun", 'String'>
    readonly status: FieldRef<"WizardRun", 'WizardRunStatus'>
    readonly runState: FieldRef<"WizardRun", 'Json'>
    readonly startedAt: FieldRef<"WizardRun", 'DateTime'>
    readonly completedAt: FieldRef<"WizardRun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WizardRun findUnique
   */
  export type WizardRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardRun
     */
    select?: WizardRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardRun
     */
    omit?: WizardRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardRunInclude<ExtArgs> | null
    /**
     * Filter, which WizardRun to fetch.
     */
    where: WizardRunWhereUniqueInput
  }

  /**
   * WizardRun findUniqueOrThrow
   */
  export type WizardRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardRun
     */
    select?: WizardRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardRun
     */
    omit?: WizardRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardRunInclude<ExtArgs> | null
    /**
     * Filter, which WizardRun to fetch.
     */
    where: WizardRunWhereUniqueInput
  }

  /**
   * WizardRun findFirst
   */
  export type WizardRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardRun
     */
    select?: WizardRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardRun
     */
    omit?: WizardRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardRunInclude<ExtArgs> | null
    /**
     * Filter, which WizardRun to fetch.
     */
    where?: WizardRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WizardRuns to fetch.
     */
    orderBy?: WizardRunOrderByWithRelationInput | WizardRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WizardRuns.
     */
    cursor?: WizardRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WizardRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WizardRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WizardRuns.
     */
    distinct?: WizardRunScalarFieldEnum | WizardRunScalarFieldEnum[]
  }

  /**
   * WizardRun findFirstOrThrow
   */
  export type WizardRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardRun
     */
    select?: WizardRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardRun
     */
    omit?: WizardRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardRunInclude<ExtArgs> | null
    /**
     * Filter, which WizardRun to fetch.
     */
    where?: WizardRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WizardRuns to fetch.
     */
    orderBy?: WizardRunOrderByWithRelationInput | WizardRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WizardRuns.
     */
    cursor?: WizardRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WizardRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WizardRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WizardRuns.
     */
    distinct?: WizardRunScalarFieldEnum | WizardRunScalarFieldEnum[]
  }

  /**
   * WizardRun findMany
   */
  export type WizardRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardRun
     */
    select?: WizardRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardRun
     */
    omit?: WizardRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardRunInclude<ExtArgs> | null
    /**
     * Filter, which WizardRuns to fetch.
     */
    where?: WizardRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WizardRuns to fetch.
     */
    orderBy?: WizardRunOrderByWithRelationInput | WizardRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WizardRuns.
     */
    cursor?: WizardRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WizardRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WizardRuns.
     */
    skip?: number
    distinct?: WizardRunScalarFieldEnum | WizardRunScalarFieldEnum[]
  }

  /**
   * WizardRun create
   */
  export type WizardRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardRun
     */
    select?: WizardRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardRun
     */
    omit?: WizardRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardRunInclude<ExtArgs> | null
    /**
     * The data needed to create a WizardRun.
     */
    data: XOR<WizardRunCreateInput, WizardRunUncheckedCreateInput>
  }

  /**
   * WizardRun createMany
   */
  export type WizardRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WizardRuns.
     */
    data: WizardRunCreateManyInput | WizardRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WizardRun createManyAndReturn
   */
  export type WizardRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardRun
     */
    select?: WizardRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WizardRun
     */
    omit?: WizardRunOmit<ExtArgs> | null
    /**
     * The data used to create many WizardRuns.
     */
    data: WizardRunCreateManyInput | WizardRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WizardRun update
   */
  export type WizardRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardRun
     */
    select?: WizardRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardRun
     */
    omit?: WizardRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardRunInclude<ExtArgs> | null
    /**
     * The data needed to update a WizardRun.
     */
    data: XOR<WizardRunUpdateInput, WizardRunUncheckedUpdateInput>
    /**
     * Choose, which WizardRun to update.
     */
    where: WizardRunWhereUniqueInput
  }

  /**
   * WizardRun updateMany
   */
  export type WizardRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WizardRuns.
     */
    data: XOR<WizardRunUpdateManyMutationInput, WizardRunUncheckedUpdateManyInput>
    /**
     * Filter which WizardRuns to update
     */
    where?: WizardRunWhereInput
    /**
     * Limit how many WizardRuns to update.
     */
    limit?: number
  }

  /**
   * WizardRun updateManyAndReturn
   */
  export type WizardRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardRun
     */
    select?: WizardRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WizardRun
     */
    omit?: WizardRunOmit<ExtArgs> | null
    /**
     * The data used to update WizardRuns.
     */
    data: XOR<WizardRunUpdateManyMutationInput, WizardRunUncheckedUpdateManyInput>
    /**
     * Filter which WizardRuns to update
     */
    where?: WizardRunWhereInput
    /**
     * Limit how many WizardRuns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardRunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WizardRun upsert
   */
  export type WizardRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardRun
     */
    select?: WizardRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardRun
     */
    omit?: WizardRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardRunInclude<ExtArgs> | null
    /**
     * The filter to search for the WizardRun to update in case it exists.
     */
    where: WizardRunWhereUniqueInput
    /**
     * In case the WizardRun found by the `where` argument doesn't exist, create a new WizardRun with this data.
     */
    create: XOR<WizardRunCreateInput, WizardRunUncheckedCreateInput>
    /**
     * In case the WizardRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WizardRunUpdateInput, WizardRunUncheckedUpdateInput>
  }

  /**
   * WizardRun delete
   */
  export type WizardRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardRun
     */
    select?: WizardRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardRun
     */
    omit?: WizardRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardRunInclude<ExtArgs> | null
    /**
     * Filter which WizardRun to delete.
     */
    where: WizardRunWhereUniqueInput
  }

  /**
   * WizardRun deleteMany
   */
  export type WizardRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WizardRuns to delete
     */
    where?: WizardRunWhereInput
    /**
     * Limit how many WizardRuns to delete.
     */
    limit?: number
  }

  /**
   * WizardRun.stepStates
   */
  export type WizardRun$stepStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateInclude<ExtArgs> | null
    where?: WizardStepStateWhereInput
    orderBy?: WizardStepStateOrderByWithRelationInput | WizardStepStateOrderByWithRelationInput[]
    cursor?: WizardStepStateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WizardStepStateScalarFieldEnum | WizardStepStateScalarFieldEnum[]
  }

  /**
   * WizardRun without action
   */
  export type WizardRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardRun
     */
    select?: WizardRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardRun
     */
    omit?: WizardRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardRunInclude<ExtArgs> | null
  }


  /**
   * Model WizardStepState
   */

  export type AggregateWizardStepState = {
    _count: WizardStepStateCountAggregateOutputType | null
    _min: WizardStepStateMinAggregateOutputType | null
    _max: WizardStepStateMaxAggregateOutputType | null
  }

  export type WizardStepStateMinAggregateOutputType = {
    id: string | null
    wizardRunId: string | null
    encounterId: string | null
    step: $Enums.WizardStep | null
    status: $Enums.WizardStepStatus | null
    lastActorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WizardStepStateMaxAggregateOutputType = {
    id: string | null
    wizardRunId: string | null
    encounterId: string | null
    step: $Enums.WizardStep | null
    status: $Enums.WizardStepStatus | null
    lastActorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WizardStepStateCountAggregateOutputType = {
    id: number
    wizardRunId: number
    encounterId: number
    step: number
    status: number
    payload: number
    lastActorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WizardStepStateMinAggregateInputType = {
    id?: true
    wizardRunId?: true
    encounterId?: true
    step?: true
    status?: true
    lastActorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WizardStepStateMaxAggregateInputType = {
    id?: true
    wizardRunId?: true
    encounterId?: true
    step?: true
    status?: true
    lastActorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WizardStepStateCountAggregateInputType = {
    id?: true
    wizardRunId?: true
    encounterId?: true
    step?: true
    status?: true
    payload?: true
    lastActorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WizardStepStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WizardStepState to aggregate.
     */
    where?: WizardStepStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WizardStepStates to fetch.
     */
    orderBy?: WizardStepStateOrderByWithRelationInput | WizardStepStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WizardStepStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WizardStepStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WizardStepStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WizardStepStates
    **/
    _count?: true | WizardStepStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WizardStepStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WizardStepStateMaxAggregateInputType
  }

  export type GetWizardStepStateAggregateType<T extends WizardStepStateAggregateArgs> = {
        [P in keyof T & keyof AggregateWizardStepState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWizardStepState[P]>
      : GetScalarType<T[P], AggregateWizardStepState[P]>
  }




  export type WizardStepStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WizardStepStateWhereInput
    orderBy?: WizardStepStateOrderByWithAggregationInput | WizardStepStateOrderByWithAggregationInput[]
    by: WizardStepStateScalarFieldEnum[] | WizardStepStateScalarFieldEnum
    having?: WizardStepStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WizardStepStateCountAggregateInputType | true
    _min?: WizardStepStateMinAggregateInputType
    _max?: WizardStepStateMaxAggregateInputType
  }

  export type WizardStepStateGroupByOutputType = {
    id: string
    wizardRunId: string
    encounterId: string
    step: $Enums.WizardStep
    status: $Enums.WizardStepStatus
    payload: JsonValue | null
    lastActorId: string | null
    createdAt: Date
    updatedAt: Date
    _count: WizardStepStateCountAggregateOutputType | null
    _min: WizardStepStateMinAggregateOutputType | null
    _max: WizardStepStateMaxAggregateOutputType | null
  }

  type GetWizardStepStateGroupByPayload<T extends WizardStepStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WizardStepStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WizardStepStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WizardStepStateGroupByOutputType[P]>
            : GetScalarType<T[P], WizardStepStateGroupByOutputType[P]>
        }
      >
    >


  export type WizardStepStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wizardRunId?: boolean
    encounterId?: boolean
    step?: boolean
    status?: boolean
    payload?: boolean
    lastActorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wizardRun?: boolean | WizardRunDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    lastActor?: boolean | WizardStepState$lastActorArgs<ExtArgs>
  }, ExtArgs["result"]["wizardStepState"]>

  export type WizardStepStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wizardRunId?: boolean
    encounterId?: boolean
    step?: boolean
    status?: boolean
    payload?: boolean
    lastActorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wizardRun?: boolean | WizardRunDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    lastActor?: boolean | WizardStepState$lastActorArgs<ExtArgs>
  }, ExtArgs["result"]["wizardStepState"]>

  export type WizardStepStateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wizardRunId?: boolean
    encounterId?: boolean
    step?: boolean
    status?: boolean
    payload?: boolean
    lastActorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wizardRun?: boolean | WizardRunDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    lastActor?: boolean | WizardStepState$lastActorArgs<ExtArgs>
  }, ExtArgs["result"]["wizardStepState"]>

  export type WizardStepStateSelectScalar = {
    id?: boolean
    wizardRunId?: boolean
    encounterId?: boolean
    step?: boolean
    status?: boolean
    payload?: boolean
    lastActorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WizardStepStateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "wizardRunId" | "encounterId" | "step" | "status" | "payload" | "lastActorId" | "createdAt" | "updatedAt", ExtArgs["result"]["wizardStepState"]>
  export type WizardStepStateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wizardRun?: boolean | WizardRunDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    lastActor?: boolean | WizardStepState$lastActorArgs<ExtArgs>
  }
  export type WizardStepStateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wizardRun?: boolean | WizardRunDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    lastActor?: boolean | WizardStepState$lastActorArgs<ExtArgs>
  }
  export type WizardStepStateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wizardRun?: boolean | WizardRunDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    lastActor?: boolean | WizardStepState$lastActorArgs<ExtArgs>
  }

  export type $WizardStepStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WizardStepState"
    objects: {
      wizardRun: Prisma.$WizardRunPayload<ExtArgs>
      encounter: Prisma.$EncounterPayload<ExtArgs>
      lastActor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      wizardRunId: string
      encounterId: string
      step: $Enums.WizardStep
      status: $Enums.WizardStepStatus
      payload: Prisma.JsonValue | null
      lastActorId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wizardStepState"]>
    composites: {}
  }

  type WizardStepStateGetPayload<S extends boolean | null | undefined | WizardStepStateDefaultArgs> = $Result.GetResult<Prisma.$WizardStepStatePayload, S>

  type WizardStepStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WizardStepStateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WizardStepStateCountAggregateInputType | true
    }

  export interface WizardStepStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WizardStepState'], meta: { name: 'WizardStepState' } }
    /**
     * Find zero or one WizardStepState that matches the filter.
     * @param {WizardStepStateFindUniqueArgs} args - Arguments to find a WizardStepState
     * @example
     * // Get one WizardStepState
     * const wizardStepState = await prisma.wizardStepState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WizardStepStateFindUniqueArgs>(args: SelectSubset<T, WizardStepStateFindUniqueArgs<ExtArgs>>): Prisma__WizardStepStateClient<$Result.GetResult<Prisma.$WizardStepStatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WizardStepState that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WizardStepStateFindUniqueOrThrowArgs} args - Arguments to find a WizardStepState
     * @example
     * // Get one WizardStepState
     * const wizardStepState = await prisma.wizardStepState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WizardStepStateFindUniqueOrThrowArgs>(args: SelectSubset<T, WizardStepStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WizardStepStateClient<$Result.GetResult<Prisma.$WizardStepStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WizardStepState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WizardStepStateFindFirstArgs} args - Arguments to find a WizardStepState
     * @example
     * // Get one WizardStepState
     * const wizardStepState = await prisma.wizardStepState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WizardStepStateFindFirstArgs>(args?: SelectSubset<T, WizardStepStateFindFirstArgs<ExtArgs>>): Prisma__WizardStepStateClient<$Result.GetResult<Prisma.$WizardStepStatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WizardStepState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WizardStepStateFindFirstOrThrowArgs} args - Arguments to find a WizardStepState
     * @example
     * // Get one WizardStepState
     * const wizardStepState = await prisma.wizardStepState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WizardStepStateFindFirstOrThrowArgs>(args?: SelectSubset<T, WizardStepStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__WizardStepStateClient<$Result.GetResult<Prisma.$WizardStepStatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WizardStepStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WizardStepStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WizardStepStates
     * const wizardStepStates = await prisma.wizardStepState.findMany()
     * 
     * // Get first 10 WizardStepStates
     * const wizardStepStates = await prisma.wizardStepState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wizardStepStateWithIdOnly = await prisma.wizardStepState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WizardStepStateFindManyArgs>(args?: SelectSubset<T, WizardStepStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WizardStepStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WizardStepState.
     * @param {WizardStepStateCreateArgs} args - Arguments to create a WizardStepState.
     * @example
     * // Create one WizardStepState
     * const WizardStepState = await prisma.wizardStepState.create({
     *   data: {
     *     // ... data to create a WizardStepState
     *   }
     * })
     * 
     */
    create<T extends WizardStepStateCreateArgs>(args: SelectSubset<T, WizardStepStateCreateArgs<ExtArgs>>): Prisma__WizardStepStateClient<$Result.GetResult<Prisma.$WizardStepStatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WizardStepStates.
     * @param {WizardStepStateCreateManyArgs} args - Arguments to create many WizardStepStates.
     * @example
     * // Create many WizardStepStates
     * const wizardStepState = await prisma.wizardStepState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WizardStepStateCreateManyArgs>(args?: SelectSubset<T, WizardStepStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WizardStepStates and returns the data saved in the database.
     * @param {WizardStepStateCreateManyAndReturnArgs} args - Arguments to create many WizardStepStates.
     * @example
     * // Create many WizardStepStates
     * const wizardStepState = await prisma.wizardStepState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WizardStepStates and only return the `id`
     * const wizardStepStateWithIdOnly = await prisma.wizardStepState.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WizardStepStateCreateManyAndReturnArgs>(args?: SelectSubset<T, WizardStepStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WizardStepStatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WizardStepState.
     * @param {WizardStepStateDeleteArgs} args - Arguments to delete one WizardStepState.
     * @example
     * // Delete one WizardStepState
     * const WizardStepState = await prisma.wizardStepState.delete({
     *   where: {
     *     // ... filter to delete one WizardStepState
     *   }
     * })
     * 
     */
    delete<T extends WizardStepStateDeleteArgs>(args: SelectSubset<T, WizardStepStateDeleteArgs<ExtArgs>>): Prisma__WizardStepStateClient<$Result.GetResult<Prisma.$WizardStepStatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WizardStepState.
     * @param {WizardStepStateUpdateArgs} args - Arguments to update one WizardStepState.
     * @example
     * // Update one WizardStepState
     * const wizardStepState = await prisma.wizardStepState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WizardStepStateUpdateArgs>(args: SelectSubset<T, WizardStepStateUpdateArgs<ExtArgs>>): Prisma__WizardStepStateClient<$Result.GetResult<Prisma.$WizardStepStatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WizardStepStates.
     * @param {WizardStepStateDeleteManyArgs} args - Arguments to filter WizardStepStates to delete.
     * @example
     * // Delete a few WizardStepStates
     * const { count } = await prisma.wizardStepState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WizardStepStateDeleteManyArgs>(args?: SelectSubset<T, WizardStepStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WizardStepStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WizardStepStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WizardStepStates
     * const wizardStepState = await prisma.wizardStepState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WizardStepStateUpdateManyArgs>(args: SelectSubset<T, WizardStepStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WizardStepStates and returns the data updated in the database.
     * @param {WizardStepStateUpdateManyAndReturnArgs} args - Arguments to update many WizardStepStates.
     * @example
     * // Update many WizardStepStates
     * const wizardStepState = await prisma.wizardStepState.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WizardStepStates and only return the `id`
     * const wizardStepStateWithIdOnly = await prisma.wizardStepState.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WizardStepStateUpdateManyAndReturnArgs>(args: SelectSubset<T, WizardStepStateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WizardStepStatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WizardStepState.
     * @param {WizardStepStateUpsertArgs} args - Arguments to update or create a WizardStepState.
     * @example
     * // Update or create a WizardStepState
     * const wizardStepState = await prisma.wizardStepState.upsert({
     *   create: {
     *     // ... data to create a WizardStepState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WizardStepState we want to update
     *   }
     * })
     */
    upsert<T extends WizardStepStateUpsertArgs>(args: SelectSubset<T, WizardStepStateUpsertArgs<ExtArgs>>): Prisma__WizardStepStateClient<$Result.GetResult<Prisma.$WizardStepStatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WizardStepStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WizardStepStateCountArgs} args - Arguments to filter WizardStepStates to count.
     * @example
     * // Count the number of WizardStepStates
     * const count = await prisma.wizardStepState.count({
     *   where: {
     *     // ... the filter for the WizardStepStates we want to count
     *   }
     * })
    **/
    count<T extends WizardStepStateCountArgs>(
      args?: Subset<T, WizardStepStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WizardStepStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WizardStepState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WizardStepStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WizardStepStateAggregateArgs>(args: Subset<T, WizardStepStateAggregateArgs>): Prisma.PrismaPromise<GetWizardStepStateAggregateType<T>>

    /**
     * Group by WizardStepState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WizardStepStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WizardStepStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WizardStepStateGroupByArgs['orderBy'] }
        : { orderBy?: WizardStepStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WizardStepStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWizardStepStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WizardStepState model
   */
  readonly fields: WizardStepStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WizardStepState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WizardStepStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wizardRun<T extends WizardRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WizardRunDefaultArgs<ExtArgs>>): Prisma__WizardRunClient<$Result.GetResult<Prisma.$WizardRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lastActor<T extends WizardStepState$lastActorArgs<ExtArgs> = {}>(args?: Subset<T, WizardStepState$lastActorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WizardStepState model
   */
  interface WizardStepStateFieldRefs {
    readonly id: FieldRef<"WizardStepState", 'String'>
    readonly wizardRunId: FieldRef<"WizardStepState", 'String'>
    readonly encounterId: FieldRef<"WizardStepState", 'String'>
    readonly step: FieldRef<"WizardStepState", 'WizardStep'>
    readonly status: FieldRef<"WizardStepState", 'WizardStepStatus'>
    readonly payload: FieldRef<"WizardStepState", 'Json'>
    readonly lastActorId: FieldRef<"WizardStepState", 'String'>
    readonly createdAt: FieldRef<"WizardStepState", 'DateTime'>
    readonly updatedAt: FieldRef<"WizardStepState", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WizardStepState findUnique
   */
  export type WizardStepStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateInclude<ExtArgs> | null
    /**
     * Filter, which WizardStepState to fetch.
     */
    where: WizardStepStateWhereUniqueInput
  }

  /**
   * WizardStepState findUniqueOrThrow
   */
  export type WizardStepStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateInclude<ExtArgs> | null
    /**
     * Filter, which WizardStepState to fetch.
     */
    where: WizardStepStateWhereUniqueInput
  }

  /**
   * WizardStepState findFirst
   */
  export type WizardStepStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateInclude<ExtArgs> | null
    /**
     * Filter, which WizardStepState to fetch.
     */
    where?: WizardStepStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WizardStepStates to fetch.
     */
    orderBy?: WizardStepStateOrderByWithRelationInput | WizardStepStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WizardStepStates.
     */
    cursor?: WizardStepStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WizardStepStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WizardStepStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WizardStepStates.
     */
    distinct?: WizardStepStateScalarFieldEnum | WizardStepStateScalarFieldEnum[]
  }

  /**
   * WizardStepState findFirstOrThrow
   */
  export type WizardStepStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateInclude<ExtArgs> | null
    /**
     * Filter, which WizardStepState to fetch.
     */
    where?: WizardStepStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WizardStepStates to fetch.
     */
    orderBy?: WizardStepStateOrderByWithRelationInput | WizardStepStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WizardStepStates.
     */
    cursor?: WizardStepStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WizardStepStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WizardStepStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WizardStepStates.
     */
    distinct?: WizardStepStateScalarFieldEnum | WizardStepStateScalarFieldEnum[]
  }

  /**
   * WizardStepState findMany
   */
  export type WizardStepStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateInclude<ExtArgs> | null
    /**
     * Filter, which WizardStepStates to fetch.
     */
    where?: WizardStepStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WizardStepStates to fetch.
     */
    orderBy?: WizardStepStateOrderByWithRelationInput | WizardStepStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WizardStepStates.
     */
    cursor?: WizardStepStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WizardStepStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WizardStepStates.
     */
    skip?: number
    distinct?: WizardStepStateScalarFieldEnum | WizardStepStateScalarFieldEnum[]
  }

  /**
   * WizardStepState create
   */
  export type WizardStepStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateInclude<ExtArgs> | null
    /**
     * The data needed to create a WizardStepState.
     */
    data: XOR<WizardStepStateCreateInput, WizardStepStateUncheckedCreateInput>
  }

  /**
   * WizardStepState createMany
   */
  export type WizardStepStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WizardStepStates.
     */
    data: WizardStepStateCreateManyInput | WizardStepStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WizardStepState createManyAndReturn
   */
  export type WizardStepStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * The data used to create many WizardStepStates.
     */
    data: WizardStepStateCreateManyInput | WizardStepStateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WizardStepState update
   */
  export type WizardStepStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateInclude<ExtArgs> | null
    /**
     * The data needed to update a WizardStepState.
     */
    data: XOR<WizardStepStateUpdateInput, WizardStepStateUncheckedUpdateInput>
    /**
     * Choose, which WizardStepState to update.
     */
    where: WizardStepStateWhereUniqueInput
  }

  /**
   * WizardStepState updateMany
   */
  export type WizardStepStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WizardStepStates.
     */
    data: XOR<WizardStepStateUpdateManyMutationInput, WizardStepStateUncheckedUpdateManyInput>
    /**
     * Filter which WizardStepStates to update
     */
    where?: WizardStepStateWhereInput
    /**
     * Limit how many WizardStepStates to update.
     */
    limit?: number
  }

  /**
   * WizardStepState updateManyAndReturn
   */
  export type WizardStepStateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * The data used to update WizardStepStates.
     */
    data: XOR<WizardStepStateUpdateManyMutationInput, WizardStepStateUncheckedUpdateManyInput>
    /**
     * Filter which WizardStepStates to update
     */
    where?: WizardStepStateWhereInput
    /**
     * Limit how many WizardStepStates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WizardStepState upsert
   */
  export type WizardStepStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateInclude<ExtArgs> | null
    /**
     * The filter to search for the WizardStepState to update in case it exists.
     */
    where: WizardStepStateWhereUniqueInput
    /**
     * In case the WizardStepState found by the `where` argument doesn't exist, create a new WizardStepState with this data.
     */
    create: XOR<WizardStepStateCreateInput, WizardStepStateUncheckedCreateInput>
    /**
     * In case the WizardStepState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WizardStepStateUpdateInput, WizardStepStateUncheckedUpdateInput>
  }

  /**
   * WizardStepState delete
   */
  export type WizardStepStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateInclude<ExtArgs> | null
    /**
     * Filter which WizardStepState to delete.
     */
    where: WizardStepStateWhereUniqueInput
  }

  /**
   * WizardStepState deleteMany
   */
  export type WizardStepStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WizardStepStates to delete
     */
    where?: WizardStepStateWhereInput
    /**
     * Limit how many WizardStepStates to delete.
     */
    limit?: number
  }

  /**
   * WizardStepState.lastActor
   */
  export type WizardStepState$lastActorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WizardStepState without action
   */
  export type WizardStepStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WizardStepState
     */
    select?: WizardStepStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WizardStepState
     */
    omit?: WizardStepStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WizardStepStateInclude<ExtArgs> | null
  }


  /**
   * Model ExportArtifact
   */

  export type AggregateExportArtifact = {
    _count: ExportArtifactCountAggregateOutputType | null
    _avg: ExportArtifactAvgAggregateOutputType | null
    _sum: ExportArtifactSumAggregateOutputType | null
    _min: ExportArtifactMinAggregateOutputType | null
    _max: ExportArtifactMaxAggregateOutputType | null
  }

  export type ExportArtifactAvgAggregateOutputType = {
    sizeBytes: number | null
  }

  export type ExportArtifactSumAggregateOutputType = {
    sizeBytes: number | null
  }

  export type ExportArtifactMinAggregateOutputType = {
    id: string | null
    encounterId: string | null
    noteId: string | null
    type: $Enums.ArtifactType | null
    filePath: string | null
    mimeType: string | null
    fileName: string | null
    sizeBytes: number | null
    createdById: string | null
    createdAt: Date | null
  }

  export type ExportArtifactMaxAggregateOutputType = {
    id: string | null
    encounterId: string | null
    noteId: string | null
    type: $Enums.ArtifactType | null
    filePath: string | null
    mimeType: string | null
    fileName: string | null
    sizeBytes: number | null
    createdById: string | null
    createdAt: Date | null
  }

  export type ExportArtifactCountAggregateOutputType = {
    id: number
    encounterId: number
    noteId: number
    type: number
    filePath: number
    mimeType: number
    fileName: number
    sizeBytes: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type ExportArtifactAvgAggregateInputType = {
    sizeBytes?: true
  }

  export type ExportArtifactSumAggregateInputType = {
    sizeBytes?: true
  }

  export type ExportArtifactMinAggregateInputType = {
    id?: true
    encounterId?: true
    noteId?: true
    type?: true
    filePath?: true
    mimeType?: true
    fileName?: true
    sizeBytes?: true
    createdById?: true
    createdAt?: true
  }

  export type ExportArtifactMaxAggregateInputType = {
    id?: true
    encounterId?: true
    noteId?: true
    type?: true
    filePath?: true
    mimeType?: true
    fileName?: true
    sizeBytes?: true
    createdById?: true
    createdAt?: true
  }

  export type ExportArtifactCountAggregateInputType = {
    id?: true
    encounterId?: true
    noteId?: true
    type?: true
    filePath?: true
    mimeType?: true
    fileName?: true
    sizeBytes?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type ExportArtifactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportArtifact to aggregate.
     */
    where?: ExportArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportArtifacts to fetch.
     */
    orderBy?: ExportArtifactOrderByWithRelationInput | ExportArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExportArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExportArtifacts
    **/
    _count?: true | ExportArtifactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExportArtifactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExportArtifactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExportArtifactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExportArtifactMaxAggregateInputType
  }

  export type GetExportArtifactAggregateType<T extends ExportArtifactAggregateArgs> = {
        [P in keyof T & keyof AggregateExportArtifact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExportArtifact[P]>
      : GetScalarType<T[P], AggregateExportArtifact[P]>
  }




  export type ExportArtifactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportArtifactWhereInput
    orderBy?: ExportArtifactOrderByWithAggregationInput | ExportArtifactOrderByWithAggregationInput[]
    by: ExportArtifactScalarFieldEnum[] | ExportArtifactScalarFieldEnum
    having?: ExportArtifactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExportArtifactCountAggregateInputType | true
    _avg?: ExportArtifactAvgAggregateInputType
    _sum?: ExportArtifactSumAggregateInputType
    _min?: ExportArtifactMinAggregateInputType
    _max?: ExportArtifactMaxAggregateInputType
  }

  export type ExportArtifactGroupByOutputType = {
    id: string
    encounterId: string
    noteId: string | null
    type: $Enums.ArtifactType
    filePath: string
    mimeType: string
    fileName: string
    sizeBytes: number
    createdById: string | null
    createdAt: Date
    _count: ExportArtifactCountAggregateOutputType | null
    _avg: ExportArtifactAvgAggregateOutputType | null
    _sum: ExportArtifactSumAggregateOutputType | null
    _min: ExportArtifactMinAggregateOutputType | null
    _max: ExportArtifactMaxAggregateOutputType | null
  }

  type GetExportArtifactGroupByPayload<T extends ExportArtifactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExportArtifactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExportArtifactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExportArtifactGroupByOutputType[P]>
            : GetScalarType<T[P], ExportArtifactGroupByOutputType[P]>
        }
      >
    >


  export type ExportArtifactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    noteId?: boolean
    type?: boolean
    filePath?: boolean
    mimeType?: boolean
    fileName?: boolean
    sizeBytes?: boolean
    createdById?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    note?: boolean | ExportArtifact$noteArgs<ExtArgs>
    createdBy?: boolean | ExportArtifact$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["exportArtifact"]>

  export type ExportArtifactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    noteId?: boolean
    type?: boolean
    filePath?: boolean
    mimeType?: boolean
    fileName?: boolean
    sizeBytes?: boolean
    createdById?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    note?: boolean | ExportArtifact$noteArgs<ExtArgs>
    createdBy?: boolean | ExportArtifact$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["exportArtifact"]>

  export type ExportArtifactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    noteId?: boolean
    type?: boolean
    filePath?: boolean
    mimeType?: boolean
    fileName?: boolean
    sizeBytes?: boolean
    createdById?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    note?: boolean | ExportArtifact$noteArgs<ExtArgs>
    createdBy?: boolean | ExportArtifact$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["exportArtifact"]>

  export type ExportArtifactSelectScalar = {
    id?: boolean
    encounterId?: boolean
    noteId?: boolean
    type?: boolean
    filePath?: boolean
    mimeType?: boolean
    fileName?: boolean
    sizeBytes?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type ExportArtifactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "encounterId" | "noteId" | "type" | "filePath" | "mimeType" | "fileName" | "sizeBytes" | "createdById" | "createdAt", ExtArgs["result"]["exportArtifact"]>
  export type ExportArtifactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    note?: boolean | ExportArtifact$noteArgs<ExtArgs>
    createdBy?: boolean | ExportArtifact$createdByArgs<ExtArgs>
  }
  export type ExportArtifactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    note?: boolean | ExportArtifact$noteArgs<ExtArgs>
    createdBy?: boolean | ExportArtifact$createdByArgs<ExtArgs>
  }
  export type ExportArtifactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    note?: boolean | ExportArtifact$noteArgs<ExtArgs>
    createdBy?: boolean | ExportArtifact$createdByArgs<ExtArgs>
  }

  export type $ExportArtifactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExportArtifact"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      note: Prisma.$NotePayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      encounterId: string
      noteId: string | null
      type: $Enums.ArtifactType
      filePath: string
      mimeType: string
      fileName: string
      sizeBytes: number
      createdById: string | null
      createdAt: Date
    }, ExtArgs["result"]["exportArtifact"]>
    composites: {}
  }

  type ExportArtifactGetPayload<S extends boolean | null | undefined | ExportArtifactDefaultArgs> = $Result.GetResult<Prisma.$ExportArtifactPayload, S>

  type ExportArtifactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExportArtifactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExportArtifactCountAggregateInputType | true
    }

  export interface ExportArtifactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExportArtifact'], meta: { name: 'ExportArtifact' } }
    /**
     * Find zero or one ExportArtifact that matches the filter.
     * @param {ExportArtifactFindUniqueArgs} args - Arguments to find a ExportArtifact
     * @example
     * // Get one ExportArtifact
     * const exportArtifact = await prisma.exportArtifact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExportArtifactFindUniqueArgs>(args: SelectSubset<T, ExportArtifactFindUniqueArgs<ExtArgs>>): Prisma__ExportArtifactClient<$Result.GetResult<Prisma.$ExportArtifactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExportArtifact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExportArtifactFindUniqueOrThrowArgs} args - Arguments to find a ExportArtifact
     * @example
     * // Get one ExportArtifact
     * const exportArtifact = await prisma.exportArtifact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExportArtifactFindUniqueOrThrowArgs>(args: SelectSubset<T, ExportArtifactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExportArtifactClient<$Result.GetResult<Prisma.$ExportArtifactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExportArtifact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportArtifactFindFirstArgs} args - Arguments to find a ExportArtifact
     * @example
     * // Get one ExportArtifact
     * const exportArtifact = await prisma.exportArtifact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExportArtifactFindFirstArgs>(args?: SelectSubset<T, ExportArtifactFindFirstArgs<ExtArgs>>): Prisma__ExportArtifactClient<$Result.GetResult<Prisma.$ExportArtifactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExportArtifact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportArtifactFindFirstOrThrowArgs} args - Arguments to find a ExportArtifact
     * @example
     * // Get one ExportArtifact
     * const exportArtifact = await prisma.exportArtifact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExportArtifactFindFirstOrThrowArgs>(args?: SelectSubset<T, ExportArtifactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExportArtifactClient<$Result.GetResult<Prisma.$ExportArtifactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExportArtifacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportArtifactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExportArtifacts
     * const exportArtifacts = await prisma.exportArtifact.findMany()
     * 
     * // Get first 10 ExportArtifacts
     * const exportArtifacts = await prisma.exportArtifact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exportArtifactWithIdOnly = await prisma.exportArtifact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExportArtifactFindManyArgs>(args?: SelectSubset<T, ExportArtifactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExportArtifact.
     * @param {ExportArtifactCreateArgs} args - Arguments to create a ExportArtifact.
     * @example
     * // Create one ExportArtifact
     * const ExportArtifact = await prisma.exportArtifact.create({
     *   data: {
     *     // ... data to create a ExportArtifact
     *   }
     * })
     * 
     */
    create<T extends ExportArtifactCreateArgs>(args: SelectSubset<T, ExportArtifactCreateArgs<ExtArgs>>): Prisma__ExportArtifactClient<$Result.GetResult<Prisma.$ExportArtifactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExportArtifacts.
     * @param {ExportArtifactCreateManyArgs} args - Arguments to create many ExportArtifacts.
     * @example
     * // Create many ExportArtifacts
     * const exportArtifact = await prisma.exportArtifact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExportArtifactCreateManyArgs>(args?: SelectSubset<T, ExportArtifactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExportArtifacts and returns the data saved in the database.
     * @param {ExportArtifactCreateManyAndReturnArgs} args - Arguments to create many ExportArtifacts.
     * @example
     * // Create many ExportArtifacts
     * const exportArtifact = await prisma.exportArtifact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExportArtifacts and only return the `id`
     * const exportArtifactWithIdOnly = await prisma.exportArtifact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExportArtifactCreateManyAndReturnArgs>(args?: SelectSubset<T, ExportArtifactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportArtifactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExportArtifact.
     * @param {ExportArtifactDeleteArgs} args - Arguments to delete one ExportArtifact.
     * @example
     * // Delete one ExportArtifact
     * const ExportArtifact = await prisma.exportArtifact.delete({
     *   where: {
     *     // ... filter to delete one ExportArtifact
     *   }
     * })
     * 
     */
    delete<T extends ExportArtifactDeleteArgs>(args: SelectSubset<T, ExportArtifactDeleteArgs<ExtArgs>>): Prisma__ExportArtifactClient<$Result.GetResult<Prisma.$ExportArtifactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExportArtifact.
     * @param {ExportArtifactUpdateArgs} args - Arguments to update one ExportArtifact.
     * @example
     * // Update one ExportArtifact
     * const exportArtifact = await prisma.exportArtifact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExportArtifactUpdateArgs>(args: SelectSubset<T, ExportArtifactUpdateArgs<ExtArgs>>): Prisma__ExportArtifactClient<$Result.GetResult<Prisma.$ExportArtifactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExportArtifacts.
     * @param {ExportArtifactDeleteManyArgs} args - Arguments to filter ExportArtifacts to delete.
     * @example
     * // Delete a few ExportArtifacts
     * const { count } = await prisma.exportArtifact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExportArtifactDeleteManyArgs>(args?: SelectSubset<T, ExportArtifactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExportArtifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportArtifactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExportArtifacts
     * const exportArtifact = await prisma.exportArtifact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExportArtifactUpdateManyArgs>(args: SelectSubset<T, ExportArtifactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExportArtifacts and returns the data updated in the database.
     * @param {ExportArtifactUpdateManyAndReturnArgs} args - Arguments to update many ExportArtifacts.
     * @example
     * // Update many ExportArtifacts
     * const exportArtifact = await prisma.exportArtifact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExportArtifacts and only return the `id`
     * const exportArtifactWithIdOnly = await prisma.exportArtifact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExportArtifactUpdateManyAndReturnArgs>(args: SelectSubset<T, ExportArtifactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportArtifactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExportArtifact.
     * @param {ExportArtifactUpsertArgs} args - Arguments to update or create a ExportArtifact.
     * @example
     * // Update or create a ExportArtifact
     * const exportArtifact = await prisma.exportArtifact.upsert({
     *   create: {
     *     // ... data to create a ExportArtifact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExportArtifact we want to update
     *   }
     * })
     */
    upsert<T extends ExportArtifactUpsertArgs>(args: SelectSubset<T, ExportArtifactUpsertArgs<ExtArgs>>): Prisma__ExportArtifactClient<$Result.GetResult<Prisma.$ExportArtifactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExportArtifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportArtifactCountArgs} args - Arguments to filter ExportArtifacts to count.
     * @example
     * // Count the number of ExportArtifacts
     * const count = await prisma.exportArtifact.count({
     *   where: {
     *     // ... the filter for the ExportArtifacts we want to count
     *   }
     * })
    **/
    count<T extends ExportArtifactCountArgs>(
      args?: Subset<T, ExportArtifactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExportArtifactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExportArtifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportArtifactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExportArtifactAggregateArgs>(args: Subset<T, ExportArtifactAggregateArgs>): Prisma.PrismaPromise<GetExportArtifactAggregateType<T>>

    /**
     * Group by ExportArtifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportArtifactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExportArtifactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExportArtifactGroupByArgs['orderBy'] }
        : { orderBy?: ExportArtifactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExportArtifactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExportArtifactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExportArtifact model
   */
  readonly fields: ExportArtifactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExportArtifact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExportArtifactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    note<T extends ExportArtifact$noteArgs<ExtArgs> = {}>(args?: Subset<T, ExportArtifact$noteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends ExportArtifact$createdByArgs<ExtArgs> = {}>(args?: Subset<T, ExportArtifact$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExportArtifact model
   */
  interface ExportArtifactFieldRefs {
    readonly id: FieldRef<"ExportArtifact", 'String'>
    readonly encounterId: FieldRef<"ExportArtifact", 'String'>
    readonly noteId: FieldRef<"ExportArtifact", 'String'>
    readonly type: FieldRef<"ExportArtifact", 'ArtifactType'>
    readonly filePath: FieldRef<"ExportArtifact", 'String'>
    readonly mimeType: FieldRef<"ExportArtifact", 'String'>
    readonly fileName: FieldRef<"ExportArtifact", 'String'>
    readonly sizeBytes: FieldRef<"ExportArtifact", 'Int'>
    readonly createdById: FieldRef<"ExportArtifact", 'String'>
    readonly createdAt: FieldRef<"ExportArtifact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExportArtifact findUnique
   */
  export type ExportArtifactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ExportArtifact to fetch.
     */
    where: ExportArtifactWhereUniqueInput
  }

  /**
   * ExportArtifact findUniqueOrThrow
   */
  export type ExportArtifactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ExportArtifact to fetch.
     */
    where: ExportArtifactWhereUniqueInput
  }

  /**
   * ExportArtifact findFirst
   */
  export type ExportArtifactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ExportArtifact to fetch.
     */
    where?: ExportArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportArtifacts to fetch.
     */
    orderBy?: ExportArtifactOrderByWithRelationInput | ExportArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportArtifacts.
     */
    cursor?: ExportArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportArtifacts.
     */
    distinct?: ExportArtifactScalarFieldEnum | ExportArtifactScalarFieldEnum[]
  }

  /**
   * ExportArtifact findFirstOrThrow
   */
  export type ExportArtifactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ExportArtifact to fetch.
     */
    where?: ExportArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportArtifacts to fetch.
     */
    orderBy?: ExportArtifactOrderByWithRelationInput | ExportArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportArtifacts.
     */
    cursor?: ExportArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportArtifacts.
     */
    distinct?: ExportArtifactScalarFieldEnum | ExportArtifactScalarFieldEnum[]
  }

  /**
   * ExportArtifact findMany
   */
  export type ExportArtifactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ExportArtifacts to fetch.
     */
    where?: ExportArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportArtifacts to fetch.
     */
    orderBy?: ExportArtifactOrderByWithRelationInput | ExportArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExportArtifacts.
     */
    cursor?: ExportArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportArtifacts.
     */
    skip?: number
    distinct?: ExportArtifactScalarFieldEnum | ExportArtifactScalarFieldEnum[]
  }

  /**
   * ExportArtifact create
   */
  export type ExportArtifactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactInclude<ExtArgs> | null
    /**
     * The data needed to create a ExportArtifact.
     */
    data: XOR<ExportArtifactCreateInput, ExportArtifactUncheckedCreateInput>
  }

  /**
   * ExportArtifact createMany
   */
  export type ExportArtifactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExportArtifacts.
     */
    data: ExportArtifactCreateManyInput | ExportArtifactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExportArtifact createManyAndReturn
   */
  export type ExportArtifactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * The data used to create many ExportArtifacts.
     */
    data: ExportArtifactCreateManyInput | ExportArtifactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExportArtifact update
   */
  export type ExportArtifactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactInclude<ExtArgs> | null
    /**
     * The data needed to update a ExportArtifact.
     */
    data: XOR<ExportArtifactUpdateInput, ExportArtifactUncheckedUpdateInput>
    /**
     * Choose, which ExportArtifact to update.
     */
    where: ExportArtifactWhereUniqueInput
  }

  /**
   * ExportArtifact updateMany
   */
  export type ExportArtifactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExportArtifacts.
     */
    data: XOR<ExportArtifactUpdateManyMutationInput, ExportArtifactUncheckedUpdateManyInput>
    /**
     * Filter which ExportArtifacts to update
     */
    where?: ExportArtifactWhereInput
    /**
     * Limit how many ExportArtifacts to update.
     */
    limit?: number
  }

  /**
   * ExportArtifact updateManyAndReturn
   */
  export type ExportArtifactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * The data used to update ExportArtifacts.
     */
    data: XOR<ExportArtifactUpdateManyMutationInput, ExportArtifactUncheckedUpdateManyInput>
    /**
     * Filter which ExportArtifacts to update
     */
    where?: ExportArtifactWhereInput
    /**
     * Limit how many ExportArtifacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExportArtifact upsert
   */
  export type ExportArtifactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactInclude<ExtArgs> | null
    /**
     * The filter to search for the ExportArtifact to update in case it exists.
     */
    where: ExportArtifactWhereUniqueInput
    /**
     * In case the ExportArtifact found by the `where` argument doesn't exist, create a new ExportArtifact with this data.
     */
    create: XOR<ExportArtifactCreateInput, ExportArtifactUncheckedCreateInput>
    /**
     * In case the ExportArtifact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExportArtifactUpdateInput, ExportArtifactUncheckedUpdateInput>
  }

  /**
   * ExportArtifact delete
   */
  export type ExportArtifactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactInclude<ExtArgs> | null
    /**
     * Filter which ExportArtifact to delete.
     */
    where: ExportArtifactWhereUniqueInput
  }

  /**
   * ExportArtifact deleteMany
   */
  export type ExportArtifactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportArtifacts to delete
     */
    where?: ExportArtifactWhereInput
    /**
     * Limit how many ExportArtifacts to delete.
     */
    limit?: number
  }

  /**
   * ExportArtifact.note
   */
  export type ExportArtifact$noteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
  }

  /**
   * ExportArtifact.createdBy
   */
  export type ExportArtifact$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ExportArtifact without action
   */
  export type ExportArtifactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportArtifact
     */
    select?: ExportArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportArtifact
     */
    omit?: ExportArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportArtifactInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    actorId: string | null
    encounterId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    actorId: string | null
    encounterId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorId: number
    encounterId: number
    action: number
    entity: number
    entityId: number
    ip: number
    userAgent: number
    details: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    actorId?: true
    encounterId?: true
    action?: true
    entity?: true
    entityId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorId?: true
    encounterId?: true
    action?: true
    entity?: true
    entityId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorId?: true
    encounterId?: true
    action?: true
    entity?: true
    entityId?: true
    ip?: true
    userAgent?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    actorId: string | null
    encounterId: string | null
    action: string
    entity: string
    entityId: string
    ip: string | null
    userAgent: string | null
    details: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    encounterId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ip?: boolean
    userAgent?: boolean
    details?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
    encounter?: boolean | AuditLog$encounterArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    encounterId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ip?: boolean
    userAgent?: boolean
    details?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
    encounter?: boolean | AuditLog$encounterArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    encounterId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ip?: boolean
    userAgent?: boolean
    details?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
    encounter?: boolean | AuditLog$encounterArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    actorId?: boolean
    encounterId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ip?: boolean
    userAgent?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actorId" | "encounterId" | "action" | "entity" | "entityId" | "ip" | "userAgent" | "details" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
    encounter?: boolean | AuditLog$encounterArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
    encounter?: boolean | AuditLog$encounterArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
    encounter?: boolean | AuditLog$encounterArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs> | null
      encounter: Prisma.$EncounterPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorId: string | null
      encounterId: string | null
      action: string
      entity: string
      entityId: string
      ip: string | null
      userAgent: string | null
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends AuditLog$actorArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    encounter<T extends AuditLog$encounterArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$encounterArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly actorId: FieldRef<"AuditLog", 'String'>
    readonly encounterId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly ip: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.actor
   */
  export type AuditLog$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog.encounter
   */
  export type AuditLog$encounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model AuthSession
   */

  export type AggregateAuthSession = {
    _count: AuthSessionCountAggregateOutputType | null
    _min: AuthSessionMinAggregateOutputType | null
    _max: AuthSessionMaxAggregateOutputType | null
  }

  export type AuthSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshTokenHash: string | null
    expiresAt: Date | null
    revokedAt: Date | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshTokenHash: string | null
    expiresAt: Date | null
    revokedAt: Date | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthSessionCountAggregateOutputType = {
    id: number
    userId: number
    refreshTokenHash: number
    expiresAt: number
    revokedAt: number
    ip: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuthSessionMinAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenHash?: true
    expiresAt?: true
    revokedAt?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenHash?: true
    expiresAt?: true
    revokedAt?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthSessionCountAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenHash?: true
    expiresAt?: true
    revokedAt?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuthSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthSession to aggregate.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthSessions
    **/
    _count?: true | AuthSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthSessionMaxAggregateInputType
  }

  export type GetAuthSessionAggregateType<T extends AuthSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthSession[P]>
      : GetScalarType<T[P], AggregateAuthSession[P]>
  }




  export type AuthSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthSessionWhereInput
    orderBy?: AuthSessionOrderByWithAggregationInput | AuthSessionOrderByWithAggregationInput[]
    by: AuthSessionScalarFieldEnum[] | AuthSessionScalarFieldEnum
    having?: AuthSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthSessionCountAggregateInputType | true
    _min?: AuthSessionMinAggregateInputType
    _max?: AuthSessionMaxAggregateInputType
  }

  export type AuthSessionGroupByOutputType = {
    id: string
    userId: string
    refreshTokenHash: string
    expiresAt: Date
    revokedAt: Date | null
    ip: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: AuthSessionCountAggregateOutputType | null
    _min: AuthSessionMinAggregateOutputType | null
    _max: AuthSessionMaxAggregateOutputType | null
  }

  type GetAuthSessionGroupByPayload<T extends AuthSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AuthSessionGroupByOutputType[P]>
        }
      >
    >


  export type AuthSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshTokenHash?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authSession"]>

  export type AuthSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshTokenHash?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authSession"]>

  export type AuthSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshTokenHash?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authSession"]>

  export type AuthSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    refreshTokenHash?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuthSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "refreshTokenHash" | "expiresAt" | "revokedAt" | "ip" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["authSession"]>
  export type AuthSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuthSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuthSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuthSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuthSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      refreshTokenHash: string
      expiresAt: Date
      revokedAt: Date | null
      ip: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["authSession"]>
    composites: {}
  }

  type AuthSessionGetPayload<S extends boolean | null | undefined | AuthSessionDefaultArgs> = $Result.GetResult<Prisma.$AuthSessionPayload, S>

  type AuthSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthSessionCountAggregateInputType | true
    }

  export interface AuthSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuthSession'], meta: { name: 'AuthSession' } }
    /**
     * Find zero or one AuthSession that matches the filter.
     * @param {AuthSessionFindUniqueArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthSessionFindUniqueArgs>(args: SelectSubset<T, AuthSessionFindUniqueArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuthSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthSessionFindUniqueOrThrowArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionFindFirstArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthSessionFindFirstArgs>(args?: SelectSubset<T, AuthSessionFindFirstArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionFindFirstOrThrowArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuthSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthSessions
     * const authSessions = await prisma.authSession.findMany()
     * 
     * // Get first 10 AuthSessions
     * const authSessions = await prisma.authSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authSessionWithIdOnly = await prisma.authSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthSessionFindManyArgs>(args?: SelectSubset<T, AuthSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuthSession.
     * @param {AuthSessionCreateArgs} args - Arguments to create a AuthSession.
     * @example
     * // Create one AuthSession
     * const AuthSession = await prisma.authSession.create({
     *   data: {
     *     // ... data to create a AuthSession
     *   }
     * })
     * 
     */
    create<T extends AuthSessionCreateArgs>(args: SelectSubset<T, AuthSessionCreateArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuthSessions.
     * @param {AuthSessionCreateManyArgs} args - Arguments to create many AuthSessions.
     * @example
     * // Create many AuthSessions
     * const authSession = await prisma.authSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthSessionCreateManyArgs>(args?: SelectSubset<T, AuthSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuthSessions and returns the data saved in the database.
     * @param {AuthSessionCreateManyAndReturnArgs} args - Arguments to create many AuthSessions.
     * @example
     * // Create many AuthSessions
     * const authSession = await prisma.authSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuthSessions and only return the `id`
     * const authSessionWithIdOnly = await prisma.authSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuthSession.
     * @param {AuthSessionDeleteArgs} args - Arguments to delete one AuthSession.
     * @example
     * // Delete one AuthSession
     * const AuthSession = await prisma.authSession.delete({
     *   where: {
     *     // ... filter to delete one AuthSession
     *   }
     * })
     * 
     */
    delete<T extends AuthSessionDeleteArgs>(args: SelectSubset<T, AuthSessionDeleteArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuthSession.
     * @param {AuthSessionUpdateArgs} args - Arguments to update one AuthSession.
     * @example
     * // Update one AuthSession
     * const authSession = await prisma.authSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthSessionUpdateArgs>(args: SelectSubset<T, AuthSessionUpdateArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuthSessions.
     * @param {AuthSessionDeleteManyArgs} args - Arguments to filter AuthSessions to delete.
     * @example
     * // Delete a few AuthSessions
     * const { count } = await prisma.authSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthSessionDeleteManyArgs>(args?: SelectSubset<T, AuthSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthSessions
     * const authSession = await prisma.authSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthSessionUpdateManyArgs>(args: SelectSubset<T, AuthSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthSessions and returns the data updated in the database.
     * @param {AuthSessionUpdateManyAndReturnArgs} args - Arguments to update many AuthSessions.
     * @example
     * // Update many AuthSessions
     * const authSession = await prisma.authSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuthSessions and only return the `id`
     * const authSessionWithIdOnly = await prisma.authSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuthSession.
     * @param {AuthSessionUpsertArgs} args - Arguments to update or create a AuthSession.
     * @example
     * // Update or create a AuthSession
     * const authSession = await prisma.authSession.upsert({
     *   create: {
     *     // ... data to create a AuthSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthSession we want to update
     *   }
     * })
     */
    upsert<T extends AuthSessionUpsertArgs>(args: SelectSubset<T, AuthSessionUpsertArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuthSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionCountArgs} args - Arguments to filter AuthSessions to count.
     * @example
     * // Count the number of AuthSessions
     * const count = await prisma.authSession.count({
     *   where: {
     *     // ... the filter for the AuthSessions we want to count
     *   }
     * })
    **/
    count<T extends AuthSessionCountArgs>(
      args?: Subset<T, AuthSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthSessionAggregateArgs>(args: Subset<T, AuthSessionAggregateArgs>): Prisma.PrismaPromise<GetAuthSessionAggregateType<T>>

    /**
     * Group by AuthSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthSessionGroupByArgs['orderBy'] }
        : { orderBy?: AuthSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuthSession model
   */
  readonly fields: AuthSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuthSession model
   */
  interface AuthSessionFieldRefs {
    readonly id: FieldRef<"AuthSession", 'String'>
    readonly userId: FieldRef<"AuthSession", 'String'>
    readonly refreshTokenHash: FieldRef<"AuthSession", 'String'>
    readonly expiresAt: FieldRef<"AuthSession", 'DateTime'>
    readonly revokedAt: FieldRef<"AuthSession", 'DateTime'>
    readonly ip: FieldRef<"AuthSession", 'String'>
    readonly userAgent: FieldRef<"AuthSession", 'String'>
    readonly createdAt: FieldRef<"AuthSession", 'DateTime'>
    readonly updatedAt: FieldRef<"AuthSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuthSession findUnique
   */
  export type AuthSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession findUniqueOrThrow
   */
  export type AuthSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession findFirst
   */
  export type AuthSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthSessions.
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthSessions.
     */
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * AuthSession findFirstOrThrow
   */
  export type AuthSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthSessions.
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthSessions.
     */
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * AuthSession findMany
   */
  export type AuthSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSessions to fetch.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthSessions.
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * AuthSession create
   */
  export type AuthSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AuthSession.
     */
    data: XOR<AuthSessionCreateInput, AuthSessionUncheckedCreateInput>
  }

  /**
   * AuthSession createMany
   */
  export type AuthSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuthSessions.
     */
    data: AuthSessionCreateManyInput | AuthSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuthSession createManyAndReturn
   */
  export type AuthSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * The data used to create many AuthSessions.
     */
    data: AuthSessionCreateManyInput | AuthSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthSession update
   */
  export type AuthSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AuthSession.
     */
    data: XOR<AuthSessionUpdateInput, AuthSessionUncheckedUpdateInput>
    /**
     * Choose, which AuthSession to update.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession updateMany
   */
  export type AuthSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuthSessions.
     */
    data: XOR<AuthSessionUpdateManyMutationInput, AuthSessionUncheckedUpdateManyInput>
    /**
     * Filter which AuthSessions to update
     */
    where?: AuthSessionWhereInput
    /**
     * Limit how many AuthSessions to update.
     */
    limit?: number
  }

  /**
   * AuthSession updateManyAndReturn
   */
  export type AuthSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * The data used to update AuthSessions.
     */
    data: XOR<AuthSessionUpdateManyMutationInput, AuthSessionUncheckedUpdateManyInput>
    /**
     * Filter which AuthSessions to update
     */
    where?: AuthSessionWhereInput
    /**
     * Limit how many AuthSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthSession upsert
   */
  export type AuthSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AuthSession to update in case it exists.
     */
    where: AuthSessionWhereUniqueInput
    /**
     * In case the AuthSession found by the `where` argument doesn't exist, create a new AuthSession with this data.
     */
    create: XOR<AuthSessionCreateInput, AuthSessionUncheckedCreateInput>
    /**
     * In case the AuthSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthSessionUpdateInput, AuthSessionUncheckedUpdateInput>
  }

  /**
   * AuthSession delete
   */
  export type AuthSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter which AuthSession to delete.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession deleteMany
   */
  export type AuthSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthSessions to delete
     */
    where?: AuthSessionWhereInput
    /**
     * Limit how many AuthSessions to delete.
     */
    limit?: number
  }

  /**
   * AuthSession without action
   */
  export type AuthSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
  }


  /**
   * Model DispatchJob
   */

  export type AggregateDispatchJob = {
    _count: DispatchJobCountAggregateOutputType | null
    _avg: DispatchJobAvgAggregateOutputType | null
    _sum: DispatchJobSumAggregateOutputType | null
    _min: DispatchJobMinAggregateOutputType | null
    _max: DispatchJobMaxAggregateOutputType | null
  }

  export type DispatchJobAvgAggregateOutputType = {
    attemptCount: number | null
    maxAttempts: number | null
  }

  export type DispatchJobSumAggregateOutputType = {
    attemptCount: number | null
    maxAttempts: number | null
  }

  export type DispatchJobMinAggregateOutputType = {
    id: string | null
    encounterId: string | null
    noteId: string | null
    target: $Enums.DispatchTarget | null
    status: $Enums.DispatchStatus | null
    contractType: string | null
    attemptCount: number | null
    maxAttempts: number | null
    nextRetryAt: Date | null
    dispatchedAt: Date | null
    deadLetteredAt: Date | null
    externalMessageId: string | null
    lastError: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DispatchJobMaxAggregateOutputType = {
    id: string | null
    encounterId: string | null
    noteId: string | null
    target: $Enums.DispatchTarget | null
    status: $Enums.DispatchStatus | null
    contractType: string | null
    attemptCount: number | null
    maxAttempts: number | null
    nextRetryAt: Date | null
    dispatchedAt: Date | null
    deadLetteredAt: Date | null
    externalMessageId: string | null
    lastError: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DispatchJobCountAggregateOutputType = {
    id: number
    encounterId: number
    noteId: number
    target: number
    status: number
    contractType: number
    attemptCount: number
    maxAttempts: number
    nextRetryAt: number
    dispatchedAt: number
    deadLetteredAt: number
    externalMessageId: number
    lastError: number
    payload: number
    response: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DispatchJobAvgAggregateInputType = {
    attemptCount?: true
    maxAttempts?: true
  }

  export type DispatchJobSumAggregateInputType = {
    attemptCount?: true
    maxAttempts?: true
  }

  export type DispatchJobMinAggregateInputType = {
    id?: true
    encounterId?: true
    noteId?: true
    target?: true
    status?: true
    contractType?: true
    attemptCount?: true
    maxAttempts?: true
    nextRetryAt?: true
    dispatchedAt?: true
    deadLetteredAt?: true
    externalMessageId?: true
    lastError?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DispatchJobMaxAggregateInputType = {
    id?: true
    encounterId?: true
    noteId?: true
    target?: true
    status?: true
    contractType?: true
    attemptCount?: true
    maxAttempts?: true
    nextRetryAt?: true
    dispatchedAt?: true
    deadLetteredAt?: true
    externalMessageId?: true
    lastError?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DispatchJobCountAggregateInputType = {
    id?: true
    encounterId?: true
    noteId?: true
    target?: true
    status?: true
    contractType?: true
    attemptCount?: true
    maxAttempts?: true
    nextRetryAt?: true
    dispatchedAt?: true
    deadLetteredAt?: true
    externalMessageId?: true
    lastError?: true
    payload?: true
    response?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DispatchJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DispatchJob to aggregate.
     */
    where?: DispatchJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatchJobs to fetch.
     */
    orderBy?: DispatchJobOrderByWithRelationInput | DispatchJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DispatchJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatchJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatchJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DispatchJobs
    **/
    _count?: true | DispatchJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DispatchJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DispatchJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DispatchJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DispatchJobMaxAggregateInputType
  }

  export type GetDispatchJobAggregateType<T extends DispatchJobAggregateArgs> = {
        [P in keyof T & keyof AggregateDispatchJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispatchJob[P]>
      : GetScalarType<T[P], AggregateDispatchJob[P]>
  }




  export type DispatchJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatchJobWhereInput
    orderBy?: DispatchJobOrderByWithAggregationInput | DispatchJobOrderByWithAggregationInput[]
    by: DispatchJobScalarFieldEnum[] | DispatchJobScalarFieldEnum
    having?: DispatchJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DispatchJobCountAggregateInputType | true
    _avg?: DispatchJobAvgAggregateInputType
    _sum?: DispatchJobSumAggregateInputType
    _min?: DispatchJobMinAggregateInputType
    _max?: DispatchJobMaxAggregateInputType
  }

  export type DispatchJobGroupByOutputType = {
    id: string
    encounterId: string
    noteId: string | null
    target: $Enums.DispatchTarget
    status: $Enums.DispatchStatus
    contractType: string | null
    attemptCount: number
    maxAttempts: number
    nextRetryAt: Date | null
    dispatchedAt: Date | null
    deadLetteredAt: Date | null
    externalMessageId: string | null
    lastError: string | null
    payload: JsonValue
    response: JsonValue | null
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: DispatchJobCountAggregateOutputType | null
    _avg: DispatchJobAvgAggregateOutputType | null
    _sum: DispatchJobSumAggregateOutputType | null
    _min: DispatchJobMinAggregateOutputType | null
    _max: DispatchJobMaxAggregateOutputType | null
  }

  type GetDispatchJobGroupByPayload<T extends DispatchJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DispatchJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DispatchJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DispatchJobGroupByOutputType[P]>
            : GetScalarType<T[P], DispatchJobGroupByOutputType[P]>
        }
      >
    >


  export type DispatchJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    noteId?: boolean
    target?: boolean
    status?: boolean
    contractType?: boolean
    attemptCount?: boolean
    maxAttempts?: boolean
    nextRetryAt?: boolean
    dispatchedAt?: boolean
    deadLetteredAt?: boolean
    externalMessageId?: boolean
    lastError?: boolean
    payload?: boolean
    response?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    note?: boolean | DispatchJob$noteArgs<ExtArgs>
    createdBy?: boolean | DispatchJob$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["dispatchJob"]>

  export type DispatchJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    noteId?: boolean
    target?: boolean
    status?: boolean
    contractType?: boolean
    attemptCount?: boolean
    maxAttempts?: boolean
    nextRetryAt?: boolean
    dispatchedAt?: boolean
    deadLetteredAt?: boolean
    externalMessageId?: boolean
    lastError?: boolean
    payload?: boolean
    response?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    note?: boolean | DispatchJob$noteArgs<ExtArgs>
    createdBy?: boolean | DispatchJob$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["dispatchJob"]>

  export type DispatchJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    noteId?: boolean
    target?: boolean
    status?: boolean
    contractType?: boolean
    attemptCount?: boolean
    maxAttempts?: boolean
    nextRetryAt?: boolean
    dispatchedAt?: boolean
    deadLetteredAt?: boolean
    externalMessageId?: boolean
    lastError?: boolean
    payload?: boolean
    response?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    note?: boolean | DispatchJob$noteArgs<ExtArgs>
    createdBy?: boolean | DispatchJob$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["dispatchJob"]>

  export type DispatchJobSelectScalar = {
    id?: boolean
    encounterId?: boolean
    noteId?: boolean
    target?: boolean
    status?: boolean
    contractType?: boolean
    attemptCount?: boolean
    maxAttempts?: boolean
    nextRetryAt?: boolean
    dispatchedAt?: boolean
    deadLetteredAt?: boolean
    externalMessageId?: boolean
    lastError?: boolean
    payload?: boolean
    response?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DispatchJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "encounterId" | "noteId" | "target" | "status" | "contractType" | "attemptCount" | "maxAttempts" | "nextRetryAt" | "dispatchedAt" | "deadLetteredAt" | "externalMessageId" | "lastError" | "payload" | "response" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["dispatchJob"]>
  export type DispatchJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    note?: boolean | DispatchJob$noteArgs<ExtArgs>
    createdBy?: boolean | DispatchJob$createdByArgs<ExtArgs>
  }
  export type DispatchJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    note?: boolean | DispatchJob$noteArgs<ExtArgs>
    createdBy?: boolean | DispatchJob$createdByArgs<ExtArgs>
  }
  export type DispatchJobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    note?: boolean | DispatchJob$noteArgs<ExtArgs>
    createdBy?: boolean | DispatchJob$createdByArgs<ExtArgs>
  }

  export type $DispatchJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DispatchJob"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      note: Prisma.$NotePayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      encounterId: string
      noteId: string | null
      target: $Enums.DispatchTarget
      status: $Enums.DispatchStatus
      contractType: string | null
      attemptCount: number
      maxAttempts: number
      nextRetryAt: Date | null
      dispatchedAt: Date | null
      deadLetteredAt: Date | null
      externalMessageId: string | null
      lastError: string | null
      payload: Prisma.JsonValue
      response: Prisma.JsonValue | null
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dispatchJob"]>
    composites: {}
  }

  type DispatchJobGetPayload<S extends boolean | null | undefined | DispatchJobDefaultArgs> = $Result.GetResult<Prisma.$DispatchJobPayload, S>

  type DispatchJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DispatchJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DispatchJobCountAggregateInputType | true
    }

  export interface DispatchJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DispatchJob'], meta: { name: 'DispatchJob' } }
    /**
     * Find zero or one DispatchJob that matches the filter.
     * @param {DispatchJobFindUniqueArgs} args - Arguments to find a DispatchJob
     * @example
     * // Get one DispatchJob
     * const dispatchJob = await prisma.dispatchJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DispatchJobFindUniqueArgs>(args: SelectSubset<T, DispatchJobFindUniqueArgs<ExtArgs>>): Prisma__DispatchJobClient<$Result.GetResult<Prisma.$DispatchJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DispatchJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DispatchJobFindUniqueOrThrowArgs} args - Arguments to find a DispatchJob
     * @example
     * // Get one DispatchJob
     * const dispatchJob = await prisma.dispatchJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DispatchJobFindUniqueOrThrowArgs>(args: SelectSubset<T, DispatchJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DispatchJobClient<$Result.GetResult<Prisma.$DispatchJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DispatchJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchJobFindFirstArgs} args - Arguments to find a DispatchJob
     * @example
     * // Get one DispatchJob
     * const dispatchJob = await prisma.dispatchJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DispatchJobFindFirstArgs>(args?: SelectSubset<T, DispatchJobFindFirstArgs<ExtArgs>>): Prisma__DispatchJobClient<$Result.GetResult<Prisma.$DispatchJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DispatchJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchJobFindFirstOrThrowArgs} args - Arguments to find a DispatchJob
     * @example
     * // Get one DispatchJob
     * const dispatchJob = await prisma.dispatchJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DispatchJobFindFirstOrThrowArgs>(args?: SelectSubset<T, DispatchJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__DispatchJobClient<$Result.GetResult<Prisma.$DispatchJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DispatchJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DispatchJobs
     * const dispatchJobs = await prisma.dispatchJob.findMany()
     * 
     * // Get first 10 DispatchJobs
     * const dispatchJobs = await prisma.dispatchJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dispatchJobWithIdOnly = await prisma.dispatchJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DispatchJobFindManyArgs>(args?: SelectSubset<T, DispatchJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DispatchJob.
     * @param {DispatchJobCreateArgs} args - Arguments to create a DispatchJob.
     * @example
     * // Create one DispatchJob
     * const DispatchJob = await prisma.dispatchJob.create({
     *   data: {
     *     // ... data to create a DispatchJob
     *   }
     * })
     * 
     */
    create<T extends DispatchJobCreateArgs>(args: SelectSubset<T, DispatchJobCreateArgs<ExtArgs>>): Prisma__DispatchJobClient<$Result.GetResult<Prisma.$DispatchJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DispatchJobs.
     * @param {DispatchJobCreateManyArgs} args - Arguments to create many DispatchJobs.
     * @example
     * // Create many DispatchJobs
     * const dispatchJob = await prisma.dispatchJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DispatchJobCreateManyArgs>(args?: SelectSubset<T, DispatchJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DispatchJobs and returns the data saved in the database.
     * @param {DispatchJobCreateManyAndReturnArgs} args - Arguments to create many DispatchJobs.
     * @example
     * // Create many DispatchJobs
     * const dispatchJob = await prisma.dispatchJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DispatchJobs and only return the `id`
     * const dispatchJobWithIdOnly = await prisma.dispatchJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DispatchJobCreateManyAndReturnArgs>(args?: SelectSubset<T, DispatchJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DispatchJob.
     * @param {DispatchJobDeleteArgs} args - Arguments to delete one DispatchJob.
     * @example
     * // Delete one DispatchJob
     * const DispatchJob = await prisma.dispatchJob.delete({
     *   where: {
     *     // ... filter to delete one DispatchJob
     *   }
     * })
     * 
     */
    delete<T extends DispatchJobDeleteArgs>(args: SelectSubset<T, DispatchJobDeleteArgs<ExtArgs>>): Prisma__DispatchJobClient<$Result.GetResult<Prisma.$DispatchJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DispatchJob.
     * @param {DispatchJobUpdateArgs} args - Arguments to update one DispatchJob.
     * @example
     * // Update one DispatchJob
     * const dispatchJob = await prisma.dispatchJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DispatchJobUpdateArgs>(args: SelectSubset<T, DispatchJobUpdateArgs<ExtArgs>>): Prisma__DispatchJobClient<$Result.GetResult<Prisma.$DispatchJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DispatchJobs.
     * @param {DispatchJobDeleteManyArgs} args - Arguments to filter DispatchJobs to delete.
     * @example
     * // Delete a few DispatchJobs
     * const { count } = await prisma.dispatchJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DispatchJobDeleteManyArgs>(args?: SelectSubset<T, DispatchJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DispatchJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DispatchJobs
     * const dispatchJob = await prisma.dispatchJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DispatchJobUpdateManyArgs>(args: SelectSubset<T, DispatchJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DispatchJobs and returns the data updated in the database.
     * @param {DispatchJobUpdateManyAndReturnArgs} args - Arguments to update many DispatchJobs.
     * @example
     * // Update many DispatchJobs
     * const dispatchJob = await prisma.dispatchJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DispatchJobs and only return the `id`
     * const dispatchJobWithIdOnly = await prisma.dispatchJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DispatchJobUpdateManyAndReturnArgs>(args: SelectSubset<T, DispatchJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DispatchJob.
     * @param {DispatchJobUpsertArgs} args - Arguments to update or create a DispatchJob.
     * @example
     * // Update or create a DispatchJob
     * const dispatchJob = await prisma.dispatchJob.upsert({
     *   create: {
     *     // ... data to create a DispatchJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DispatchJob we want to update
     *   }
     * })
     */
    upsert<T extends DispatchJobUpsertArgs>(args: SelectSubset<T, DispatchJobUpsertArgs<ExtArgs>>): Prisma__DispatchJobClient<$Result.GetResult<Prisma.$DispatchJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DispatchJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchJobCountArgs} args - Arguments to filter DispatchJobs to count.
     * @example
     * // Count the number of DispatchJobs
     * const count = await prisma.dispatchJob.count({
     *   where: {
     *     // ... the filter for the DispatchJobs we want to count
     *   }
     * })
    **/
    count<T extends DispatchJobCountArgs>(
      args?: Subset<T, DispatchJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DispatchJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DispatchJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DispatchJobAggregateArgs>(args: Subset<T, DispatchJobAggregateArgs>): Prisma.PrismaPromise<GetDispatchJobAggregateType<T>>

    /**
     * Group by DispatchJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DispatchJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DispatchJobGroupByArgs['orderBy'] }
        : { orderBy?: DispatchJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DispatchJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDispatchJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DispatchJob model
   */
  readonly fields: DispatchJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DispatchJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DispatchJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    note<T extends DispatchJob$noteArgs<ExtArgs> = {}>(args?: Subset<T, DispatchJob$noteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends DispatchJob$createdByArgs<ExtArgs> = {}>(args?: Subset<T, DispatchJob$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DispatchJob model
   */
  interface DispatchJobFieldRefs {
    readonly id: FieldRef<"DispatchJob", 'String'>
    readonly encounterId: FieldRef<"DispatchJob", 'String'>
    readonly noteId: FieldRef<"DispatchJob", 'String'>
    readonly target: FieldRef<"DispatchJob", 'DispatchTarget'>
    readonly status: FieldRef<"DispatchJob", 'DispatchStatus'>
    readonly contractType: FieldRef<"DispatchJob", 'String'>
    readonly attemptCount: FieldRef<"DispatchJob", 'Int'>
    readonly maxAttempts: FieldRef<"DispatchJob", 'Int'>
    readonly nextRetryAt: FieldRef<"DispatchJob", 'DateTime'>
    readonly dispatchedAt: FieldRef<"DispatchJob", 'DateTime'>
    readonly deadLetteredAt: FieldRef<"DispatchJob", 'DateTime'>
    readonly externalMessageId: FieldRef<"DispatchJob", 'String'>
    readonly lastError: FieldRef<"DispatchJob", 'String'>
    readonly payload: FieldRef<"DispatchJob", 'Json'>
    readonly response: FieldRef<"DispatchJob", 'Json'>
    readonly createdById: FieldRef<"DispatchJob", 'String'>
    readonly createdAt: FieldRef<"DispatchJob", 'DateTime'>
    readonly updatedAt: FieldRef<"DispatchJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DispatchJob findUnique
   */
  export type DispatchJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobInclude<ExtArgs> | null
    /**
     * Filter, which DispatchJob to fetch.
     */
    where: DispatchJobWhereUniqueInput
  }

  /**
   * DispatchJob findUniqueOrThrow
   */
  export type DispatchJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobInclude<ExtArgs> | null
    /**
     * Filter, which DispatchJob to fetch.
     */
    where: DispatchJobWhereUniqueInput
  }

  /**
   * DispatchJob findFirst
   */
  export type DispatchJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobInclude<ExtArgs> | null
    /**
     * Filter, which DispatchJob to fetch.
     */
    where?: DispatchJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatchJobs to fetch.
     */
    orderBy?: DispatchJobOrderByWithRelationInput | DispatchJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DispatchJobs.
     */
    cursor?: DispatchJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatchJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatchJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DispatchJobs.
     */
    distinct?: DispatchJobScalarFieldEnum | DispatchJobScalarFieldEnum[]
  }

  /**
   * DispatchJob findFirstOrThrow
   */
  export type DispatchJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobInclude<ExtArgs> | null
    /**
     * Filter, which DispatchJob to fetch.
     */
    where?: DispatchJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatchJobs to fetch.
     */
    orderBy?: DispatchJobOrderByWithRelationInput | DispatchJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DispatchJobs.
     */
    cursor?: DispatchJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatchJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatchJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DispatchJobs.
     */
    distinct?: DispatchJobScalarFieldEnum | DispatchJobScalarFieldEnum[]
  }

  /**
   * DispatchJob findMany
   */
  export type DispatchJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobInclude<ExtArgs> | null
    /**
     * Filter, which DispatchJobs to fetch.
     */
    where?: DispatchJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispatchJobs to fetch.
     */
    orderBy?: DispatchJobOrderByWithRelationInput | DispatchJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DispatchJobs.
     */
    cursor?: DispatchJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispatchJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispatchJobs.
     */
    skip?: number
    distinct?: DispatchJobScalarFieldEnum | DispatchJobScalarFieldEnum[]
  }

  /**
   * DispatchJob create
   */
  export type DispatchJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobInclude<ExtArgs> | null
    /**
     * The data needed to create a DispatchJob.
     */
    data: XOR<DispatchJobCreateInput, DispatchJobUncheckedCreateInput>
  }

  /**
   * DispatchJob createMany
   */
  export type DispatchJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DispatchJobs.
     */
    data: DispatchJobCreateManyInput | DispatchJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DispatchJob createManyAndReturn
   */
  export type DispatchJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * The data used to create many DispatchJobs.
     */
    data: DispatchJobCreateManyInput | DispatchJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DispatchJob update
   */
  export type DispatchJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobInclude<ExtArgs> | null
    /**
     * The data needed to update a DispatchJob.
     */
    data: XOR<DispatchJobUpdateInput, DispatchJobUncheckedUpdateInput>
    /**
     * Choose, which DispatchJob to update.
     */
    where: DispatchJobWhereUniqueInput
  }

  /**
   * DispatchJob updateMany
   */
  export type DispatchJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DispatchJobs.
     */
    data: XOR<DispatchJobUpdateManyMutationInput, DispatchJobUncheckedUpdateManyInput>
    /**
     * Filter which DispatchJobs to update
     */
    where?: DispatchJobWhereInput
    /**
     * Limit how many DispatchJobs to update.
     */
    limit?: number
  }

  /**
   * DispatchJob updateManyAndReturn
   */
  export type DispatchJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * The data used to update DispatchJobs.
     */
    data: XOR<DispatchJobUpdateManyMutationInput, DispatchJobUncheckedUpdateManyInput>
    /**
     * Filter which DispatchJobs to update
     */
    where?: DispatchJobWhereInput
    /**
     * Limit how many DispatchJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DispatchJob upsert
   */
  export type DispatchJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobInclude<ExtArgs> | null
    /**
     * The filter to search for the DispatchJob to update in case it exists.
     */
    where: DispatchJobWhereUniqueInput
    /**
     * In case the DispatchJob found by the `where` argument doesn't exist, create a new DispatchJob with this data.
     */
    create: XOR<DispatchJobCreateInput, DispatchJobUncheckedCreateInput>
    /**
     * In case the DispatchJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DispatchJobUpdateInput, DispatchJobUncheckedUpdateInput>
  }

  /**
   * DispatchJob delete
   */
  export type DispatchJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobInclude<ExtArgs> | null
    /**
     * Filter which DispatchJob to delete.
     */
    where: DispatchJobWhereUniqueInput
  }

  /**
   * DispatchJob deleteMany
   */
  export type DispatchJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DispatchJobs to delete
     */
    where?: DispatchJobWhereInput
    /**
     * Limit how many DispatchJobs to delete.
     */
    limit?: number
  }

  /**
   * DispatchJob.note
   */
  export type DispatchJob$noteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
  }

  /**
   * DispatchJob.createdBy
   */
  export type DispatchJob$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DispatchJob without action
   */
  export type DispatchJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispatchJob
     */
    select?: DispatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DispatchJob
     */
    omit?: DispatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchJobInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    passwordHash: 'passwordHash',
    mfaEnabled: 'mfaEnabled',
    mfaSecret: 'mfaSecret',
    mfaBackupCodesHash: 'mfaBackupCodesHash',
    mfaEnrolledAt: 'mfaEnrolledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    payload: 'payload',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    firstName: 'firstName',
    lastName: 'lastName',
    dateOfBirth: 'dateOfBirth',
    email: 'email',
    phone: 'phone',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    patientId: 'patientId',
    providerId: 'providerId',
    createdById: 'createdById',
    scheduledAt: 'scheduledAt',
    durationMinutes: 'durationMinutes',
    appointmentType: 'appointmentType',
    location: 'location',
    status: 'status',
    priority: 'priority',
    isVirtual: 'isVirtual',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const EncounterScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    appointmentId: 'appointmentId',
    patientId: 'patientId',
    providerId: 'providerId',
    status: 'status',
    startedAt: 'startedAt',
    stoppedAt: 'stoppedAt',
    hiddenDraftCreated: 'hiddenDraftCreated',
    draftUnhiddenAt: 'draftUnhiddenAt',
    finalizedAt: 'finalizedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EncounterScalarFieldEnum = (typeof EncounterScalarFieldEnum)[keyof typeof EncounterScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    status: 'status',
    visibility: 'visibility',
    content: 'content',
    patientSummary: 'patientSummary',
    createdById: 'createdById',
    updatedById: 'updatedById',
    finalizedAt: 'finalizedAt',
    lockedAt: 'lockedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const NoteVersionScalarFieldEnum: {
    id: 'id',
    noteId: 'noteId',
    versionNumber: 'versionNumber',
    source: 'source',
    content: 'content',
    patientSummary: 'patientSummary',
    traceId: 'traceId',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type NoteVersionScalarFieldEnum = (typeof NoteVersionScalarFieldEnum)[keyof typeof NoteVersionScalarFieldEnum]


  export const TranscriptSegmentScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    speaker: 'speaker',
    speakerLabel: 'speakerLabel',
    text: 'text',
    startMs: 'startMs',
    endMs: 'endMs',
    source: 'source',
    confidence: 'confidence',
    createdAt: 'createdAt'
  };

  export type TranscriptSegmentScalarFieldEnum = (typeof TranscriptSegmentScalarFieldEnum)[keyof typeof TranscriptSegmentScalarFieldEnum]


  export const ChartAssetScalarFieldEnum: {
    id: 'id',
    appointmentId: 'appointmentId',
    encounterId: 'encounterId',
    patientId: 'patientId',
    fileName: 'fileName',
    mimeType: 'mimeType',
    sizeBytes: 'sizeBytes',
    storagePath: 'storagePath',
    extractedJson: 'extractedJson',
    rawText: 'rawText',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type ChartAssetScalarFieldEnum = (typeof ChartAssetScalarFieldEnum)[keyof typeof ChartAssetScalarFieldEnum]


  export const SuggestionGenerationScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    trigger: 'trigger',
    textDelta: 'textDelta',
    transcriptDelta: 'transcriptDelta',
    inputHash: 'inputHash',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type SuggestionGenerationScalarFieldEnum = (typeof SuggestionGenerationScalarFieldEnum)[keyof typeof SuggestionGenerationScalarFieldEnum]


  export const CodeSuggestionScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    generationId: 'generationId',
    code: 'code',
    codeType: 'codeType',
    category: 'category',
    title: 'title',
    description: 'description',
    rationale: 'rationale',
    confidence: 'confidence',
    evidence: 'evidence',
    status: 'status',
    recommended: 'recommended',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CodeSuggestionScalarFieldEnum = (typeof CodeSuggestionScalarFieldEnum)[keyof typeof CodeSuggestionScalarFieldEnum]


  export const CodeSelectionScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    codeSuggestionId: 'codeSuggestionId',
    code: 'code',
    codeType: 'codeType',
    category: 'category',
    action: 'action',
    decisionReason: 'decisionReason',
    actorId: 'actorId',
    createdAt: 'createdAt'
  };

  export type CodeSelectionScalarFieldEnum = (typeof CodeSelectionScalarFieldEnum)[keyof typeof CodeSelectionScalarFieldEnum]


  export const ComplianceIssueScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    severity: 'severity',
    status: 'status',
    title: 'title',
    description: 'description',
    rationale: 'rationale',
    remediation: 'remediation',
    evidence: 'evidence',
    fingerprint: 'fingerprint',
    actorId: 'actorId',
    resolvedAt: 'resolvedAt',
    dismissedAt: 'dismissedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplianceIssueScalarFieldEnum = (typeof ComplianceIssueScalarFieldEnum)[keyof typeof ComplianceIssueScalarFieldEnum]


  export const WizardRunScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    status: 'status',
    runState: 'runState',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type WizardRunScalarFieldEnum = (typeof WizardRunScalarFieldEnum)[keyof typeof WizardRunScalarFieldEnum]


  export const WizardStepStateScalarFieldEnum: {
    id: 'id',
    wizardRunId: 'wizardRunId',
    encounterId: 'encounterId',
    step: 'step',
    status: 'status',
    payload: 'payload',
    lastActorId: 'lastActorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WizardStepStateScalarFieldEnum = (typeof WizardStepStateScalarFieldEnum)[keyof typeof WizardStepStateScalarFieldEnum]


  export const ExportArtifactScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    noteId: 'noteId',
    type: 'type',
    filePath: 'filePath',
    mimeType: 'mimeType',
    fileName: 'fileName',
    sizeBytes: 'sizeBytes',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type ExportArtifactScalarFieldEnum = (typeof ExportArtifactScalarFieldEnum)[keyof typeof ExportArtifactScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorId: 'actorId',
    encounterId: 'encounterId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    ip: 'ip',
    userAgent: 'userAgent',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AuthSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    refreshTokenHash: 'refreshTokenHash',
    expiresAt: 'expiresAt',
    revokedAt: 'revokedAt',
    ip: 'ip',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuthSessionScalarFieldEnum = (typeof AuthSessionScalarFieldEnum)[keyof typeof AuthSessionScalarFieldEnum]


  export const DispatchJobScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    noteId: 'noteId',
    target: 'target',
    status: 'status',
    contractType: 'contractType',
    attemptCount: 'attemptCount',
    maxAttempts: 'maxAttempts',
    nextRetryAt: 'nextRetryAt',
    dispatchedAt: 'dispatchedAt',
    deadLetteredAt: 'deadLetteredAt',
    externalMessageId: 'externalMessageId',
    lastError: 'lastError',
    payload: 'payload',
    response: 'response',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DispatchJobScalarFieldEnum = (typeof DispatchJobScalarFieldEnum)[keyof typeof DispatchJobScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'AppointmentPriority'
   */
  export type EnumAppointmentPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentPriority'>
    


  /**
   * Reference to a field of type 'AppointmentPriority[]'
   */
  export type ListEnumAppointmentPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentPriority[]'>
    


  /**
   * Reference to a field of type 'EncounterStatus'
   */
  export type EnumEncounterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EncounterStatus'>
    


  /**
   * Reference to a field of type 'EncounterStatus[]'
   */
  export type ListEnumEncounterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EncounterStatus[]'>
    


  /**
   * Reference to a field of type 'NoteStatus'
   */
  export type EnumNoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteStatus'>
    


  /**
   * Reference to a field of type 'NoteStatus[]'
   */
  export type ListEnumNoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteStatus[]'>
    


  /**
   * Reference to a field of type 'NoteVisibility'
   */
  export type EnumNoteVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteVisibility'>
    


  /**
   * Reference to a field of type 'NoteVisibility[]'
   */
  export type ListEnumNoteVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteVisibility[]'>
    


  /**
   * Reference to a field of type 'TranscriptSource'
   */
  export type EnumTranscriptSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranscriptSource'>
    


  /**
   * Reference to a field of type 'TranscriptSource[]'
   */
  export type ListEnumTranscriptSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranscriptSource[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'SuggestionCategory'
   */
  export type EnumSuggestionCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SuggestionCategory'>
    


  /**
   * Reference to a field of type 'SuggestionCategory[]'
   */
  export type ListEnumSuggestionCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SuggestionCategory[]'>
    


  /**
   * Reference to a field of type 'SuggestionStatus'
   */
  export type EnumSuggestionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SuggestionStatus'>
    


  /**
   * Reference to a field of type 'SuggestionStatus[]'
   */
  export type ListEnumSuggestionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SuggestionStatus[]'>
    


  /**
   * Reference to a field of type 'SelectionAction'
   */
  export type EnumSelectionActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SelectionAction'>
    


  /**
   * Reference to a field of type 'SelectionAction[]'
   */
  export type ListEnumSelectionActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SelectionAction[]'>
    


  /**
   * Reference to a field of type 'ComplianceSeverity'
   */
  export type EnumComplianceSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplianceSeverity'>
    


  /**
   * Reference to a field of type 'ComplianceSeverity[]'
   */
  export type ListEnumComplianceSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplianceSeverity[]'>
    


  /**
   * Reference to a field of type 'ComplianceStatus'
   */
  export type EnumComplianceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplianceStatus'>
    


  /**
   * Reference to a field of type 'ComplianceStatus[]'
   */
  export type ListEnumComplianceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplianceStatus[]'>
    


  /**
   * Reference to a field of type 'WizardRunStatus'
   */
  export type EnumWizardRunStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WizardRunStatus'>
    


  /**
   * Reference to a field of type 'WizardRunStatus[]'
   */
  export type ListEnumWizardRunStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WizardRunStatus[]'>
    


  /**
   * Reference to a field of type 'WizardStep'
   */
  export type EnumWizardStepFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WizardStep'>
    


  /**
   * Reference to a field of type 'WizardStep[]'
   */
  export type ListEnumWizardStepFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WizardStep[]'>
    


  /**
   * Reference to a field of type 'WizardStepStatus'
   */
  export type EnumWizardStepStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WizardStepStatus'>
    


  /**
   * Reference to a field of type 'WizardStepStatus[]'
   */
  export type ListEnumWizardStepStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WizardStepStatus[]'>
    


  /**
   * Reference to a field of type 'ArtifactType'
   */
  export type EnumArtifactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArtifactType'>
    


  /**
   * Reference to a field of type 'ArtifactType[]'
   */
  export type ListEnumArtifactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArtifactType[]'>
    


  /**
   * Reference to a field of type 'DispatchTarget'
   */
  export type EnumDispatchTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DispatchTarget'>
    


  /**
   * Reference to a field of type 'DispatchTarget[]'
   */
  export type ListEnumDispatchTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DispatchTarget[]'>
    


  /**
   * Reference to a field of type 'DispatchStatus'
   */
  export type EnumDispatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DispatchStatus'>
    


  /**
   * Reference to a field of type 'DispatchStatus[]'
   */
  export type ListEnumDispatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DispatchStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    passwordHash?: StringNullableFilter<"User"> | string | null
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    mfaBackupCodesHash?: JsonNullableFilter<"User">
    mfaEnrolledAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    appointmentsCreated?: AppointmentListRelationFilter
    appointmentsProvided?: AppointmentListRelationFilter
    encountersProvided?: EncounterListRelationFilter
    notesCreated?: NoteListRelationFilter
    notesUpdated?: NoteListRelationFilter
    noteVersions?: NoteVersionListRelationFilter
    chartAssets?: ChartAssetListRelationFilter
    suggestionGenerations?: SuggestionGenerationListRelationFilter
    codeSelections?: CodeSelectionListRelationFilter
    complianceIssues?: ComplianceIssueListRelationFilter
    wizardStepStates?: WizardStepStateListRelationFilter
    exportArtifacts?: ExportArtifactListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    authSessions?: AuthSessionListRelationFilter
    dispatchJobs?: DispatchJobListRelationFilter
    userSettings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaBackupCodesHash?: SortOrderInput | SortOrder
    mfaEnrolledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    appointmentsCreated?: AppointmentOrderByRelationAggregateInput
    appointmentsProvided?: AppointmentOrderByRelationAggregateInput
    encountersProvided?: EncounterOrderByRelationAggregateInput
    notesCreated?: NoteOrderByRelationAggregateInput
    notesUpdated?: NoteOrderByRelationAggregateInput
    noteVersions?: NoteVersionOrderByRelationAggregateInput
    chartAssets?: ChartAssetOrderByRelationAggregateInput
    suggestionGenerations?: SuggestionGenerationOrderByRelationAggregateInput
    codeSelections?: CodeSelectionOrderByRelationAggregateInput
    complianceIssues?: ComplianceIssueOrderByRelationAggregateInput
    wizardStepStates?: WizardStepStateOrderByRelationAggregateInput
    exportArtifacts?: ExportArtifactOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    authSessions?: AuthSessionOrderByRelationAggregateInput
    dispatchJobs?: DispatchJobOrderByRelationAggregateInput
    userSettings?: UserSettingsOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    passwordHash?: StringNullableFilter<"User"> | string | null
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    mfaBackupCodesHash?: JsonNullableFilter<"User">
    mfaEnrolledAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    appointmentsCreated?: AppointmentListRelationFilter
    appointmentsProvided?: AppointmentListRelationFilter
    encountersProvided?: EncounterListRelationFilter
    notesCreated?: NoteListRelationFilter
    notesUpdated?: NoteListRelationFilter
    noteVersions?: NoteVersionListRelationFilter
    chartAssets?: ChartAssetListRelationFilter
    suggestionGenerations?: SuggestionGenerationListRelationFilter
    codeSelections?: CodeSelectionListRelationFilter
    complianceIssues?: ComplianceIssueListRelationFilter
    wizardStepStates?: WizardStepStateListRelationFilter
    exportArtifacts?: ExportArtifactListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    authSessions?: AuthSessionListRelationFilter
    dispatchJobs?: DispatchJobListRelationFilter
    userSettings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaBackupCodesHash?: SortOrderInput | SortOrder
    mfaEnrolledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    mfaEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    mfaSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    mfaBackupCodesHash?: JsonNullableWithAggregatesFilter<"User">
    mfaEnrolledAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    id?: StringFilter<"UserSettings"> | string
    userId?: StringFilter<"UserSettings"> | string
    payload?: JsonFilter<"UserSettings">
    updatedById?: StringNullableFilter<"UserSettings"> | string | null
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    payload?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    payload?: JsonFilter<"UserSettings">
    updatedById?: StringNullableFilter<"UserSettings"> | string | null
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    payload?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSettings"> | string
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    payload?: JsonWithAggregatesFilter<"UserSettings">
    updatedById?: StringNullableWithAggregatesFilter<"UserSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    externalId?: StringFilter<"Patient"> | string
    firstName?: StringFilter<"Patient"> | string
    lastName?: StringFilter<"Patient"> | string
    dateOfBirth?: DateTimeNullableFilter<"Patient"> | Date | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    metadata?: JsonNullableFilter<"Patient">
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    appointments?: AppointmentListRelationFilter
    encounters?: EncounterListRelationFilter
    chartAssets?: ChartAssetListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    appointments?: AppointmentOrderByRelationAggregateInput
    encounters?: EncounterOrderByRelationAggregateInput
    chartAssets?: ChartAssetOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    firstName?: StringFilter<"Patient"> | string
    lastName?: StringFilter<"Patient"> | string
    dateOfBirth?: DateTimeNullableFilter<"Patient"> | Date | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    metadata?: JsonNullableFilter<"Patient">
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    appointments?: AppointmentListRelationFilter
    encounters?: EncounterListRelationFilter
    chartAssets?: ChartAssetListRelationFilter
  }, "id" | "externalId">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    externalId?: StringWithAggregatesFilter<"Patient"> | string
    firstName?: StringWithAggregatesFilter<"Patient"> | string
    lastName?: StringWithAggregatesFilter<"Patient"> | string
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    email?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Patient">
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    externalId?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    providerId?: StringNullableFilter<"Appointment"> | string | null
    createdById?: StringNullableFilter<"Appointment"> | string | null
    scheduledAt?: DateTimeFilter<"Appointment"> | Date | string
    durationMinutes?: IntFilter<"Appointment"> | number
    appointmentType?: StringFilter<"Appointment"> | string
    location?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFilter<"Appointment"> | $Enums.AppointmentPriority
    isVirtual?: BoolFilter<"Appointment"> | boolean
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    provider?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    encounter?: XOR<EncounterNullableScalarRelationFilter, EncounterWhereInput> | null
    chartAssets?: ChartAssetListRelationFilter
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrder
    patientId?: SortOrder
    providerId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    scheduledAt?: SortOrder
    durationMinutes?: SortOrder
    appointmentType?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    isVirtual?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    provider?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    encounter?: EncounterOrderByWithRelationInput
    chartAssets?: ChartAssetOrderByRelationAggregateInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    patientId?: StringFilter<"Appointment"> | string
    providerId?: StringNullableFilter<"Appointment"> | string | null
    createdById?: StringNullableFilter<"Appointment"> | string | null
    scheduledAt?: DateTimeFilter<"Appointment"> | Date | string
    durationMinutes?: IntFilter<"Appointment"> | number
    appointmentType?: StringFilter<"Appointment"> | string
    location?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFilter<"Appointment"> | $Enums.AppointmentPriority
    isVirtual?: BoolFilter<"Appointment"> | boolean
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    provider?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    encounter?: XOR<EncounterNullableScalarRelationFilter, EncounterWhereInput> | null
    chartAssets?: ChartAssetListRelationFilter
  }, "id" | "externalId">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrder
    patientId?: SortOrder
    providerId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    scheduledAt?: SortOrder
    durationMinutes?: SortOrder
    appointmentType?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    isVirtual?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    externalId?: StringWithAggregatesFilter<"Appointment"> | string
    patientId?: StringWithAggregatesFilter<"Appointment"> | string
    providerId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    scheduledAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    durationMinutes?: IntWithAggregatesFilter<"Appointment"> | number
    appointmentType?: StringWithAggregatesFilter<"Appointment"> | string
    location?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityWithAggregatesFilter<"Appointment"> | $Enums.AppointmentPriority
    isVirtual?: BoolWithAggregatesFilter<"Appointment"> | boolean
    notes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type EncounterWhereInput = {
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    id?: StringFilter<"Encounter"> | string
    externalId?: StringFilter<"Encounter"> | string
    appointmentId?: StringNullableFilter<"Encounter"> | string | null
    patientId?: StringFilter<"Encounter"> | string
    providerId?: StringNullableFilter<"Encounter"> | string | null
    status?: EnumEncounterStatusFilter<"Encounter"> | $Enums.EncounterStatus
    startedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    stoppedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    hiddenDraftCreated?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    draftUnhiddenAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    finalizedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeFilter<"Encounter"> | Date | string
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    provider?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    note?: XOR<NoteNullableScalarRelationFilter, NoteWhereInput> | null
    transcriptSegments?: TranscriptSegmentListRelationFilter
    chartAssets?: ChartAssetListRelationFilter
    suggestionCycles?: SuggestionGenerationListRelationFilter
    codeSuggestions?: CodeSuggestionListRelationFilter
    codeSelections?: CodeSelectionListRelationFilter
    complianceIssues?: ComplianceIssueListRelationFilter
    wizardRuns?: WizardRunListRelationFilter
    wizardStepStates?: WizardStepStateListRelationFilter
    exportArtifacts?: ExportArtifactListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    dispatchJobs?: DispatchJobListRelationFilter
  }

  export type EncounterOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    patientId?: SortOrder
    providerId?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    stoppedAt?: SortOrderInput | SortOrder
    hiddenDraftCreated?: SortOrderInput | SortOrder
    draftUnhiddenAt?: SortOrderInput | SortOrder
    finalizedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    provider?: UserOrderByWithRelationInput
    note?: NoteOrderByWithRelationInput
    transcriptSegments?: TranscriptSegmentOrderByRelationAggregateInput
    chartAssets?: ChartAssetOrderByRelationAggregateInput
    suggestionCycles?: SuggestionGenerationOrderByRelationAggregateInput
    codeSuggestions?: CodeSuggestionOrderByRelationAggregateInput
    codeSelections?: CodeSelectionOrderByRelationAggregateInput
    complianceIssues?: ComplianceIssueOrderByRelationAggregateInput
    wizardRuns?: WizardRunOrderByRelationAggregateInput
    wizardStepStates?: WizardStepStateOrderByRelationAggregateInput
    exportArtifacts?: ExportArtifactOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    dispatchJobs?: DispatchJobOrderByRelationAggregateInput
  }

  export type EncounterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId?: string
    appointmentId?: string
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    patientId?: StringFilter<"Encounter"> | string
    providerId?: StringNullableFilter<"Encounter"> | string | null
    status?: EnumEncounterStatusFilter<"Encounter"> | $Enums.EncounterStatus
    startedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    stoppedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    hiddenDraftCreated?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    draftUnhiddenAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    finalizedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeFilter<"Encounter"> | Date | string
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    provider?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    note?: XOR<NoteNullableScalarRelationFilter, NoteWhereInput> | null
    transcriptSegments?: TranscriptSegmentListRelationFilter
    chartAssets?: ChartAssetListRelationFilter
    suggestionCycles?: SuggestionGenerationListRelationFilter
    codeSuggestions?: CodeSuggestionListRelationFilter
    codeSelections?: CodeSelectionListRelationFilter
    complianceIssues?: ComplianceIssueListRelationFilter
    wizardRuns?: WizardRunListRelationFilter
    wizardStepStates?: WizardStepStateListRelationFilter
    exportArtifacts?: ExportArtifactListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    dispatchJobs?: DispatchJobListRelationFilter
  }, "id" | "externalId" | "appointmentId">

  export type EncounterOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    patientId?: SortOrder
    providerId?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    stoppedAt?: SortOrderInput | SortOrder
    hiddenDraftCreated?: SortOrderInput | SortOrder
    draftUnhiddenAt?: SortOrderInput | SortOrder
    finalizedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EncounterCountOrderByAggregateInput
    _max?: EncounterMaxOrderByAggregateInput
    _min?: EncounterMinOrderByAggregateInput
  }

  export type EncounterScalarWhereWithAggregatesInput = {
    AND?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    OR?: EncounterScalarWhereWithAggregatesInput[]
    NOT?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Encounter"> | string
    externalId?: StringWithAggregatesFilter<"Encounter"> | string
    appointmentId?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    patientId?: StringWithAggregatesFilter<"Encounter"> | string
    providerId?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    status?: EnumEncounterStatusWithAggregatesFilter<"Encounter"> | $Enums.EncounterStatus
    startedAt?: DateTimeNullableWithAggregatesFilter<"Encounter"> | Date | string | null
    stoppedAt?: DateTimeNullableWithAggregatesFilter<"Encounter"> | Date | string | null
    hiddenDraftCreated?: DateTimeNullableWithAggregatesFilter<"Encounter"> | Date | string | null
    draftUnhiddenAt?: DateTimeNullableWithAggregatesFilter<"Encounter"> | Date | string | null
    finalizedAt?: DateTimeNullableWithAggregatesFilter<"Encounter"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
  }

  export type NoteWhereInput = {
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    id?: StringFilter<"Note"> | string
    encounterId?: StringFilter<"Note"> | string
    status?: EnumNoteStatusFilter<"Note"> | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFilter<"Note"> | $Enums.NoteVisibility
    content?: StringFilter<"Note"> | string
    patientSummary?: StringFilter<"Note"> | string
    createdById?: StringNullableFilter<"Note"> | string | null
    updatedById?: StringNullableFilter<"Note"> | string | null
    finalizedAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    lockedAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    versions?: NoteVersionListRelationFilter
    exportArtifacts?: ExportArtifactListRelationFilter
    dispatchJobs?: DispatchJobListRelationFilter
  }

  export type NoteOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    content?: SortOrder
    patientSummary?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    finalizedAt?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    versions?: NoteVersionOrderByRelationAggregateInput
    exportArtifacts?: ExportArtifactOrderByRelationAggregateInput
    dispatchJobs?: DispatchJobOrderByRelationAggregateInput
  }

  export type NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    encounterId?: string
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    status?: EnumNoteStatusFilter<"Note"> | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFilter<"Note"> | $Enums.NoteVisibility
    content?: StringFilter<"Note"> | string
    patientSummary?: StringFilter<"Note"> | string
    createdById?: StringNullableFilter<"Note"> | string | null
    updatedById?: StringNullableFilter<"Note"> | string | null
    finalizedAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    lockedAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    versions?: NoteVersionListRelationFilter
    exportArtifacts?: ExportArtifactListRelationFilter
    dispatchJobs?: DispatchJobListRelationFilter
  }, "id" | "encounterId">

  export type NoteOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    content?: SortOrder
    patientSummary?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    finalizedAt?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NoteCountOrderByAggregateInput
    _max?: NoteMaxOrderByAggregateInput
    _min?: NoteMinOrderByAggregateInput
  }

  export type NoteScalarWhereWithAggregatesInput = {
    AND?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    OR?: NoteScalarWhereWithAggregatesInput[]
    NOT?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Note"> | string
    encounterId?: StringWithAggregatesFilter<"Note"> | string
    status?: EnumNoteStatusWithAggregatesFilter<"Note"> | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityWithAggregatesFilter<"Note"> | $Enums.NoteVisibility
    content?: StringWithAggregatesFilter<"Note"> | string
    patientSummary?: StringWithAggregatesFilter<"Note"> | string
    createdById?: StringNullableWithAggregatesFilter<"Note"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Note"> | string | null
    finalizedAt?: DateTimeNullableWithAggregatesFilter<"Note"> | Date | string | null
    lockedAt?: DateTimeNullableWithAggregatesFilter<"Note"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
  }

  export type NoteVersionWhereInput = {
    AND?: NoteVersionWhereInput | NoteVersionWhereInput[]
    OR?: NoteVersionWhereInput[]
    NOT?: NoteVersionWhereInput | NoteVersionWhereInput[]
    id?: StringFilter<"NoteVersion"> | string
    noteId?: StringFilter<"NoteVersion"> | string
    versionNumber?: IntFilter<"NoteVersion"> | number
    source?: StringFilter<"NoteVersion"> | string
    content?: StringFilter<"NoteVersion"> | string
    patientSummary?: StringFilter<"NoteVersion"> | string
    traceId?: StringNullableFilter<"NoteVersion"> | string | null
    createdById?: StringNullableFilter<"NoteVersion"> | string | null
    createdAt?: DateTimeFilter<"NoteVersion"> | Date | string
    note?: XOR<NoteScalarRelationFilter, NoteWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NoteVersionOrderByWithRelationInput = {
    id?: SortOrder
    noteId?: SortOrder
    versionNumber?: SortOrder
    source?: SortOrder
    content?: SortOrder
    patientSummary?: SortOrder
    traceId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    note?: NoteOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type NoteVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    noteId_versionNumber?: NoteVersionNoteIdVersionNumberCompoundUniqueInput
    AND?: NoteVersionWhereInput | NoteVersionWhereInput[]
    OR?: NoteVersionWhereInput[]
    NOT?: NoteVersionWhereInput | NoteVersionWhereInput[]
    noteId?: StringFilter<"NoteVersion"> | string
    versionNumber?: IntFilter<"NoteVersion"> | number
    source?: StringFilter<"NoteVersion"> | string
    content?: StringFilter<"NoteVersion"> | string
    patientSummary?: StringFilter<"NoteVersion"> | string
    traceId?: StringNullableFilter<"NoteVersion"> | string | null
    createdById?: StringNullableFilter<"NoteVersion"> | string | null
    createdAt?: DateTimeFilter<"NoteVersion"> | Date | string
    note?: XOR<NoteScalarRelationFilter, NoteWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "noteId_versionNumber">

  export type NoteVersionOrderByWithAggregationInput = {
    id?: SortOrder
    noteId?: SortOrder
    versionNumber?: SortOrder
    source?: SortOrder
    content?: SortOrder
    patientSummary?: SortOrder
    traceId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NoteVersionCountOrderByAggregateInput
    _avg?: NoteVersionAvgOrderByAggregateInput
    _max?: NoteVersionMaxOrderByAggregateInput
    _min?: NoteVersionMinOrderByAggregateInput
    _sum?: NoteVersionSumOrderByAggregateInput
  }

  export type NoteVersionScalarWhereWithAggregatesInput = {
    AND?: NoteVersionScalarWhereWithAggregatesInput | NoteVersionScalarWhereWithAggregatesInput[]
    OR?: NoteVersionScalarWhereWithAggregatesInput[]
    NOT?: NoteVersionScalarWhereWithAggregatesInput | NoteVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NoteVersion"> | string
    noteId?: StringWithAggregatesFilter<"NoteVersion"> | string
    versionNumber?: IntWithAggregatesFilter<"NoteVersion"> | number
    source?: StringWithAggregatesFilter<"NoteVersion"> | string
    content?: StringWithAggregatesFilter<"NoteVersion"> | string
    patientSummary?: StringWithAggregatesFilter<"NoteVersion"> | string
    traceId?: StringNullableWithAggregatesFilter<"NoteVersion"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"NoteVersion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NoteVersion"> | Date | string
  }

  export type TranscriptSegmentWhereInput = {
    AND?: TranscriptSegmentWhereInput | TranscriptSegmentWhereInput[]
    OR?: TranscriptSegmentWhereInput[]
    NOT?: TranscriptSegmentWhereInput | TranscriptSegmentWhereInput[]
    id?: StringFilter<"TranscriptSegment"> | string
    encounterId?: StringFilter<"TranscriptSegment"> | string
    speaker?: StringFilter<"TranscriptSegment"> | string
    speakerLabel?: StringNullableFilter<"TranscriptSegment"> | string | null
    text?: StringFilter<"TranscriptSegment"> | string
    startMs?: IntFilter<"TranscriptSegment"> | number
    endMs?: IntFilter<"TranscriptSegment"> | number
    source?: EnumTranscriptSourceFilter<"TranscriptSegment"> | $Enums.TranscriptSource
    confidence?: FloatNullableFilter<"TranscriptSegment"> | number | null
    createdAt?: DateTimeFilter<"TranscriptSegment"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
  }

  export type TranscriptSegmentOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    speaker?: SortOrder
    speakerLabel?: SortOrderInput | SortOrder
    text?: SortOrder
    startMs?: SortOrder
    endMs?: SortOrder
    source?: SortOrder
    confidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
  }

  export type TranscriptSegmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TranscriptSegmentWhereInput | TranscriptSegmentWhereInput[]
    OR?: TranscriptSegmentWhereInput[]
    NOT?: TranscriptSegmentWhereInput | TranscriptSegmentWhereInput[]
    encounterId?: StringFilter<"TranscriptSegment"> | string
    speaker?: StringFilter<"TranscriptSegment"> | string
    speakerLabel?: StringNullableFilter<"TranscriptSegment"> | string | null
    text?: StringFilter<"TranscriptSegment"> | string
    startMs?: IntFilter<"TranscriptSegment"> | number
    endMs?: IntFilter<"TranscriptSegment"> | number
    source?: EnumTranscriptSourceFilter<"TranscriptSegment"> | $Enums.TranscriptSource
    confidence?: FloatNullableFilter<"TranscriptSegment"> | number | null
    createdAt?: DateTimeFilter<"TranscriptSegment"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
  }, "id">

  export type TranscriptSegmentOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    speaker?: SortOrder
    speakerLabel?: SortOrderInput | SortOrder
    text?: SortOrder
    startMs?: SortOrder
    endMs?: SortOrder
    source?: SortOrder
    confidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TranscriptSegmentCountOrderByAggregateInput
    _avg?: TranscriptSegmentAvgOrderByAggregateInput
    _max?: TranscriptSegmentMaxOrderByAggregateInput
    _min?: TranscriptSegmentMinOrderByAggregateInput
    _sum?: TranscriptSegmentSumOrderByAggregateInput
  }

  export type TranscriptSegmentScalarWhereWithAggregatesInput = {
    AND?: TranscriptSegmentScalarWhereWithAggregatesInput | TranscriptSegmentScalarWhereWithAggregatesInput[]
    OR?: TranscriptSegmentScalarWhereWithAggregatesInput[]
    NOT?: TranscriptSegmentScalarWhereWithAggregatesInput | TranscriptSegmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TranscriptSegment"> | string
    encounterId?: StringWithAggregatesFilter<"TranscriptSegment"> | string
    speaker?: StringWithAggregatesFilter<"TranscriptSegment"> | string
    speakerLabel?: StringNullableWithAggregatesFilter<"TranscriptSegment"> | string | null
    text?: StringWithAggregatesFilter<"TranscriptSegment"> | string
    startMs?: IntWithAggregatesFilter<"TranscriptSegment"> | number
    endMs?: IntWithAggregatesFilter<"TranscriptSegment"> | number
    source?: EnumTranscriptSourceWithAggregatesFilter<"TranscriptSegment"> | $Enums.TranscriptSource
    confidence?: FloatNullableWithAggregatesFilter<"TranscriptSegment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TranscriptSegment"> | Date | string
  }

  export type ChartAssetWhereInput = {
    AND?: ChartAssetWhereInput | ChartAssetWhereInput[]
    OR?: ChartAssetWhereInput[]
    NOT?: ChartAssetWhereInput | ChartAssetWhereInput[]
    id?: StringFilter<"ChartAsset"> | string
    appointmentId?: StringNullableFilter<"ChartAsset"> | string | null
    encounterId?: StringNullableFilter<"ChartAsset"> | string | null
    patientId?: StringNullableFilter<"ChartAsset"> | string | null
    fileName?: StringFilter<"ChartAsset"> | string
    mimeType?: StringFilter<"ChartAsset"> | string
    sizeBytes?: IntFilter<"ChartAsset"> | number
    storagePath?: StringFilter<"ChartAsset"> | string
    extractedJson?: JsonNullableFilter<"ChartAsset">
    rawText?: StringNullableFilter<"ChartAsset"> | string | null
    createdById?: StringNullableFilter<"ChartAsset"> | string | null
    createdAt?: DateTimeFilter<"ChartAsset"> | Date | string
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    encounter?: XOR<EncounterNullableScalarRelationFilter, EncounterWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ChartAssetOrderByWithRelationInput = {
    id?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    encounterId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    storagePath?: SortOrder
    extractedJson?: SortOrderInput | SortOrder
    rawText?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
    encounter?: EncounterOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type ChartAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChartAssetWhereInput | ChartAssetWhereInput[]
    OR?: ChartAssetWhereInput[]
    NOT?: ChartAssetWhereInput | ChartAssetWhereInput[]
    appointmentId?: StringNullableFilter<"ChartAsset"> | string | null
    encounterId?: StringNullableFilter<"ChartAsset"> | string | null
    patientId?: StringNullableFilter<"ChartAsset"> | string | null
    fileName?: StringFilter<"ChartAsset"> | string
    mimeType?: StringFilter<"ChartAsset"> | string
    sizeBytes?: IntFilter<"ChartAsset"> | number
    storagePath?: StringFilter<"ChartAsset"> | string
    extractedJson?: JsonNullableFilter<"ChartAsset">
    rawText?: StringNullableFilter<"ChartAsset"> | string | null
    createdById?: StringNullableFilter<"ChartAsset"> | string | null
    createdAt?: DateTimeFilter<"ChartAsset"> | Date | string
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    encounter?: XOR<EncounterNullableScalarRelationFilter, EncounterWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ChartAssetOrderByWithAggregationInput = {
    id?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    encounterId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    storagePath?: SortOrder
    extractedJson?: SortOrderInput | SortOrder
    rawText?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChartAssetCountOrderByAggregateInput
    _avg?: ChartAssetAvgOrderByAggregateInput
    _max?: ChartAssetMaxOrderByAggregateInput
    _min?: ChartAssetMinOrderByAggregateInput
    _sum?: ChartAssetSumOrderByAggregateInput
  }

  export type ChartAssetScalarWhereWithAggregatesInput = {
    AND?: ChartAssetScalarWhereWithAggregatesInput | ChartAssetScalarWhereWithAggregatesInput[]
    OR?: ChartAssetScalarWhereWithAggregatesInput[]
    NOT?: ChartAssetScalarWhereWithAggregatesInput | ChartAssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChartAsset"> | string
    appointmentId?: StringNullableWithAggregatesFilter<"ChartAsset"> | string | null
    encounterId?: StringNullableWithAggregatesFilter<"ChartAsset"> | string | null
    patientId?: StringNullableWithAggregatesFilter<"ChartAsset"> | string | null
    fileName?: StringWithAggregatesFilter<"ChartAsset"> | string
    mimeType?: StringWithAggregatesFilter<"ChartAsset"> | string
    sizeBytes?: IntWithAggregatesFilter<"ChartAsset"> | number
    storagePath?: StringWithAggregatesFilter<"ChartAsset"> | string
    extractedJson?: JsonNullableWithAggregatesFilter<"ChartAsset">
    rawText?: StringNullableWithAggregatesFilter<"ChartAsset"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"ChartAsset"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChartAsset"> | Date | string
  }

  export type SuggestionGenerationWhereInput = {
    AND?: SuggestionGenerationWhereInput | SuggestionGenerationWhereInput[]
    OR?: SuggestionGenerationWhereInput[]
    NOT?: SuggestionGenerationWhereInput | SuggestionGenerationWhereInput[]
    id?: StringFilter<"SuggestionGeneration"> | string
    encounterId?: StringFilter<"SuggestionGeneration"> | string
    trigger?: StringFilter<"SuggestionGeneration"> | string
    textDelta?: IntFilter<"SuggestionGeneration"> | number
    transcriptDelta?: IntFilter<"SuggestionGeneration"> | number
    inputHash?: StringNullableFilter<"SuggestionGeneration"> | string | null
    createdById?: StringNullableFilter<"SuggestionGeneration"> | string | null
    createdAt?: DateTimeFilter<"SuggestionGeneration"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    suggestions?: CodeSuggestionListRelationFilter
  }

  export type SuggestionGenerationOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    trigger?: SortOrder
    textDelta?: SortOrder
    transcriptDelta?: SortOrder
    inputHash?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    suggestions?: CodeSuggestionOrderByRelationAggregateInput
  }

  export type SuggestionGenerationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SuggestionGenerationWhereInput | SuggestionGenerationWhereInput[]
    OR?: SuggestionGenerationWhereInput[]
    NOT?: SuggestionGenerationWhereInput | SuggestionGenerationWhereInput[]
    encounterId?: StringFilter<"SuggestionGeneration"> | string
    trigger?: StringFilter<"SuggestionGeneration"> | string
    textDelta?: IntFilter<"SuggestionGeneration"> | number
    transcriptDelta?: IntFilter<"SuggestionGeneration"> | number
    inputHash?: StringNullableFilter<"SuggestionGeneration"> | string | null
    createdById?: StringNullableFilter<"SuggestionGeneration"> | string | null
    createdAt?: DateTimeFilter<"SuggestionGeneration"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    suggestions?: CodeSuggestionListRelationFilter
  }, "id">

  export type SuggestionGenerationOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    trigger?: SortOrder
    textDelta?: SortOrder
    transcriptDelta?: SortOrder
    inputHash?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SuggestionGenerationCountOrderByAggregateInput
    _avg?: SuggestionGenerationAvgOrderByAggregateInput
    _max?: SuggestionGenerationMaxOrderByAggregateInput
    _min?: SuggestionGenerationMinOrderByAggregateInput
    _sum?: SuggestionGenerationSumOrderByAggregateInput
  }

  export type SuggestionGenerationScalarWhereWithAggregatesInput = {
    AND?: SuggestionGenerationScalarWhereWithAggregatesInput | SuggestionGenerationScalarWhereWithAggregatesInput[]
    OR?: SuggestionGenerationScalarWhereWithAggregatesInput[]
    NOT?: SuggestionGenerationScalarWhereWithAggregatesInput | SuggestionGenerationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SuggestionGeneration"> | string
    encounterId?: StringWithAggregatesFilter<"SuggestionGeneration"> | string
    trigger?: StringWithAggregatesFilter<"SuggestionGeneration"> | string
    textDelta?: IntWithAggregatesFilter<"SuggestionGeneration"> | number
    transcriptDelta?: IntWithAggregatesFilter<"SuggestionGeneration"> | number
    inputHash?: StringNullableWithAggregatesFilter<"SuggestionGeneration"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"SuggestionGeneration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SuggestionGeneration"> | Date | string
  }

  export type CodeSuggestionWhereInput = {
    AND?: CodeSuggestionWhereInput | CodeSuggestionWhereInput[]
    OR?: CodeSuggestionWhereInput[]
    NOT?: CodeSuggestionWhereInput | CodeSuggestionWhereInput[]
    id?: StringFilter<"CodeSuggestion"> | string
    encounterId?: StringFilter<"CodeSuggestion"> | string
    generationId?: StringFilter<"CodeSuggestion"> | string
    code?: StringFilter<"CodeSuggestion"> | string
    codeType?: StringFilter<"CodeSuggestion"> | string
    category?: EnumSuggestionCategoryFilter<"CodeSuggestion"> | $Enums.SuggestionCategory
    title?: StringFilter<"CodeSuggestion"> | string
    description?: StringFilter<"CodeSuggestion"> | string
    rationale?: StringFilter<"CodeSuggestion"> | string
    confidence?: FloatFilter<"CodeSuggestion"> | number
    evidence?: JsonNullableFilter<"CodeSuggestion">
    status?: EnumSuggestionStatusFilter<"CodeSuggestion"> | $Enums.SuggestionStatus
    recommended?: BoolFilter<"CodeSuggestion"> | boolean
    metadata?: JsonNullableFilter<"CodeSuggestion">
    createdAt?: DateTimeFilter<"CodeSuggestion"> | Date | string
    updatedAt?: DateTimeFilter<"CodeSuggestion"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    generation?: XOR<SuggestionGenerationScalarRelationFilter, SuggestionGenerationWhereInput>
    selections?: CodeSelectionListRelationFilter
  }

  export type CodeSuggestionOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    generationId?: SortOrder
    code?: SortOrder
    codeType?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    confidence?: SortOrder
    evidence?: SortOrderInput | SortOrder
    status?: SortOrder
    recommended?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    generation?: SuggestionGenerationOrderByWithRelationInput
    selections?: CodeSelectionOrderByRelationAggregateInput
  }

  export type CodeSuggestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CodeSuggestionWhereInput | CodeSuggestionWhereInput[]
    OR?: CodeSuggestionWhereInput[]
    NOT?: CodeSuggestionWhereInput | CodeSuggestionWhereInput[]
    encounterId?: StringFilter<"CodeSuggestion"> | string
    generationId?: StringFilter<"CodeSuggestion"> | string
    code?: StringFilter<"CodeSuggestion"> | string
    codeType?: StringFilter<"CodeSuggestion"> | string
    category?: EnumSuggestionCategoryFilter<"CodeSuggestion"> | $Enums.SuggestionCategory
    title?: StringFilter<"CodeSuggestion"> | string
    description?: StringFilter<"CodeSuggestion"> | string
    rationale?: StringFilter<"CodeSuggestion"> | string
    confidence?: FloatFilter<"CodeSuggestion"> | number
    evidence?: JsonNullableFilter<"CodeSuggestion">
    status?: EnumSuggestionStatusFilter<"CodeSuggestion"> | $Enums.SuggestionStatus
    recommended?: BoolFilter<"CodeSuggestion"> | boolean
    metadata?: JsonNullableFilter<"CodeSuggestion">
    createdAt?: DateTimeFilter<"CodeSuggestion"> | Date | string
    updatedAt?: DateTimeFilter<"CodeSuggestion"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    generation?: XOR<SuggestionGenerationScalarRelationFilter, SuggestionGenerationWhereInput>
    selections?: CodeSelectionListRelationFilter
  }, "id">

  export type CodeSuggestionOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    generationId?: SortOrder
    code?: SortOrder
    codeType?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    confidence?: SortOrder
    evidence?: SortOrderInput | SortOrder
    status?: SortOrder
    recommended?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CodeSuggestionCountOrderByAggregateInput
    _avg?: CodeSuggestionAvgOrderByAggregateInput
    _max?: CodeSuggestionMaxOrderByAggregateInput
    _min?: CodeSuggestionMinOrderByAggregateInput
    _sum?: CodeSuggestionSumOrderByAggregateInput
  }

  export type CodeSuggestionScalarWhereWithAggregatesInput = {
    AND?: CodeSuggestionScalarWhereWithAggregatesInput | CodeSuggestionScalarWhereWithAggregatesInput[]
    OR?: CodeSuggestionScalarWhereWithAggregatesInput[]
    NOT?: CodeSuggestionScalarWhereWithAggregatesInput | CodeSuggestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CodeSuggestion"> | string
    encounterId?: StringWithAggregatesFilter<"CodeSuggestion"> | string
    generationId?: StringWithAggregatesFilter<"CodeSuggestion"> | string
    code?: StringWithAggregatesFilter<"CodeSuggestion"> | string
    codeType?: StringWithAggregatesFilter<"CodeSuggestion"> | string
    category?: EnumSuggestionCategoryWithAggregatesFilter<"CodeSuggestion"> | $Enums.SuggestionCategory
    title?: StringWithAggregatesFilter<"CodeSuggestion"> | string
    description?: StringWithAggregatesFilter<"CodeSuggestion"> | string
    rationale?: StringWithAggregatesFilter<"CodeSuggestion"> | string
    confidence?: FloatWithAggregatesFilter<"CodeSuggestion"> | number
    evidence?: JsonNullableWithAggregatesFilter<"CodeSuggestion">
    status?: EnumSuggestionStatusWithAggregatesFilter<"CodeSuggestion"> | $Enums.SuggestionStatus
    recommended?: BoolWithAggregatesFilter<"CodeSuggestion"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"CodeSuggestion">
    createdAt?: DateTimeWithAggregatesFilter<"CodeSuggestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CodeSuggestion"> | Date | string
  }

  export type CodeSelectionWhereInput = {
    AND?: CodeSelectionWhereInput | CodeSelectionWhereInput[]
    OR?: CodeSelectionWhereInput[]
    NOT?: CodeSelectionWhereInput | CodeSelectionWhereInput[]
    id?: StringFilter<"CodeSelection"> | string
    encounterId?: StringFilter<"CodeSelection"> | string
    codeSuggestionId?: StringNullableFilter<"CodeSelection"> | string | null
    code?: StringFilter<"CodeSelection"> | string
    codeType?: StringFilter<"CodeSelection"> | string
    category?: EnumSuggestionCategoryFilter<"CodeSelection"> | $Enums.SuggestionCategory
    action?: EnumSelectionActionFilter<"CodeSelection"> | $Enums.SelectionAction
    decisionReason?: StringNullableFilter<"CodeSelection"> | string | null
    actorId?: StringNullableFilter<"CodeSelection"> | string | null
    createdAt?: DateTimeFilter<"CodeSelection"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    codeSuggestion?: XOR<CodeSuggestionNullableScalarRelationFilter, CodeSuggestionWhereInput> | null
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CodeSelectionOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    codeSuggestionId?: SortOrderInput | SortOrder
    code?: SortOrder
    codeType?: SortOrder
    category?: SortOrder
    action?: SortOrder
    decisionReason?: SortOrderInput | SortOrder
    actorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    codeSuggestion?: CodeSuggestionOrderByWithRelationInput
    actor?: UserOrderByWithRelationInput
  }

  export type CodeSelectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CodeSelectionWhereInput | CodeSelectionWhereInput[]
    OR?: CodeSelectionWhereInput[]
    NOT?: CodeSelectionWhereInput | CodeSelectionWhereInput[]
    encounterId?: StringFilter<"CodeSelection"> | string
    codeSuggestionId?: StringNullableFilter<"CodeSelection"> | string | null
    code?: StringFilter<"CodeSelection"> | string
    codeType?: StringFilter<"CodeSelection"> | string
    category?: EnumSuggestionCategoryFilter<"CodeSelection"> | $Enums.SuggestionCategory
    action?: EnumSelectionActionFilter<"CodeSelection"> | $Enums.SelectionAction
    decisionReason?: StringNullableFilter<"CodeSelection"> | string | null
    actorId?: StringNullableFilter<"CodeSelection"> | string | null
    createdAt?: DateTimeFilter<"CodeSelection"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    codeSuggestion?: XOR<CodeSuggestionNullableScalarRelationFilter, CodeSuggestionWhereInput> | null
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type CodeSelectionOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    codeSuggestionId?: SortOrderInput | SortOrder
    code?: SortOrder
    codeType?: SortOrder
    category?: SortOrder
    action?: SortOrder
    decisionReason?: SortOrderInput | SortOrder
    actorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CodeSelectionCountOrderByAggregateInput
    _max?: CodeSelectionMaxOrderByAggregateInput
    _min?: CodeSelectionMinOrderByAggregateInput
  }

  export type CodeSelectionScalarWhereWithAggregatesInput = {
    AND?: CodeSelectionScalarWhereWithAggregatesInput | CodeSelectionScalarWhereWithAggregatesInput[]
    OR?: CodeSelectionScalarWhereWithAggregatesInput[]
    NOT?: CodeSelectionScalarWhereWithAggregatesInput | CodeSelectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CodeSelection"> | string
    encounterId?: StringWithAggregatesFilter<"CodeSelection"> | string
    codeSuggestionId?: StringNullableWithAggregatesFilter<"CodeSelection"> | string | null
    code?: StringWithAggregatesFilter<"CodeSelection"> | string
    codeType?: StringWithAggregatesFilter<"CodeSelection"> | string
    category?: EnumSuggestionCategoryWithAggregatesFilter<"CodeSelection"> | $Enums.SuggestionCategory
    action?: EnumSelectionActionWithAggregatesFilter<"CodeSelection"> | $Enums.SelectionAction
    decisionReason?: StringNullableWithAggregatesFilter<"CodeSelection"> | string | null
    actorId?: StringNullableWithAggregatesFilter<"CodeSelection"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CodeSelection"> | Date | string
  }

  export type ComplianceIssueWhereInput = {
    AND?: ComplianceIssueWhereInput | ComplianceIssueWhereInput[]
    OR?: ComplianceIssueWhereInput[]
    NOT?: ComplianceIssueWhereInput | ComplianceIssueWhereInput[]
    id?: StringFilter<"ComplianceIssue"> | string
    encounterId?: StringFilter<"ComplianceIssue"> | string
    severity?: EnumComplianceSeverityFilter<"ComplianceIssue"> | $Enums.ComplianceSeverity
    status?: EnumComplianceStatusFilter<"ComplianceIssue"> | $Enums.ComplianceStatus
    title?: StringFilter<"ComplianceIssue"> | string
    description?: StringFilter<"ComplianceIssue"> | string
    rationale?: StringFilter<"ComplianceIssue"> | string
    remediation?: StringFilter<"ComplianceIssue"> | string
    evidence?: JsonNullableFilter<"ComplianceIssue">
    fingerprint?: StringFilter<"ComplianceIssue"> | string
    actorId?: StringNullableFilter<"ComplianceIssue"> | string | null
    resolvedAt?: DateTimeNullableFilter<"ComplianceIssue"> | Date | string | null
    dismissedAt?: DateTimeNullableFilter<"ComplianceIssue"> | Date | string | null
    createdAt?: DateTimeFilter<"ComplianceIssue"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceIssue"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ComplianceIssueOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    remediation?: SortOrder
    evidence?: SortOrderInput | SortOrder
    fingerprint?: SortOrder
    actorId?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    dismissedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    actor?: UserOrderByWithRelationInput
  }

  export type ComplianceIssueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    encounterId_fingerprint?: ComplianceIssueEncounterIdFingerprintCompoundUniqueInput
    AND?: ComplianceIssueWhereInput | ComplianceIssueWhereInput[]
    OR?: ComplianceIssueWhereInput[]
    NOT?: ComplianceIssueWhereInput | ComplianceIssueWhereInput[]
    encounterId?: StringFilter<"ComplianceIssue"> | string
    severity?: EnumComplianceSeverityFilter<"ComplianceIssue"> | $Enums.ComplianceSeverity
    status?: EnumComplianceStatusFilter<"ComplianceIssue"> | $Enums.ComplianceStatus
    title?: StringFilter<"ComplianceIssue"> | string
    description?: StringFilter<"ComplianceIssue"> | string
    rationale?: StringFilter<"ComplianceIssue"> | string
    remediation?: StringFilter<"ComplianceIssue"> | string
    evidence?: JsonNullableFilter<"ComplianceIssue">
    fingerprint?: StringFilter<"ComplianceIssue"> | string
    actorId?: StringNullableFilter<"ComplianceIssue"> | string | null
    resolvedAt?: DateTimeNullableFilter<"ComplianceIssue"> | Date | string | null
    dismissedAt?: DateTimeNullableFilter<"ComplianceIssue"> | Date | string | null
    createdAt?: DateTimeFilter<"ComplianceIssue"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceIssue"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "encounterId_fingerprint">

  export type ComplianceIssueOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    remediation?: SortOrder
    evidence?: SortOrderInput | SortOrder
    fingerprint?: SortOrder
    actorId?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    dismissedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComplianceIssueCountOrderByAggregateInput
    _max?: ComplianceIssueMaxOrderByAggregateInput
    _min?: ComplianceIssueMinOrderByAggregateInput
  }

  export type ComplianceIssueScalarWhereWithAggregatesInput = {
    AND?: ComplianceIssueScalarWhereWithAggregatesInput | ComplianceIssueScalarWhereWithAggregatesInput[]
    OR?: ComplianceIssueScalarWhereWithAggregatesInput[]
    NOT?: ComplianceIssueScalarWhereWithAggregatesInput | ComplianceIssueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComplianceIssue"> | string
    encounterId?: StringWithAggregatesFilter<"ComplianceIssue"> | string
    severity?: EnumComplianceSeverityWithAggregatesFilter<"ComplianceIssue"> | $Enums.ComplianceSeverity
    status?: EnumComplianceStatusWithAggregatesFilter<"ComplianceIssue"> | $Enums.ComplianceStatus
    title?: StringWithAggregatesFilter<"ComplianceIssue"> | string
    description?: StringWithAggregatesFilter<"ComplianceIssue"> | string
    rationale?: StringWithAggregatesFilter<"ComplianceIssue"> | string
    remediation?: StringWithAggregatesFilter<"ComplianceIssue"> | string
    evidence?: JsonNullableWithAggregatesFilter<"ComplianceIssue">
    fingerprint?: StringWithAggregatesFilter<"ComplianceIssue"> | string
    actorId?: StringNullableWithAggregatesFilter<"ComplianceIssue"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"ComplianceIssue"> | Date | string | null
    dismissedAt?: DateTimeNullableWithAggregatesFilter<"ComplianceIssue"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ComplianceIssue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComplianceIssue"> | Date | string
  }

  export type WizardRunWhereInput = {
    AND?: WizardRunWhereInput | WizardRunWhereInput[]
    OR?: WizardRunWhereInput[]
    NOT?: WizardRunWhereInput | WizardRunWhereInput[]
    id?: StringFilter<"WizardRun"> | string
    encounterId?: StringFilter<"WizardRun"> | string
    status?: EnumWizardRunStatusFilter<"WizardRun"> | $Enums.WizardRunStatus
    runState?: JsonNullableFilter<"WizardRun">
    startedAt?: DateTimeFilter<"WizardRun"> | Date | string
    completedAt?: DateTimeNullableFilter<"WizardRun"> | Date | string | null
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    stepStates?: WizardStepStateListRelationFilter
  }

  export type WizardRunOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    status?: SortOrder
    runState?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    encounter?: EncounterOrderByWithRelationInput
    stepStates?: WizardStepStateOrderByRelationAggregateInput
  }

  export type WizardRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WizardRunWhereInput | WizardRunWhereInput[]
    OR?: WizardRunWhereInput[]
    NOT?: WizardRunWhereInput | WizardRunWhereInput[]
    encounterId?: StringFilter<"WizardRun"> | string
    status?: EnumWizardRunStatusFilter<"WizardRun"> | $Enums.WizardRunStatus
    runState?: JsonNullableFilter<"WizardRun">
    startedAt?: DateTimeFilter<"WizardRun"> | Date | string
    completedAt?: DateTimeNullableFilter<"WizardRun"> | Date | string | null
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    stepStates?: WizardStepStateListRelationFilter
  }, "id">

  export type WizardRunOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    status?: SortOrder
    runState?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: WizardRunCountOrderByAggregateInput
    _max?: WizardRunMaxOrderByAggregateInput
    _min?: WizardRunMinOrderByAggregateInput
  }

  export type WizardRunScalarWhereWithAggregatesInput = {
    AND?: WizardRunScalarWhereWithAggregatesInput | WizardRunScalarWhereWithAggregatesInput[]
    OR?: WizardRunScalarWhereWithAggregatesInput[]
    NOT?: WizardRunScalarWhereWithAggregatesInput | WizardRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WizardRun"> | string
    encounterId?: StringWithAggregatesFilter<"WizardRun"> | string
    status?: EnumWizardRunStatusWithAggregatesFilter<"WizardRun"> | $Enums.WizardRunStatus
    runState?: JsonNullableWithAggregatesFilter<"WizardRun">
    startedAt?: DateTimeWithAggregatesFilter<"WizardRun"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"WizardRun"> | Date | string | null
  }

  export type WizardStepStateWhereInput = {
    AND?: WizardStepStateWhereInput | WizardStepStateWhereInput[]
    OR?: WizardStepStateWhereInput[]
    NOT?: WizardStepStateWhereInput | WizardStepStateWhereInput[]
    id?: StringFilter<"WizardStepState"> | string
    wizardRunId?: StringFilter<"WizardStepState"> | string
    encounterId?: StringFilter<"WizardStepState"> | string
    step?: EnumWizardStepFilter<"WizardStepState"> | $Enums.WizardStep
    status?: EnumWizardStepStatusFilter<"WizardStepState"> | $Enums.WizardStepStatus
    payload?: JsonNullableFilter<"WizardStepState">
    lastActorId?: StringNullableFilter<"WizardStepState"> | string | null
    createdAt?: DateTimeFilter<"WizardStepState"> | Date | string
    updatedAt?: DateTimeFilter<"WizardStepState"> | Date | string
    wizardRun?: XOR<WizardRunScalarRelationFilter, WizardRunWhereInput>
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    lastActor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type WizardStepStateOrderByWithRelationInput = {
    id?: SortOrder
    wizardRunId?: SortOrder
    encounterId?: SortOrder
    step?: SortOrder
    status?: SortOrder
    payload?: SortOrderInput | SortOrder
    lastActorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wizardRun?: WizardRunOrderByWithRelationInput
    encounter?: EncounterOrderByWithRelationInput
    lastActor?: UserOrderByWithRelationInput
  }

  export type WizardStepStateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    wizardRunId_step?: WizardStepStateWizardRunIdStepCompoundUniqueInput
    AND?: WizardStepStateWhereInput | WizardStepStateWhereInput[]
    OR?: WizardStepStateWhereInput[]
    NOT?: WizardStepStateWhereInput | WizardStepStateWhereInput[]
    wizardRunId?: StringFilter<"WizardStepState"> | string
    encounterId?: StringFilter<"WizardStepState"> | string
    step?: EnumWizardStepFilter<"WizardStepState"> | $Enums.WizardStep
    status?: EnumWizardStepStatusFilter<"WizardStepState"> | $Enums.WizardStepStatus
    payload?: JsonNullableFilter<"WizardStepState">
    lastActorId?: StringNullableFilter<"WizardStepState"> | string | null
    createdAt?: DateTimeFilter<"WizardStepState"> | Date | string
    updatedAt?: DateTimeFilter<"WizardStepState"> | Date | string
    wizardRun?: XOR<WizardRunScalarRelationFilter, WizardRunWhereInput>
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    lastActor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "wizardRunId_step">

  export type WizardStepStateOrderByWithAggregationInput = {
    id?: SortOrder
    wizardRunId?: SortOrder
    encounterId?: SortOrder
    step?: SortOrder
    status?: SortOrder
    payload?: SortOrderInput | SortOrder
    lastActorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WizardStepStateCountOrderByAggregateInput
    _max?: WizardStepStateMaxOrderByAggregateInput
    _min?: WizardStepStateMinOrderByAggregateInput
  }

  export type WizardStepStateScalarWhereWithAggregatesInput = {
    AND?: WizardStepStateScalarWhereWithAggregatesInput | WizardStepStateScalarWhereWithAggregatesInput[]
    OR?: WizardStepStateScalarWhereWithAggregatesInput[]
    NOT?: WizardStepStateScalarWhereWithAggregatesInput | WizardStepStateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WizardStepState"> | string
    wizardRunId?: StringWithAggregatesFilter<"WizardStepState"> | string
    encounterId?: StringWithAggregatesFilter<"WizardStepState"> | string
    step?: EnumWizardStepWithAggregatesFilter<"WizardStepState"> | $Enums.WizardStep
    status?: EnumWizardStepStatusWithAggregatesFilter<"WizardStepState"> | $Enums.WizardStepStatus
    payload?: JsonNullableWithAggregatesFilter<"WizardStepState">
    lastActorId?: StringNullableWithAggregatesFilter<"WizardStepState"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WizardStepState"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WizardStepState"> | Date | string
  }

  export type ExportArtifactWhereInput = {
    AND?: ExportArtifactWhereInput | ExportArtifactWhereInput[]
    OR?: ExportArtifactWhereInput[]
    NOT?: ExportArtifactWhereInput | ExportArtifactWhereInput[]
    id?: StringFilter<"ExportArtifact"> | string
    encounterId?: StringFilter<"ExportArtifact"> | string
    noteId?: StringNullableFilter<"ExportArtifact"> | string | null
    type?: EnumArtifactTypeFilter<"ExportArtifact"> | $Enums.ArtifactType
    filePath?: StringFilter<"ExportArtifact"> | string
    mimeType?: StringFilter<"ExportArtifact"> | string
    fileName?: StringFilter<"ExportArtifact"> | string
    sizeBytes?: IntFilter<"ExportArtifact"> | number
    createdById?: StringNullableFilter<"ExportArtifact"> | string | null
    createdAt?: DateTimeFilter<"ExportArtifact"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    note?: XOR<NoteNullableScalarRelationFilter, NoteWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ExportArtifactOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    noteId?: SortOrderInput | SortOrder
    type?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileName?: SortOrder
    sizeBytes?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    note?: NoteOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type ExportArtifactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExportArtifactWhereInput | ExportArtifactWhereInput[]
    OR?: ExportArtifactWhereInput[]
    NOT?: ExportArtifactWhereInput | ExportArtifactWhereInput[]
    encounterId?: StringFilter<"ExportArtifact"> | string
    noteId?: StringNullableFilter<"ExportArtifact"> | string | null
    type?: EnumArtifactTypeFilter<"ExportArtifact"> | $Enums.ArtifactType
    filePath?: StringFilter<"ExportArtifact"> | string
    mimeType?: StringFilter<"ExportArtifact"> | string
    fileName?: StringFilter<"ExportArtifact"> | string
    sizeBytes?: IntFilter<"ExportArtifact"> | number
    createdById?: StringNullableFilter<"ExportArtifact"> | string | null
    createdAt?: DateTimeFilter<"ExportArtifact"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    note?: XOR<NoteNullableScalarRelationFilter, NoteWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ExportArtifactOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    noteId?: SortOrderInput | SortOrder
    type?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileName?: SortOrder
    sizeBytes?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ExportArtifactCountOrderByAggregateInput
    _avg?: ExportArtifactAvgOrderByAggregateInput
    _max?: ExportArtifactMaxOrderByAggregateInput
    _min?: ExportArtifactMinOrderByAggregateInput
    _sum?: ExportArtifactSumOrderByAggregateInput
  }

  export type ExportArtifactScalarWhereWithAggregatesInput = {
    AND?: ExportArtifactScalarWhereWithAggregatesInput | ExportArtifactScalarWhereWithAggregatesInput[]
    OR?: ExportArtifactScalarWhereWithAggregatesInput[]
    NOT?: ExportArtifactScalarWhereWithAggregatesInput | ExportArtifactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExportArtifact"> | string
    encounterId?: StringWithAggregatesFilter<"ExportArtifact"> | string
    noteId?: StringNullableWithAggregatesFilter<"ExportArtifact"> | string | null
    type?: EnumArtifactTypeWithAggregatesFilter<"ExportArtifact"> | $Enums.ArtifactType
    filePath?: StringWithAggregatesFilter<"ExportArtifact"> | string
    mimeType?: StringWithAggregatesFilter<"ExportArtifact"> | string
    fileName?: StringWithAggregatesFilter<"ExportArtifact"> | string
    sizeBytes?: IntWithAggregatesFilter<"ExportArtifact"> | number
    createdById?: StringNullableWithAggregatesFilter<"ExportArtifact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExportArtifact"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    encounterId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    encounter?: XOR<EncounterNullableScalarRelationFilter, EncounterWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorId?: SortOrderInput | SortOrder
    encounterId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actor?: UserOrderByWithRelationInput
    encounter?: EncounterOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    encounterId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    encounter?: XOR<EncounterNullableScalarRelationFilter, EncounterWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorId?: SortOrderInput | SortOrder
    encounterId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    actorId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    encounterId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    ip?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type AuthSessionWhereInput = {
    AND?: AuthSessionWhereInput | AuthSessionWhereInput[]
    OR?: AuthSessionWhereInput[]
    NOT?: AuthSessionWhereInput | AuthSessionWhereInput[]
    id?: StringFilter<"AuthSession"> | string
    userId?: StringFilter<"AuthSession"> | string
    refreshTokenHash?: StringFilter<"AuthSession"> | string
    expiresAt?: DateTimeFilter<"AuthSession"> | Date | string
    revokedAt?: DateTimeNullableFilter<"AuthSession"> | Date | string | null
    ip?: StringNullableFilter<"AuthSession"> | string | null
    userAgent?: StringNullableFilter<"AuthSession"> | string | null
    createdAt?: DateTimeFilter<"AuthSession"> | Date | string
    updatedAt?: DateTimeFilter<"AuthSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuthSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuthSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refreshTokenHash?: string
    AND?: AuthSessionWhereInput | AuthSessionWhereInput[]
    OR?: AuthSessionWhereInput[]
    NOT?: AuthSessionWhereInput | AuthSessionWhereInput[]
    userId?: StringFilter<"AuthSession"> | string
    expiresAt?: DateTimeFilter<"AuthSession"> | Date | string
    revokedAt?: DateTimeNullableFilter<"AuthSession"> | Date | string | null
    ip?: StringNullableFilter<"AuthSession"> | string | null
    userAgent?: StringNullableFilter<"AuthSession"> | string | null
    createdAt?: DateTimeFilter<"AuthSession"> | Date | string
    updatedAt?: DateTimeFilter<"AuthSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "refreshTokenHash">

  export type AuthSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuthSessionCountOrderByAggregateInput
    _max?: AuthSessionMaxOrderByAggregateInput
    _min?: AuthSessionMinOrderByAggregateInput
  }

  export type AuthSessionScalarWhereWithAggregatesInput = {
    AND?: AuthSessionScalarWhereWithAggregatesInput | AuthSessionScalarWhereWithAggregatesInput[]
    OR?: AuthSessionScalarWhereWithAggregatesInput[]
    NOT?: AuthSessionScalarWhereWithAggregatesInput | AuthSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuthSession"> | string
    userId?: StringWithAggregatesFilter<"AuthSession"> | string
    refreshTokenHash?: StringWithAggregatesFilter<"AuthSession"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"AuthSession"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"AuthSession"> | Date | string | null
    ip?: StringNullableWithAggregatesFilter<"AuthSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuthSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuthSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuthSession"> | Date | string
  }

  export type DispatchJobWhereInput = {
    AND?: DispatchJobWhereInput | DispatchJobWhereInput[]
    OR?: DispatchJobWhereInput[]
    NOT?: DispatchJobWhereInput | DispatchJobWhereInput[]
    id?: StringFilter<"DispatchJob"> | string
    encounterId?: StringFilter<"DispatchJob"> | string
    noteId?: StringNullableFilter<"DispatchJob"> | string | null
    target?: EnumDispatchTargetFilter<"DispatchJob"> | $Enums.DispatchTarget
    status?: EnumDispatchStatusFilter<"DispatchJob"> | $Enums.DispatchStatus
    contractType?: StringNullableFilter<"DispatchJob"> | string | null
    attemptCount?: IntFilter<"DispatchJob"> | number
    maxAttempts?: IntFilter<"DispatchJob"> | number
    nextRetryAt?: DateTimeNullableFilter<"DispatchJob"> | Date | string | null
    dispatchedAt?: DateTimeNullableFilter<"DispatchJob"> | Date | string | null
    deadLetteredAt?: DateTimeNullableFilter<"DispatchJob"> | Date | string | null
    externalMessageId?: StringNullableFilter<"DispatchJob"> | string | null
    lastError?: StringNullableFilter<"DispatchJob"> | string | null
    payload?: JsonFilter<"DispatchJob">
    response?: JsonNullableFilter<"DispatchJob">
    createdById?: StringNullableFilter<"DispatchJob"> | string | null
    createdAt?: DateTimeFilter<"DispatchJob"> | Date | string
    updatedAt?: DateTimeFilter<"DispatchJob"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    note?: XOR<NoteNullableScalarRelationFilter, NoteWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DispatchJobOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    noteId?: SortOrderInput | SortOrder
    target?: SortOrder
    status?: SortOrder
    contractType?: SortOrderInput | SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    dispatchedAt?: SortOrderInput | SortOrder
    deadLetteredAt?: SortOrderInput | SortOrder
    externalMessageId?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    payload?: SortOrder
    response?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    note?: NoteOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type DispatchJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DispatchJobWhereInput | DispatchJobWhereInput[]
    OR?: DispatchJobWhereInput[]
    NOT?: DispatchJobWhereInput | DispatchJobWhereInput[]
    encounterId?: StringFilter<"DispatchJob"> | string
    noteId?: StringNullableFilter<"DispatchJob"> | string | null
    target?: EnumDispatchTargetFilter<"DispatchJob"> | $Enums.DispatchTarget
    status?: EnumDispatchStatusFilter<"DispatchJob"> | $Enums.DispatchStatus
    contractType?: StringNullableFilter<"DispatchJob"> | string | null
    attemptCount?: IntFilter<"DispatchJob"> | number
    maxAttempts?: IntFilter<"DispatchJob"> | number
    nextRetryAt?: DateTimeNullableFilter<"DispatchJob"> | Date | string | null
    dispatchedAt?: DateTimeNullableFilter<"DispatchJob"> | Date | string | null
    deadLetteredAt?: DateTimeNullableFilter<"DispatchJob"> | Date | string | null
    externalMessageId?: StringNullableFilter<"DispatchJob"> | string | null
    lastError?: StringNullableFilter<"DispatchJob"> | string | null
    payload?: JsonFilter<"DispatchJob">
    response?: JsonNullableFilter<"DispatchJob">
    createdById?: StringNullableFilter<"DispatchJob"> | string | null
    createdAt?: DateTimeFilter<"DispatchJob"> | Date | string
    updatedAt?: DateTimeFilter<"DispatchJob"> | Date | string
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    note?: XOR<NoteNullableScalarRelationFilter, NoteWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type DispatchJobOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    noteId?: SortOrderInput | SortOrder
    target?: SortOrder
    status?: SortOrder
    contractType?: SortOrderInput | SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    dispatchedAt?: SortOrderInput | SortOrder
    deadLetteredAt?: SortOrderInput | SortOrder
    externalMessageId?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    payload?: SortOrder
    response?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DispatchJobCountOrderByAggregateInput
    _avg?: DispatchJobAvgOrderByAggregateInput
    _max?: DispatchJobMaxOrderByAggregateInput
    _min?: DispatchJobMinOrderByAggregateInput
    _sum?: DispatchJobSumOrderByAggregateInput
  }

  export type DispatchJobScalarWhereWithAggregatesInput = {
    AND?: DispatchJobScalarWhereWithAggregatesInput | DispatchJobScalarWhereWithAggregatesInput[]
    OR?: DispatchJobScalarWhereWithAggregatesInput[]
    NOT?: DispatchJobScalarWhereWithAggregatesInput | DispatchJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DispatchJob"> | string
    encounterId?: StringWithAggregatesFilter<"DispatchJob"> | string
    noteId?: StringNullableWithAggregatesFilter<"DispatchJob"> | string | null
    target?: EnumDispatchTargetWithAggregatesFilter<"DispatchJob"> | $Enums.DispatchTarget
    status?: EnumDispatchStatusWithAggregatesFilter<"DispatchJob"> | $Enums.DispatchStatus
    contractType?: StringNullableWithAggregatesFilter<"DispatchJob"> | string | null
    attemptCount?: IntWithAggregatesFilter<"DispatchJob"> | number
    maxAttempts?: IntWithAggregatesFilter<"DispatchJob"> | number
    nextRetryAt?: DateTimeNullableWithAggregatesFilter<"DispatchJob"> | Date | string | null
    dispatchedAt?: DateTimeNullableWithAggregatesFilter<"DispatchJob"> | Date | string | null
    deadLetteredAt?: DateTimeNullableWithAggregatesFilter<"DispatchJob"> | Date | string | null
    externalMessageId?: StringNullableWithAggregatesFilter<"DispatchJob"> | string | null
    lastError?: StringNullableWithAggregatesFilter<"DispatchJob"> | string | null
    payload?: JsonWithAggregatesFilter<"DispatchJob">
    response?: JsonNullableWithAggregatesFilter<"DispatchJob">
    createdById?: StringNullableWithAggregatesFilter<"DispatchJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DispatchJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DispatchJob"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateInput = {
    id?: string
    payload: JsonNullValueInput | InputJsonValue
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    payload: JsonNullValueInput | InputJsonValue
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateManyInput = {
    id?: string
    userId: string
    payload: JsonNullValueInput | InputJsonValue
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    id?: string
    externalId: string
    firstName: string
    lastName: string
    dateOfBirth?: Date | string | null
    email?: string | null
    phone?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    encounters?: EncounterCreateNestedManyWithoutPatientInput
    chartAssets?: ChartAssetCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    externalId: string
    firstName: string
    lastName: string
    dateOfBirth?: Date | string | null
    email?: string | null
    phone?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    externalId: string
    firstName: string
    lastName: string
    dateOfBirth?: Date | string | null
    email?: string | null
    phone?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    id?: string
    externalId: string
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    provider?: UserCreateNestedOneWithoutAppointmentsProvidedInput
    createdBy?: UserCreateNestedOneWithoutAppointmentsCreatedInput
    encounter?: EncounterCreateNestedOneWithoutAppointmentInput
    chartAssets?: ChartAssetCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    externalId: string
    patientId: string
    providerId?: string | null
    createdById?: string | null
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter?: EncounterUncheckedCreateNestedOneWithoutAppointmentInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    provider?: UserUpdateOneWithoutAppointmentsProvidedNestedInput
    createdBy?: UserUpdateOneWithoutAppointmentsCreatedNestedInput
    encounter?: EncounterUpdateOneWithoutAppointmentNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUncheckedUpdateOneWithoutAppointmentNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentCreateManyInput = {
    id?: string
    externalId: string
    patientId: string
    providerId?: string | null
    createdById?: string | null
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterCreateManyInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteCreateInput = {
    id?: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutNoteInput
    createdBy?: UserCreateNestedOneWithoutNotesCreatedInput
    updatedBy?: UserCreateNestedOneWithoutNotesUpdatedInput
    versions?: NoteVersionCreateNestedManyWithoutNoteInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutNoteInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateInput = {
    id?: string
    encounterId: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    createdById?: string | null
    updatedById?: string | null
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: NoteVersionUncheckedCreateNestedManyWithoutNoteInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutNoteInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutNoteNestedInput
    createdBy?: UserUpdateOneWithoutNotesCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutNotesUpdatedNestedInput
    versions?: NoteVersionUpdateManyWithoutNoteNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutNoteNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: NoteVersionUncheckedUpdateManyWithoutNoteNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutNoteNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NoteCreateManyInput = {
    id?: string
    encounterId: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    createdById?: string | null
    updatedById?: string | null
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteVersionCreateInput = {
    id?: string
    versionNumber: number
    source: string
    content: string
    patientSummary: string
    traceId?: string | null
    createdAt?: Date | string
    note: NoteCreateNestedOneWithoutVersionsInput
    createdBy?: UserCreateNestedOneWithoutNoteVersionsInput
  }

  export type NoteVersionUncheckedCreateInput = {
    id?: string
    noteId: string
    versionNumber: number
    source: string
    content: string
    patientSummary: string
    traceId?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type NoteVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUpdateOneRequiredWithoutVersionsNestedInput
    createdBy?: UserUpdateOneWithoutNoteVersionsNestedInput
  }

  export type NoteVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteVersionCreateManyInput = {
    id?: string
    noteId: string
    versionNumber: number
    source: string
    content: string
    patientSummary: string
    traceId?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type NoteVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptSegmentCreateInput = {
    id?: string
    speaker: string
    speakerLabel?: string | null
    text: string
    startMs: number
    endMs: number
    source?: $Enums.TranscriptSource
    confidence?: number | null
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutTranscriptSegmentsInput
  }

  export type TranscriptSegmentUncheckedCreateInput = {
    id?: string
    encounterId: string
    speaker: string
    speakerLabel?: string | null
    text: string
    startMs: number
    endMs: number
    source?: $Enums.TranscriptSource
    confidence?: number | null
    createdAt?: Date | string
  }

  export type TranscriptSegmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
    speakerLabel?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    startMs?: IntFieldUpdateOperationsInput | number
    endMs?: IntFieldUpdateOperationsInput | number
    source?: EnumTranscriptSourceFieldUpdateOperationsInput | $Enums.TranscriptSource
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutTranscriptSegmentsNestedInput
  }

  export type TranscriptSegmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
    speakerLabel?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    startMs?: IntFieldUpdateOperationsInput | number
    endMs?: IntFieldUpdateOperationsInput | number
    source?: EnumTranscriptSourceFieldUpdateOperationsInput | $Enums.TranscriptSource
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptSegmentCreateManyInput = {
    id?: string
    encounterId: string
    speaker: string
    speakerLabel?: string | null
    text: string
    startMs: number
    endMs: number
    source?: $Enums.TranscriptSource
    confidence?: number | null
    createdAt?: Date | string
  }

  export type TranscriptSegmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
    speakerLabel?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    startMs?: IntFieldUpdateOperationsInput | number
    endMs?: IntFieldUpdateOperationsInput | number
    source?: EnumTranscriptSourceFieldUpdateOperationsInput | $Enums.TranscriptSource
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptSegmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
    speakerLabel?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    startMs?: IntFieldUpdateOperationsInput | number
    endMs?: IntFieldUpdateOperationsInput | number
    source?: EnumTranscriptSourceFieldUpdateOperationsInput | $Enums.TranscriptSource
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartAssetCreateInput = {
    id?: string
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutChartAssetsInput
    encounter?: EncounterCreateNestedOneWithoutChartAssetsInput
    patient?: PatientCreateNestedOneWithoutChartAssetsInput
    createdBy?: UserCreateNestedOneWithoutChartAssetsInput
  }

  export type ChartAssetUncheckedCreateInput = {
    id?: string
    appointmentId?: string | null
    encounterId?: string | null
    patientId?: string | null
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type ChartAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutChartAssetsNestedInput
    encounter?: EncounterUpdateOneWithoutChartAssetsNestedInput
    patient?: PatientUpdateOneWithoutChartAssetsNestedInput
    createdBy?: UserUpdateOneWithoutChartAssetsNestedInput
  }

  export type ChartAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartAssetCreateManyInput = {
    id?: string
    appointmentId?: string | null
    encounterId?: string | null
    patientId?: string | null
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type ChartAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestionGenerationCreateInput = {
    id?: string
    trigger: string
    textDelta?: number
    transcriptDelta?: number
    inputHash?: string | null
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutSuggestionCyclesInput
    createdBy?: UserCreateNestedOneWithoutSuggestionGenerationsInput
    suggestions?: CodeSuggestionCreateNestedManyWithoutGenerationInput
  }

  export type SuggestionGenerationUncheckedCreateInput = {
    id?: string
    encounterId: string
    trigger: string
    textDelta?: number
    transcriptDelta?: number
    inputHash?: string | null
    createdById?: string | null
    createdAt?: Date | string
    suggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type SuggestionGenerationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    textDelta?: IntFieldUpdateOperationsInput | number
    transcriptDelta?: IntFieldUpdateOperationsInput | number
    inputHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutSuggestionCyclesNestedInput
    createdBy?: UserUpdateOneWithoutSuggestionGenerationsNestedInput
    suggestions?: CodeSuggestionUpdateManyWithoutGenerationNestedInput
  }

  export type SuggestionGenerationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    textDelta?: IntFieldUpdateOperationsInput | number
    transcriptDelta?: IntFieldUpdateOperationsInput | number
    inputHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suggestions?: CodeSuggestionUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type SuggestionGenerationCreateManyInput = {
    id?: string
    encounterId: string
    trigger: string
    textDelta?: number
    transcriptDelta?: number
    inputHash?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type SuggestionGenerationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    textDelta?: IntFieldUpdateOperationsInput | number
    transcriptDelta?: IntFieldUpdateOperationsInput | number
    inputHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestionGenerationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    textDelta?: IntFieldUpdateOperationsInput | number
    transcriptDelta?: IntFieldUpdateOperationsInput | number
    inputHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSuggestionCreateInput = {
    id?: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    title: string
    description: string
    rationale: string
    confidence: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.SuggestionStatus
    recommended?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutCodeSuggestionsInput
    generation: SuggestionGenerationCreateNestedOneWithoutSuggestionsInput
    selections?: CodeSelectionCreateNestedManyWithoutCodeSuggestionInput
  }

  export type CodeSuggestionUncheckedCreateInput = {
    id?: string
    encounterId: string
    generationId: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    title: string
    description: string
    rationale: string
    confidence: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.SuggestionStatus
    recommended?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    selections?: CodeSelectionUncheckedCreateNestedManyWithoutCodeSuggestionInput
  }

  export type CodeSuggestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumSuggestionStatusFieldUpdateOperationsInput | $Enums.SuggestionStatus
    recommended?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutCodeSuggestionsNestedInput
    generation?: SuggestionGenerationUpdateOneRequiredWithoutSuggestionsNestedInput
    selections?: CodeSelectionUpdateManyWithoutCodeSuggestionNestedInput
  }

  export type CodeSuggestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    generationId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumSuggestionStatusFieldUpdateOperationsInput | $Enums.SuggestionStatus
    recommended?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    selections?: CodeSelectionUncheckedUpdateManyWithoutCodeSuggestionNestedInput
  }

  export type CodeSuggestionCreateManyInput = {
    id?: string
    encounterId: string
    generationId: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    title: string
    description: string
    rationale: string
    confidence: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.SuggestionStatus
    recommended?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeSuggestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumSuggestionStatusFieldUpdateOperationsInput | $Enums.SuggestionStatus
    recommended?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSuggestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    generationId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumSuggestionStatusFieldUpdateOperationsInput | $Enums.SuggestionStatus
    recommended?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSelectionCreateInput = {
    id?: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    action: $Enums.SelectionAction
    decisionReason?: string | null
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutCodeSelectionsInput
    codeSuggestion?: CodeSuggestionCreateNestedOneWithoutSelectionsInput
    actor?: UserCreateNestedOneWithoutCodeSelectionsInput
  }

  export type CodeSelectionUncheckedCreateInput = {
    id?: string
    encounterId: string
    codeSuggestionId?: string | null
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    action: $Enums.SelectionAction
    decisionReason?: string | null
    actorId?: string | null
    createdAt?: Date | string
  }

  export type CodeSelectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    action?: EnumSelectionActionFieldUpdateOperationsInput | $Enums.SelectionAction
    decisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutCodeSelectionsNestedInput
    codeSuggestion?: CodeSuggestionUpdateOneWithoutSelectionsNestedInput
    actor?: UserUpdateOneWithoutCodeSelectionsNestedInput
  }

  export type CodeSelectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    codeSuggestionId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    action?: EnumSelectionActionFieldUpdateOperationsInput | $Enums.SelectionAction
    decisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSelectionCreateManyInput = {
    id?: string
    encounterId: string
    codeSuggestionId?: string | null
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    action: $Enums.SelectionAction
    decisionReason?: string | null
    actorId?: string | null
    createdAt?: Date | string
  }

  export type CodeSelectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    action?: EnumSelectionActionFieldUpdateOperationsInput | $Enums.SelectionAction
    decisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSelectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    codeSuggestionId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    action?: EnumSelectionActionFieldUpdateOperationsInput | $Enums.SelectionAction
    decisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceIssueCreateInput = {
    id?: string
    severity: $Enums.ComplianceSeverity
    status?: $Enums.ComplianceStatus
    title: string
    description: string
    rationale: string
    remediation: string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint: string
    resolvedAt?: Date | string | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutComplianceIssuesInput
    actor?: UserCreateNestedOneWithoutComplianceIssuesInput
  }

  export type ComplianceIssueUncheckedCreateInput = {
    id?: string
    encounterId: string
    severity: $Enums.ComplianceSeverity
    status?: $Enums.ComplianceStatus
    title: string
    description: string
    rationale: string
    remediation: string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint: string
    actorId?: string | null
    resolvedAt?: Date | string | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceIssueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumComplianceSeverityFieldUpdateOperationsInput | $Enums.ComplianceSeverity
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    remediation?: StringFieldUpdateOperationsInput | string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutComplianceIssuesNestedInput
    actor?: UserUpdateOneWithoutComplianceIssuesNestedInput
  }

  export type ComplianceIssueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    severity?: EnumComplianceSeverityFieldUpdateOperationsInput | $Enums.ComplianceSeverity
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    remediation?: StringFieldUpdateOperationsInput | string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceIssueCreateManyInput = {
    id?: string
    encounterId: string
    severity: $Enums.ComplianceSeverity
    status?: $Enums.ComplianceStatus
    title: string
    description: string
    rationale: string
    remediation: string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint: string
    actorId?: string | null
    resolvedAt?: Date | string | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceIssueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumComplianceSeverityFieldUpdateOperationsInput | $Enums.ComplianceSeverity
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    remediation?: StringFieldUpdateOperationsInput | string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceIssueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    severity?: EnumComplianceSeverityFieldUpdateOperationsInput | $Enums.ComplianceSeverity
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    remediation?: StringFieldUpdateOperationsInput | string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WizardRunCreateInput = {
    id?: string
    status?: $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    encounter: EncounterCreateNestedOneWithoutWizardRunsInput
    stepStates?: WizardStepStateCreateNestedManyWithoutWizardRunInput
  }

  export type WizardRunUncheckedCreateInput = {
    id?: string
    encounterId: string
    status?: $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    stepStates?: WizardStepStateUncheckedCreateNestedManyWithoutWizardRunInput
  }

  export type WizardRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWizardRunStatusFieldUpdateOperationsInput | $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encounter?: EncounterUpdateOneRequiredWithoutWizardRunsNestedInput
    stepStates?: WizardStepStateUpdateManyWithoutWizardRunNestedInput
  }

  export type WizardRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    status?: EnumWizardRunStatusFieldUpdateOperationsInput | $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepStates?: WizardStepStateUncheckedUpdateManyWithoutWizardRunNestedInput
  }

  export type WizardRunCreateManyInput = {
    id?: string
    encounterId: string
    status?: $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type WizardRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWizardRunStatusFieldUpdateOperationsInput | $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WizardRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    status?: EnumWizardRunStatusFieldUpdateOperationsInput | $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WizardStepStateCreateInput = {
    id?: string
    step: $Enums.WizardStep
    status?: $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    wizardRun: WizardRunCreateNestedOneWithoutStepStatesInput
    encounter: EncounterCreateNestedOneWithoutWizardStepStatesInput
    lastActor?: UserCreateNestedOneWithoutWizardStepStatesInput
  }

  export type WizardStepStateUncheckedCreateInput = {
    id?: string
    wizardRunId: string
    encounterId: string
    step: $Enums.WizardStep
    status?: $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    lastActorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WizardStepStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: EnumWizardStepFieldUpdateOperationsInput | $Enums.WizardStep
    status?: EnumWizardStepStatusFieldUpdateOperationsInput | $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wizardRun?: WizardRunUpdateOneRequiredWithoutStepStatesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutWizardStepStatesNestedInput
    lastActor?: UserUpdateOneWithoutWizardStepStatesNestedInput
  }

  export type WizardStepStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    wizardRunId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    step?: EnumWizardStepFieldUpdateOperationsInput | $Enums.WizardStep
    status?: EnumWizardStepStatusFieldUpdateOperationsInput | $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    lastActorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WizardStepStateCreateManyInput = {
    id?: string
    wizardRunId: string
    encounterId: string
    step: $Enums.WizardStep
    status?: $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    lastActorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WizardStepStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: EnumWizardStepFieldUpdateOperationsInput | $Enums.WizardStep
    status?: EnumWizardStepStatusFieldUpdateOperationsInput | $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WizardStepStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    wizardRunId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    step?: EnumWizardStepFieldUpdateOperationsInput | $Enums.WizardStep
    status?: EnumWizardStepStatusFieldUpdateOperationsInput | $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    lastActorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportArtifactCreateInput = {
    id?: string
    type: $Enums.ArtifactType
    filePath: string
    mimeType: string
    fileName: string
    sizeBytes: number
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutExportArtifactsInput
    note?: NoteCreateNestedOneWithoutExportArtifactsInput
    createdBy?: UserCreateNestedOneWithoutExportArtifactsInput
  }

  export type ExportArtifactUncheckedCreateInput = {
    id?: string
    encounterId: string
    noteId?: string | null
    type: $Enums.ArtifactType
    filePath: string
    mimeType: string
    fileName: string
    sizeBytes: number
    createdById?: string | null
    createdAt?: Date | string
  }

  export type ExportArtifactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutExportArtifactsNestedInput
    note?: NoteUpdateOneWithoutExportArtifactsNestedInput
    createdBy?: UserUpdateOneWithoutExportArtifactsNestedInput
  }

  export type ExportArtifactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportArtifactCreateManyInput = {
    id?: string
    encounterId: string
    noteId?: string | null
    type: $Enums.ArtifactType
    filePath: string
    mimeType: string
    fileName: string
    sizeBytes: number
    createdById?: string | null
    createdAt?: Date | string
  }

  export type ExportArtifactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportArtifactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor?: UserCreateNestedOneWithoutAuditLogsInput
    encounter?: EncounterCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    actorId?: string | null
    encounterId?: string | null
    action: string
    entity: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutAuditLogsNestedInput
    encounter?: EncounterUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    actorId?: string | null
    encounterId?: string | null
    action: string
    entity: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionCreateInput = {
    id?: string
    refreshTokenHash: string
    expiresAt: Date | string
    revokedAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAuthSessionsInput
  }

  export type AuthSessionUncheckedCreateInput = {
    id?: string
    userId: string
    refreshTokenHash: string
    expiresAt: Date | string
    revokedAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuthSessionsNestedInput
  }

  export type AuthSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionCreateManyInput = {
    id?: string
    userId: string
    refreshTokenHash: string
    expiresAt: Date | string
    revokedAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchJobCreateInput = {
    id?: string
    target?: $Enums.DispatchTarget
    status?: $Enums.DispatchStatus
    contractType?: string | null
    attemptCount?: number
    maxAttempts?: number
    nextRetryAt?: Date | string | null
    dispatchedAt?: Date | string | null
    deadLetteredAt?: Date | string | null
    externalMessageId?: string | null
    lastError?: string | null
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutDispatchJobsInput
    note?: NoteCreateNestedOneWithoutDispatchJobsInput
    createdBy?: UserCreateNestedOneWithoutDispatchJobsInput
  }

  export type DispatchJobUncheckedCreateInput = {
    id?: string
    encounterId: string
    noteId?: string | null
    target?: $Enums.DispatchTarget
    status?: $Enums.DispatchStatus
    contractType?: string | null
    attemptCount?: number
    maxAttempts?: number
    nextRetryAt?: Date | string | null
    dispatchedAt?: Date | string | null
    deadLetteredAt?: Date | string | null
    externalMessageId?: string | null
    lastError?: string | null
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DispatchJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: EnumDispatchTargetFieldUpdateOperationsInput | $Enums.DispatchTarget
    status?: EnumDispatchStatusFieldUpdateOperationsInput | $Enums.DispatchStatus
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutDispatchJobsNestedInput
    note?: NoteUpdateOneWithoutDispatchJobsNestedInput
    createdBy?: UserUpdateOneWithoutDispatchJobsNestedInput
  }

  export type DispatchJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    target?: EnumDispatchTargetFieldUpdateOperationsInput | $Enums.DispatchTarget
    status?: EnumDispatchStatusFieldUpdateOperationsInput | $Enums.DispatchStatus
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchJobCreateManyInput = {
    id?: string
    encounterId: string
    noteId?: string | null
    target?: $Enums.DispatchTarget
    status?: $Enums.DispatchStatus
    contractType?: string | null
    attemptCount?: number
    maxAttempts?: number
    nextRetryAt?: Date | string | null
    dispatchedAt?: Date | string | null
    deadLetteredAt?: Date | string | null
    externalMessageId?: string | null
    lastError?: string | null
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DispatchJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: EnumDispatchTargetFieldUpdateOperationsInput | $Enums.DispatchTarget
    status?: EnumDispatchStatusFieldUpdateOperationsInput | $Enums.DispatchStatus
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    target?: EnumDispatchTargetFieldUpdateOperationsInput | $Enums.DispatchTarget
    status?: EnumDispatchStatusFieldUpdateOperationsInput | $Enums.DispatchStatus
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type EncounterListRelationFilter = {
    every?: EncounterWhereInput
    some?: EncounterWhereInput
    none?: EncounterWhereInput
  }

  export type NoteListRelationFilter = {
    every?: NoteWhereInput
    some?: NoteWhereInput
    none?: NoteWhereInput
  }

  export type NoteVersionListRelationFilter = {
    every?: NoteVersionWhereInput
    some?: NoteVersionWhereInput
    none?: NoteVersionWhereInput
  }

  export type ChartAssetListRelationFilter = {
    every?: ChartAssetWhereInput
    some?: ChartAssetWhereInput
    none?: ChartAssetWhereInput
  }

  export type SuggestionGenerationListRelationFilter = {
    every?: SuggestionGenerationWhereInput
    some?: SuggestionGenerationWhereInput
    none?: SuggestionGenerationWhereInput
  }

  export type CodeSelectionListRelationFilter = {
    every?: CodeSelectionWhereInput
    some?: CodeSelectionWhereInput
    none?: CodeSelectionWhereInput
  }

  export type ComplianceIssueListRelationFilter = {
    every?: ComplianceIssueWhereInput
    some?: ComplianceIssueWhereInput
    none?: ComplianceIssueWhereInput
  }

  export type WizardStepStateListRelationFilter = {
    every?: WizardStepStateWhereInput
    some?: WizardStepStateWhereInput
    none?: WizardStepStateWhereInput
  }

  export type ExportArtifactListRelationFilter = {
    every?: ExportArtifactWhereInput
    some?: ExportArtifactWhereInput
    none?: ExportArtifactWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type AuthSessionListRelationFilter = {
    every?: AuthSessionWhereInput
    some?: AuthSessionWhereInput
    none?: AuthSessionWhereInput
  }

  export type DispatchJobListRelationFilter = {
    every?: DispatchJobWhereInput
    some?: DispatchJobWhereInput
    none?: DispatchJobWhereInput
  }

  export type UserSettingsNullableScalarRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChartAssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuggestionGenerationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CodeSelectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplianceIssueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WizardStepStateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExportArtifactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DispatchJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    mfaBackupCodesHash?: SortOrder
    mfaEnrolledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    mfaEnrolledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    mfaEnrolledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    payload?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type EnumAppointmentPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentPriority | EnumAppointmentPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentPriority[] | ListEnumAppointmentPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentPriority[] | ListEnumAppointmentPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentPriorityFilter<$PrismaModel> | $Enums.AppointmentPriority
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type EncounterNullableScalarRelationFilter = {
    is?: EncounterWhereInput | null
    isNot?: EncounterWhereInput | null
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    patientId?: SortOrder
    providerId?: SortOrder
    createdById?: SortOrder
    scheduledAt?: SortOrder
    durationMinutes?: SortOrder
    appointmentType?: SortOrder
    location?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    isVirtual?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    patientId?: SortOrder
    providerId?: SortOrder
    createdById?: SortOrder
    scheduledAt?: SortOrder
    durationMinutes?: SortOrder
    appointmentType?: SortOrder
    location?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    isVirtual?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    patientId?: SortOrder
    providerId?: SortOrder
    createdById?: SortOrder
    scheduledAt?: SortOrder
    durationMinutes?: SortOrder
    appointmentType?: SortOrder
    location?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    isVirtual?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    durationMinutes?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type EnumAppointmentPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentPriority | EnumAppointmentPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentPriority[] | ListEnumAppointmentPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentPriority[] | ListEnumAppointmentPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentPriorityWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentPriorityFilter<$PrismaModel>
    _max?: NestedEnumAppointmentPriorityFilter<$PrismaModel>
  }

  export type EnumEncounterStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterStatus | EnumEncounterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterStatus[] | ListEnumEncounterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EncounterStatus[] | ListEnumEncounterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEncounterStatusFilter<$PrismaModel> | $Enums.EncounterStatus
  }

  export type AppointmentNullableScalarRelationFilter = {
    is?: AppointmentWhereInput | null
    isNot?: AppointmentWhereInput | null
  }

  export type NoteNullableScalarRelationFilter = {
    is?: NoteWhereInput | null
    isNot?: NoteWhereInput | null
  }

  export type TranscriptSegmentListRelationFilter = {
    every?: TranscriptSegmentWhereInput
    some?: TranscriptSegmentWhereInput
    none?: TranscriptSegmentWhereInput
  }

  export type CodeSuggestionListRelationFilter = {
    every?: CodeSuggestionWhereInput
    some?: CodeSuggestionWhereInput
    none?: CodeSuggestionWhereInput
  }

  export type WizardRunListRelationFilter = {
    every?: WizardRunWhereInput
    some?: WizardRunWhereInput
    none?: WizardRunWhereInput
  }

  export type TranscriptSegmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CodeSuggestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WizardRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    appointmentId?: SortOrder
    patientId?: SortOrder
    providerId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    stoppedAt?: SortOrder
    hiddenDraftCreated?: SortOrder
    draftUnhiddenAt?: SortOrder
    finalizedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    appointmentId?: SortOrder
    patientId?: SortOrder
    providerId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    stoppedAt?: SortOrder
    hiddenDraftCreated?: SortOrder
    draftUnhiddenAt?: SortOrder
    finalizedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    appointmentId?: SortOrder
    patientId?: SortOrder
    providerId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    stoppedAt?: SortOrder
    hiddenDraftCreated?: SortOrder
    draftUnhiddenAt?: SortOrder
    finalizedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEncounterStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterStatus | EnumEncounterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterStatus[] | ListEnumEncounterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EncounterStatus[] | ListEnumEncounterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEncounterStatusWithAggregatesFilter<$PrismaModel> | $Enums.EncounterStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEncounterStatusFilter<$PrismaModel>
    _max?: NestedEnumEncounterStatusFilter<$PrismaModel>
  }

  export type EnumNoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteStatus | EnumNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NoteStatus[] | ListEnumNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteStatus[] | ListEnumNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteStatusFilter<$PrismaModel> | $Enums.NoteStatus
  }

  export type EnumNoteVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteVisibility | EnumNoteVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.NoteVisibility[] | ListEnumNoteVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteVisibility[] | ListEnumNoteVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteVisibilityFilter<$PrismaModel> | $Enums.NoteVisibility
  }

  export type EncounterScalarRelationFilter = {
    is?: EncounterWhereInput
    isNot?: EncounterWhereInput
  }

  export type NoteCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    content?: SortOrder
    patientSummary?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    finalizedAt?: SortOrder
    lockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    content?: SortOrder
    patientSummary?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    finalizedAt?: SortOrder
    lockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoteMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    content?: SortOrder
    patientSummary?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    finalizedAt?: SortOrder
    lockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteStatus | EnumNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NoteStatus[] | ListEnumNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteStatus[] | ListEnumNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.NoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteStatusFilter<$PrismaModel>
    _max?: NestedEnumNoteStatusFilter<$PrismaModel>
  }

  export type EnumNoteVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteVisibility | EnumNoteVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.NoteVisibility[] | ListEnumNoteVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteVisibility[] | ListEnumNoteVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.NoteVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteVisibilityFilter<$PrismaModel>
    _max?: NestedEnumNoteVisibilityFilter<$PrismaModel>
  }

  export type NoteScalarRelationFilter = {
    is?: NoteWhereInput
    isNot?: NoteWhereInput
  }

  export type NoteVersionNoteIdVersionNumberCompoundUniqueInput = {
    noteId: string
    versionNumber: number
  }

  export type NoteVersionCountOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    versionNumber?: SortOrder
    source?: SortOrder
    content?: SortOrder
    patientSummary?: SortOrder
    traceId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type NoteVersionAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type NoteVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    versionNumber?: SortOrder
    source?: SortOrder
    content?: SortOrder
    patientSummary?: SortOrder
    traceId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type NoteVersionMinOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    versionNumber?: SortOrder
    source?: SortOrder
    content?: SortOrder
    patientSummary?: SortOrder
    traceId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type NoteVersionSumOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type EnumTranscriptSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptSource | EnumTranscriptSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptSource[] | ListEnumTranscriptSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptSource[] | ListEnumTranscriptSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptSourceFilter<$PrismaModel> | $Enums.TranscriptSource
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TranscriptSegmentCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    speaker?: SortOrder
    speakerLabel?: SortOrder
    text?: SortOrder
    startMs?: SortOrder
    endMs?: SortOrder
    source?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type TranscriptSegmentAvgOrderByAggregateInput = {
    startMs?: SortOrder
    endMs?: SortOrder
    confidence?: SortOrder
  }

  export type TranscriptSegmentMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    speaker?: SortOrder
    speakerLabel?: SortOrder
    text?: SortOrder
    startMs?: SortOrder
    endMs?: SortOrder
    source?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type TranscriptSegmentMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    speaker?: SortOrder
    speakerLabel?: SortOrder
    text?: SortOrder
    startMs?: SortOrder
    endMs?: SortOrder
    source?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type TranscriptSegmentSumOrderByAggregateInput = {
    startMs?: SortOrder
    endMs?: SortOrder
    confidence?: SortOrder
  }

  export type EnumTranscriptSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptSource | EnumTranscriptSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptSource[] | ListEnumTranscriptSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptSource[] | ListEnumTranscriptSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptSourceWithAggregatesFilter<$PrismaModel> | $Enums.TranscriptSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranscriptSourceFilter<$PrismaModel>
    _max?: NestedEnumTranscriptSourceFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type PatientNullableScalarRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type ChartAssetCountOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    storagePath?: SortOrder
    extractedJson?: SortOrder
    rawText?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ChartAssetAvgOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type ChartAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    storagePath?: SortOrder
    rawText?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ChartAssetMinOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    storagePath?: SortOrder
    rawText?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ChartAssetSumOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type SuggestionGenerationCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    trigger?: SortOrder
    textDelta?: SortOrder
    transcriptDelta?: SortOrder
    inputHash?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type SuggestionGenerationAvgOrderByAggregateInput = {
    textDelta?: SortOrder
    transcriptDelta?: SortOrder
  }

  export type SuggestionGenerationMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    trigger?: SortOrder
    textDelta?: SortOrder
    transcriptDelta?: SortOrder
    inputHash?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type SuggestionGenerationMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    trigger?: SortOrder
    textDelta?: SortOrder
    transcriptDelta?: SortOrder
    inputHash?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type SuggestionGenerationSumOrderByAggregateInput = {
    textDelta?: SortOrder
    transcriptDelta?: SortOrder
  }

  export type EnumSuggestionCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SuggestionCategory | EnumSuggestionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SuggestionCategory[] | ListEnumSuggestionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SuggestionCategory[] | ListEnumSuggestionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSuggestionCategoryFilter<$PrismaModel> | $Enums.SuggestionCategory
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumSuggestionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SuggestionStatus | EnumSuggestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SuggestionStatus[] | ListEnumSuggestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SuggestionStatus[] | ListEnumSuggestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSuggestionStatusFilter<$PrismaModel> | $Enums.SuggestionStatus
  }

  export type SuggestionGenerationScalarRelationFilter = {
    is?: SuggestionGenerationWhereInput
    isNot?: SuggestionGenerationWhereInput
  }

  export type CodeSuggestionCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    generationId?: SortOrder
    code?: SortOrder
    codeType?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    confidence?: SortOrder
    evidence?: SortOrder
    status?: SortOrder
    recommended?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodeSuggestionAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type CodeSuggestionMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    generationId?: SortOrder
    code?: SortOrder
    codeType?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    recommended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodeSuggestionMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    generationId?: SortOrder
    code?: SortOrder
    codeType?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    recommended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodeSuggestionSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type EnumSuggestionCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SuggestionCategory | EnumSuggestionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SuggestionCategory[] | ListEnumSuggestionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SuggestionCategory[] | ListEnumSuggestionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSuggestionCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SuggestionCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSuggestionCategoryFilter<$PrismaModel>
    _max?: NestedEnumSuggestionCategoryFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumSuggestionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SuggestionStatus | EnumSuggestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SuggestionStatus[] | ListEnumSuggestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SuggestionStatus[] | ListEnumSuggestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSuggestionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SuggestionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSuggestionStatusFilter<$PrismaModel>
    _max?: NestedEnumSuggestionStatusFilter<$PrismaModel>
  }

  export type EnumSelectionActionFilter<$PrismaModel = never> = {
    equals?: $Enums.SelectionAction | EnumSelectionActionFieldRefInput<$PrismaModel>
    in?: $Enums.SelectionAction[] | ListEnumSelectionActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SelectionAction[] | ListEnumSelectionActionFieldRefInput<$PrismaModel>
    not?: NestedEnumSelectionActionFilter<$PrismaModel> | $Enums.SelectionAction
  }

  export type CodeSuggestionNullableScalarRelationFilter = {
    is?: CodeSuggestionWhereInput | null
    isNot?: CodeSuggestionWhereInput | null
  }

  export type CodeSelectionCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    codeSuggestionId?: SortOrder
    code?: SortOrder
    codeType?: SortOrder
    category?: SortOrder
    action?: SortOrder
    decisionReason?: SortOrder
    actorId?: SortOrder
    createdAt?: SortOrder
  }

  export type CodeSelectionMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    codeSuggestionId?: SortOrder
    code?: SortOrder
    codeType?: SortOrder
    category?: SortOrder
    action?: SortOrder
    decisionReason?: SortOrder
    actorId?: SortOrder
    createdAt?: SortOrder
  }

  export type CodeSelectionMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    codeSuggestionId?: SortOrder
    code?: SortOrder
    codeType?: SortOrder
    category?: SortOrder
    action?: SortOrder
    decisionReason?: SortOrder
    actorId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSelectionActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SelectionAction | EnumSelectionActionFieldRefInput<$PrismaModel>
    in?: $Enums.SelectionAction[] | ListEnumSelectionActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SelectionAction[] | ListEnumSelectionActionFieldRefInput<$PrismaModel>
    not?: NestedEnumSelectionActionWithAggregatesFilter<$PrismaModel> | $Enums.SelectionAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSelectionActionFilter<$PrismaModel>
    _max?: NestedEnumSelectionActionFilter<$PrismaModel>
  }

  export type EnumComplianceSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceSeverity | EnumComplianceSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceSeverity[] | ListEnumComplianceSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceSeverity[] | ListEnumComplianceSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceSeverityFilter<$PrismaModel> | $Enums.ComplianceSeverity
  }

  export type EnumComplianceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusFilter<$PrismaModel> | $Enums.ComplianceStatus
  }

  export type ComplianceIssueEncounterIdFingerprintCompoundUniqueInput = {
    encounterId: string
    fingerprint: string
  }

  export type ComplianceIssueCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    remediation?: SortOrder
    evidence?: SortOrder
    fingerprint?: SortOrder
    actorId?: SortOrder
    resolvedAt?: SortOrder
    dismissedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceIssueMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    remediation?: SortOrder
    fingerprint?: SortOrder
    actorId?: SortOrder
    resolvedAt?: SortOrder
    dismissedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceIssueMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    remediation?: SortOrder
    fingerprint?: SortOrder
    actorId?: SortOrder
    resolvedAt?: SortOrder
    dismissedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumComplianceSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceSeverity | EnumComplianceSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceSeverity[] | ListEnumComplianceSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceSeverity[] | ListEnumComplianceSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceSeverityWithAggregatesFilter<$PrismaModel> | $Enums.ComplianceSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplianceSeverityFilter<$PrismaModel>
    _max?: NestedEnumComplianceSeverityFilter<$PrismaModel>
  }

  export type EnumComplianceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplianceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplianceStatusFilter<$PrismaModel>
    _max?: NestedEnumComplianceStatusFilter<$PrismaModel>
  }

  export type EnumWizardRunStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WizardRunStatus | EnumWizardRunStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WizardRunStatus[] | ListEnumWizardRunStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WizardRunStatus[] | ListEnumWizardRunStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWizardRunStatusFilter<$PrismaModel> | $Enums.WizardRunStatus
  }

  export type WizardRunCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    status?: SortOrder
    runState?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type WizardRunMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type WizardRunMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type EnumWizardRunStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WizardRunStatus | EnumWizardRunStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WizardRunStatus[] | ListEnumWizardRunStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WizardRunStatus[] | ListEnumWizardRunStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWizardRunStatusWithAggregatesFilter<$PrismaModel> | $Enums.WizardRunStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWizardRunStatusFilter<$PrismaModel>
    _max?: NestedEnumWizardRunStatusFilter<$PrismaModel>
  }

  export type EnumWizardStepFilter<$PrismaModel = never> = {
    equals?: $Enums.WizardStep | EnumWizardStepFieldRefInput<$PrismaModel>
    in?: $Enums.WizardStep[] | ListEnumWizardStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.WizardStep[] | ListEnumWizardStepFieldRefInput<$PrismaModel>
    not?: NestedEnumWizardStepFilter<$PrismaModel> | $Enums.WizardStep
  }

  export type EnumWizardStepStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WizardStepStatus | EnumWizardStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WizardStepStatus[] | ListEnumWizardStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WizardStepStatus[] | ListEnumWizardStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWizardStepStatusFilter<$PrismaModel> | $Enums.WizardStepStatus
  }

  export type WizardRunScalarRelationFilter = {
    is?: WizardRunWhereInput
    isNot?: WizardRunWhereInput
  }

  export type WizardStepStateWizardRunIdStepCompoundUniqueInput = {
    wizardRunId: string
    step: $Enums.WizardStep
  }

  export type WizardStepStateCountOrderByAggregateInput = {
    id?: SortOrder
    wizardRunId?: SortOrder
    encounterId?: SortOrder
    step?: SortOrder
    status?: SortOrder
    payload?: SortOrder
    lastActorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WizardStepStateMaxOrderByAggregateInput = {
    id?: SortOrder
    wizardRunId?: SortOrder
    encounterId?: SortOrder
    step?: SortOrder
    status?: SortOrder
    lastActorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WizardStepStateMinOrderByAggregateInput = {
    id?: SortOrder
    wizardRunId?: SortOrder
    encounterId?: SortOrder
    step?: SortOrder
    status?: SortOrder
    lastActorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWizardStepWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WizardStep | EnumWizardStepFieldRefInput<$PrismaModel>
    in?: $Enums.WizardStep[] | ListEnumWizardStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.WizardStep[] | ListEnumWizardStepFieldRefInput<$PrismaModel>
    not?: NestedEnumWizardStepWithAggregatesFilter<$PrismaModel> | $Enums.WizardStep
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWizardStepFilter<$PrismaModel>
    _max?: NestedEnumWizardStepFilter<$PrismaModel>
  }

  export type EnumWizardStepStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WizardStepStatus | EnumWizardStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WizardStepStatus[] | ListEnumWizardStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WizardStepStatus[] | ListEnumWizardStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWizardStepStatusWithAggregatesFilter<$PrismaModel> | $Enums.WizardStepStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWizardStepStatusFilter<$PrismaModel>
    _max?: NestedEnumWizardStepStatusFilter<$PrismaModel>
  }

  export type EnumArtifactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtifactType | EnumArtifactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtifactTypeFilter<$PrismaModel> | $Enums.ArtifactType
  }

  export type ExportArtifactCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    noteId?: SortOrder
    type?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileName?: SortOrder
    sizeBytes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ExportArtifactAvgOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type ExportArtifactMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    noteId?: SortOrder
    type?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileName?: SortOrder
    sizeBytes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ExportArtifactMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    noteId?: SortOrder
    type?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    fileName?: SortOrder
    sizeBytes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ExportArtifactSumOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type EnumArtifactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtifactType | EnumArtifactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtifactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ArtifactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArtifactTypeFilter<$PrismaModel>
    _max?: NestedEnumArtifactTypeFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    encounterId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    encounterId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    encounterId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuthSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenHash?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDispatchTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.DispatchTarget | EnumDispatchTargetFieldRefInput<$PrismaModel>
    in?: $Enums.DispatchTarget[] | ListEnumDispatchTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.DispatchTarget[] | ListEnumDispatchTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumDispatchTargetFilter<$PrismaModel> | $Enums.DispatchTarget
  }

  export type EnumDispatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DispatchStatus | EnumDispatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DispatchStatus[] | ListEnumDispatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DispatchStatus[] | ListEnumDispatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDispatchStatusFilter<$PrismaModel> | $Enums.DispatchStatus
  }

  export type DispatchJobCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    noteId?: SortOrder
    target?: SortOrder
    status?: SortOrder
    contractType?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    nextRetryAt?: SortOrder
    dispatchedAt?: SortOrder
    deadLetteredAt?: SortOrder
    externalMessageId?: SortOrder
    lastError?: SortOrder
    payload?: SortOrder
    response?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DispatchJobAvgOrderByAggregateInput = {
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
  }

  export type DispatchJobMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    noteId?: SortOrder
    target?: SortOrder
    status?: SortOrder
    contractType?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    nextRetryAt?: SortOrder
    dispatchedAt?: SortOrder
    deadLetteredAt?: SortOrder
    externalMessageId?: SortOrder
    lastError?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DispatchJobMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    noteId?: SortOrder
    target?: SortOrder
    status?: SortOrder
    contractType?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    nextRetryAt?: SortOrder
    dispatchedAt?: SortOrder
    deadLetteredAt?: SortOrder
    externalMessageId?: SortOrder
    lastError?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DispatchJobSumOrderByAggregateInput = {
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
  }

  export type EnumDispatchTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DispatchTarget | EnumDispatchTargetFieldRefInput<$PrismaModel>
    in?: $Enums.DispatchTarget[] | ListEnumDispatchTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.DispatchTarget[] | ListEnumDispatchTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumDispatchTargetWithAggregatesFilter<$PrismaModel> | $Enums.DispatchTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDispatchTargetFilter<$PrismaModel>
    _max?: NestedEnumDispatchTargetFilter<$PrismaModel>
  }

  export type EnumDispatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DispatchStatus | EnumDispatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DispatchStatus[] | ListEnumDispatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DispatchStatus[] | ListEnumDispatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDispatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.DispatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDispatchStatusFilter<$PrismaModel>
    _max?: NestedEnumDispatchStatusFilter<$PrismaModel>
  }

  export type AppointmentCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AppointmentCreateWithoutCreatedByInput, AppointmentUncheckedCreateWithoutCreatedByInput> | AppointmentCreateWithoutCreatedByInput[] | AppointmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCreatedByInput | AppointmentCreateOrConnectWithoutCreatedByInput[]
    createMany?: AppointmentCreateManyCreatedByInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutProviderInput = {
    create?: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput> | AppointmentCreateWithoutProviderInput[] | AppointmentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProviderInput | AppointmentCreateOrConnectWithoutProviderInput[]
    createMany?: AppointmentCreateManyProviderInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutProviderInput = {
    create?: XOR<EncounterCreateWithoutProviderInput, EncounterUncheckedCreateWithoutProviderInput> | EncounterCreateWithoutProviderInput[] | EncounterUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutProviderInput | EncounterCreateOrConnectWithoutProviderInput[]
    createMany?: EncounterCreateManyProviderInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<NoteCreateWithoutCreatedByInput, NoteUncheckedCreateWithoutCreatedByInput> | NoteCreateWithoutCreatedByInput[] | NoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutCreatedByInput | NoteCreateOrConnectWithoutCreatedByInput[]
    createMany?: NoteCreateManyCreatedByInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<NoteCreateWithoutUpdatedByInput, NoteUncheckedCreateWithoutUpdatedByInput> | NoteCreateWithoutUpdatedByInput[] | NoteUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUpdatedByInput | NoteCreateOrConnectWithoutUpdatedByInput[]
    createMany?: NoteCreateManyUpdatedByInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type NoteVersionCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<NoteVersionCreateWithoutCreatedByInput, NoteVersionUncheckedCreateWithoutCreatedByInput> | NoteVersionCreateWithoutCreatedByInput[] | NoteVersionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NoteVersionCreateOrConnectWithoutCreatedByInput | NoteVersionCreateOrConnectWithoutCreatedByInput[]
    createMany?: NoteVersionCreateManyCreatedByInputEnvelope
    connect?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
  }

  export type ChartAssetCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ChartAssetCreateWithoutCreatedByInput, ChartAssetUncheckedCreateWithoutCreatedByInput> | ChartAssetCreateWithoutCreatedByInput[] | ChartAssetUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutCreatedByInput | ChartAssetCreateOrConnectWithoutCreatedByInput[]
    createMany?: ChartAssetCreateManyCreatedByInputEnvelope
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
  }

  export type SuggestionGenerationCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SuggestionGenerationCreateWithoutCreatedByInput, SuggestionGenerationUncheckedCreateWithoutCreatedByInput> | SuggestionGenerationCreateWithoutCreatedByInput[] | SuggestionGenerationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SuggestionGenerationCreateOrConnectWithoutCreatedByInput | SuggestionGenerationCreateOrConnectWithoutCreatedByInput[]
    createMany?: SuggestionGenerationCreateManyCreatedByInputEnvelope
    connect?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
  }

  export type CodeSelectionCreateNestedManyWithoutActorInput = {
    create?: XOR<CodeSelectionCreateWithoutActorInput, CodeSelectionUncheckedCreateWithoutActorInput> | CodeSelectionCreateWithoutActorInput[] | CodeSelectionUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CodeSelectionCreateOrConnectWithoutActorInput | CodeSelectionCreateOrConnectWithoutActorInput[]
    createMany?: CodeSelectionCreateManyActorInputEnvelope
    connect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
  }

  export type ComplianceIssueCreateNestedManyWithoutActorInput = {
    create?: XOR<ComplianceIssueCreateWithoutActorInput, ComplianceIssueUncheckedCreateWithoutActorInput> | ComplianceIssueCreateWithoutActorInput[] | ComplianceIssueUncheckedCreateWithoutActorInput[]
    connectOrCreate?: ComplianceIssueCreateOrConnectWithoutActorInput | ComplianceIssueCreateOrConnectWithoutActorInput[]
    createMany?: ComplianceIssueCreateManyActorInputEnvelope
    connect?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
  }

  export type WizardStepStateCreateNestedManyWithoutLastActorInput = {
    create?: XOR<WizardStepStateCreateWithoutLastActorInput, WizardStepStateUncheckedCreateWithoutLastActorInput> | WizardStepStateCreateWithoutLastActorInput[] | WizardStepStateUncheckedCreateWithoutLastActorInput[]
    connectOrCreate?: WizardStepStateCreateOrConnectWithoutLastActorInput | WizardStepStateCreateOrConnectWithoutLastActorInput[]
    createMany?: WizardStepStateCreateManyLastActorInputEnvelope
    connect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
  }

  export type ExportArtifactCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ExportArtifactCreateWithoutCreatedByInput, ExportArtifactUncheckedCreateWithoutCreatedByInput> | ExportArtifactCreateWithoutCreatedByInput[] | ExportArtifactUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ExportArtifactCreateOrConnectWithoutCreatedByInput | ExportArtifactCreateOrConnectWithoutCreatedByInput[]
    createMany?: ExportArtifactCreateManyCreatedByInputEnvelope
    connect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AuthSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
  }

  export type DispatchJobCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<DispatchJobCreateWithoutCreatedByInput, DispatchJobUncheckedCreateWithoutCreatedByInput> | DispatchJobCreateWithoutCreatedByInput[] | DispatchJobUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DispatchJobCreateOrConnectWithoutCreatedByInput | DispatchJobCreateOrConnectWithoutCreatedByInput[]
    createMany?: DispatchJobCreateManyCreatedByInputEnvelope
    connect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type AppointmentUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AppointmentCreateWithoutCreatedByInput, AppointmentUncheckedCreateWithoutCreatedByInput> | AppointmentCreateWithoutCreatedByInput[] | AppointmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCreatedByInput | AppointmentCreateOrConnectWithoutCreatedByInput[]
    createMany?: AppointmentCreateManyCreatedByInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput> | AppointmentCreateWithoutProviderInput[] | AppointmentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProviderInput | AppointmentCreateOrConnectWithoutProviderInput[]
    createMany?: AppointmentCreateManyProviderInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<EncounterCreateWithoutProviderInput, EncounterUncheckedCreateWithoutProviderInput> | EncounterCreateWithoutProviderInput[] | EncounterUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutProviderInput | EncounterCreateOrConnectWithoutProviderInput[]
    createMany?: EncounterCreateManyProviderInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<NoteCreateWithoutCreatedByInput, NoteUncheckedCreateWithoutCreatedByInput> | NoteCreateWithoutCreatedByInput[] | NoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutCreatedByInput | NoteCreateOrConnectWithoutCreatedByInput[]
    createMany?: NoteCreateManyCreatedByInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<NoteCreateWithoutUpdatedByInput, NoteUncheckedCreateWithoutUpdatedByInput> | NoteCreateWithoutUpdatedByInput[] | NoteUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUpdatedByInput | NoteCreateOrConnectWithoutUpdatedByInput[]
    createMany?: NoteCreateManyUpdatedByInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<NoteVersionCreateWithoutCreatedByInput, NoteVersionUncheckedCreateWithoutCreatedByInput> | NoteVersionCreateWithoutCreatedByInput[] | NoteVersionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NoteVersionCreateOrConnectWithoutCreatedByInput | NoteVersionCreateOrConnectWithoutCreatedByInput[]
    createMany?: NoteVersionCreateManyCreatedByInputEnvelope
    connect?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
  }

  export type ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ChartAssetCreateWithoutCreatedByInput, ChartAssetUncheckedCreateWithoutCreatedByInput> | ChartAssetCreateWithoutCreatedByInput[] | ChartAssetUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutCreatedByInput | ChartAssetCreateOrConnectWithoutCreatedByInput[]
    createMany?: ChartAssetCreateManyCreatedByInputEnvelope
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
  }

  export type SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SuggestionGenerationCreateWithoutCreatedByInput, SuggestionGenerationUncheckedCreateWithoutCreatedByInput> | SuggestionGenerationCreateWithoutCreatedByInput[] | SuggestionGenerationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SuggestionGenerationCreateOrConnectWithoutCreatedByInput | SuggestionGenerationCreateOrConnectWithoutCreatedByInput[]
    createMany?: SuggestionGenerationCreateManyCreatedByInputEnvelope
    connect?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
  }

  export type CodeSelectionUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<CodeSelectionCreateWithoutActorInput, CodeSelectionUncheckedCreateWithoutActorInput> | CodeSelectionCreateWithoutActorInput[] | CodeSelectionUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CodeSelectionCreateOrConnectWithoutActorInput | CodeSelectionCreateOrConnectWithoutActorInput[]
    createMany?: CodeSelectionCreateManyActorInputEnvelope
    connect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
  }

  export type ComplianceIssueUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<ComplianceIssueCreateWithoutActorInput, ComplianceIssueUncheckedCreateWithoutActorInput> | ComplianceIssueCreateWithoutActorInput[] | ComplianceIssueUncheckedCreateWithoutActorInput[]
    connectOrCreate?: ComplianceIssueCreateOrConnectWithoutActorInput | ComplianceIssueCreateOrConnectWithoutActorInput[]
    createMany?: ComplianceIssueCreateManyActorInputEnvelope
    connect?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
  }

  export type WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput = {
    create?: XOR<WizardStepStateCreateWithoutLastActorInput, WizardStepStateUncheckedCreateWithoutLastActorInput> | WizardStepStateCreateWithoutLastActorInput[] | WizardStepStateUncheckedCreateWithoutLastActorInput[]
    connectOrCreate?: WizardStepStateCreateOrConnectWithoutLastActorInput | WizardStepStateCreateOrConnectWithoutLastActorInput[]
    createMany?: WizardStepStateCreateManyLastActorInputEnvelope
    connect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
  }

  export type ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ExportArtifactCreateWithoutCreatedByInput, ExportArtifactUncheckedCreateWithoutCreatedByInput> | ExportArtifactCreateWithoutCreatedByInput[] | ExportArtifactUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ExportArtifactCreateOrConnectWithoutCreatedByInput | ExportArtifactCreateOrConnectWithoutCreatedByInput[]
    createMany?: ExportArtifactCreateManyCreatedByInputEnvelope
    connect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AuthSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
  }

  export type DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<DispatchJobCreateWithoutCreatedByInput, DispatchJobUncheckedCreateWithoutCreatedByInput> | DispatchJobCreateWithoutCreatedByInput[] | DispatchJobUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DispatchJobCreateOrConnectWithoutCreatedByInput | DispatchJobCreateOrConnectWithoutCreatedByInput[]
    createMany?: DispatchJobCreateManyCreatedByInputEnvelope
    connect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AppointmentUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AppointmentCreateWithoutCreatedByInput, AppointmentUncheckedCreateWithoutCreatedByInput> | AppointmentCreateWithoutCreatedByInput[] | AppointmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCreatedByInput | AppointmentCreateOrConnectWithoutCreatedByInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutCreatedByInput | AppointmentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AppointmentCreateManyCreatedByInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutCreatedByInput | AppointmentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutCreatedByInput | AppointmentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutProviderNestedInput = {
    create?: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput> | AppointmentCreateWithoutProviderInput[] | AppointmentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProviderInput | AppointmentCreateOrConnectWithoutProviderInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutProviderInput | AppointmentUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: AppointmentCreateManyProviderInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutProviderInput | AppointmentUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutProviderInput | AppointmentUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutProviderNestedInput = {
    create?: XOR<EncounterCreateWithoutProviderInput, EncounterUncheckedCreateWithoutProviderInput> | EncounterCreateWithoutProviderInput[] | EncounterUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutProviderInput | EncounterCreateOrConnectWithoutProviderInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutProviderInput | EncounterUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: EncounterCreateManyProviderInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutProviderInput | EncounterUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutProviderInput | EncounterUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<NoteCreateWithoutCreatedByInput, NoteUncheckedCreateWithoutCreatedByInput> | NoteCreateWithoutCreatedByInput[] | NoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutCreatedByInput | NoteCreateOrConnectWithoutCreatedByInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutCreatedByInput | NoteUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: NoteCreateManyCreatedByInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutCreatedByInput | NoteUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutCreatedByInput | NoteUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<NoteCreateWithoutUpdatedByInput, NoteUncheckedCreateWithoutUpdatedByInput> | NoteCreateWithoutUpdatedByInput[] | NoteUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUpdatedByInput | NoteCreateOrConnectWithoutUpdatedByInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutUpdatedByInput | NoteUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: NoteCreateManyUpdatedByInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutUpdatedByInput | NoteUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutUpdatedByInput | NoteUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type NoteVersionUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<NoteVersionCreateWithoutCreatedByInput, NoteVersionUncheckedCreateWithoutCreatedByInput> | NoteVersionCreateWithoutCreatedByInput[] | NoteVersionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NoteVersionCreateOrConnectWithoutCreatedByInput | NoteVersionCreateOrConnectWithoutCreatedByInput[]
    upsert?: NoteVersionUpsertWithWhereUniqueWithoutCreatedByInput | NoteVersionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: NoteVersionCreateManyCreatedByInputEnvelope
    set?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    disconnect?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    delete?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    connect?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    update?: NoteVersionUpdateWithWhereUniqueWithoutCreatedByInput | NoteVersionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: NoteVersionUpdateManyWithWhereWithoutCreatedByInput | NoteVersionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: NoteVersionScalarWhereInput | NoteVersionScalarWhereInput[]
  }

  export type ChartAssetUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ChartAssetCreateWithoutCreatedByInput, ChartAssetUncheckedCreateWithoutCreatedByInput> | ChartAssetCreateWithoutCreatedByInput[] | ChartAssetUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutCreatedByInput | ChartAssetCreateOrConnectWithoutCreatedByInput[]
    upsert?: ChartAssetUpsertWithWhereUniqueWithoutCreatedByInput | ChartAssetUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ChartAssetCreateManyCreatedByInputEnvelope
    set?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    disconnect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    delete?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    update?: ChartAssetUpdateWithWhereUniqueWithoutCreatedByInput | ChartAssetUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ChartAssetUpdateManyWithWhereWithoutCreatedByInput | ChartAssetUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ChartAssetScalarWhereInput | ChartAssetScalarWhereInput[]
  }

  export type SuggestionGenerationUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SuggestionGenerationCreateWithoutCreatedByInput, SuggestionGenerationUncheckedCreateWithoutCreatedByInput> | SuggestionGenerationCreateWithoutCreatedByInput[] | SuggestionGenerationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SuggestionGenerationCreateOrConnectWithoutCreatedByInput | SuggestionGenerationCreateOrConnectWithoutCreatedByInput[]
    upsert?: SuggestionGenerationUpsertWithWhereUniqueWithoutCreatedByInput | SuggestionGenerationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SuggestionGenerationCreateManyCreatedByInputEnvelope
    set?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    disconnect?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    delete?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    connect?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    update?: SuggestionGenerationUpdateWithWhereUniqueWithoutCreatedByInput | SuggestionGenerationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SuggestionGenerationUpdateManyWithWhereWithoutCreatedByInput | SuggestionGenerationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SuggestionGenerationScalarWhereInput | SuggestionGenerationScalarWhereInput[]
  }

  export type CodeSelectionUpdateManyWithoutActorNestedInput = {
    create?: XOR<CodeSelectionCreateWithoutActorInput, CodeSelectionUncheckedCreateWithoutActorInput> | CodeSelectionCreateWithoutActorInput[] | CodeSelectionUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CodeSelectionCreateOrConnectWithoutActorInput | CodeSelectionCreateOrConnectWithoutActorInput[]
    upsert?: CodeSelectionUpsertWithWhereUniqueWithoutActorInput | CodeSelectionUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: CodeSelectionCreateManyActorInputEnvelope
    set?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    disconnect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    delete?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    connect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    update?: CodeSelectionUpdateWithWhereUniqueWithoutActorInput | CodeSelectionUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: CodeSelectionUpdateManyWithWhereWithoutActorInput | CodeSelectionUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: CodeSelectionScalarWhereInput | CodeSelectionScalarWhereInput[]
  }

  export type ComplianceIssueUpdateManyWithoutActorNestedInput = {
    create?: XOR<ComplianceIssueCreateWithoutActorInput, ComplianceIssueUncheckedCreateWithoutActorInput> | ComplianceIssueCreateWithoutActorInput[] | ComplianceIssueUncheckedCreateWithoutActorInput[]
    connectOrCreate?: ComplianceIssueCreateOrConnectWithoutActorInput | ComplianceIssueCreateOrConnectWithoutActorInput[]
    upsert?: ComplianceIssueUpsertWithWhereUniqueWithoutActorInput | ComplianceIssueUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: ComplianceIssueCreateManyActorInputEnvelope
    set?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    disconnect?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    delete?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    connect?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    update?: ComplianceIssueUpdateWithWhereUniqueWithoutActorInput | ComplianceIssueUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: ComplianceIssueUpdateManyWithWhereWithoutActorInput | ComplianceIssueUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: ComplianceIssueScalarWhereInput | ComplianceIssueScalarWhereInput[]
  }

  export type WizardStepStateUpdateManyWithoutLastActorNestedInput = {
    create?: XOR<WizardStepStateCreateWithoutLastActorInput, WizardStepStateUncheckedCreateWithoutLastActorInput> | WizardStepStateCreateWithoutLastActorInput[] | WizardStepStateUncheckedCreateWithoutLastActorInput[]
    connectOrCreate?: WizardStepStateCreateOrConnectWithoutLastActorInput | WizardStepStateCreateOrConnectWithoutLastActorInput[]
    upsert?: WizardStepStateUpsertWithWhereUniqueWithoutLastActorInput | WizardStepStateUpsertWithWhereUniqueWithoutLastActorInput[]
    createMany?: WizardStepStateCreateManyLastActorInputEnvelope
    set?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    disconnect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    delete?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    connect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    update?: WizardStepStateUpdateWithWhereUniqueWithoutLastActorInput | WizardStepStateUpdateWithWhereUniqueWithoutLastActorInput[]
    updateMany?: WizardStepStateUpdateManyWithWhereWithoutLastActorInput | WizardStepStateUpdateManyWithWhereWithoutLastActorInput[]
    deleteMany?: WizardStepStateScalarWhereInput | WizardStepStateScalarWhereInput[]
  }

  export type ExportArtifactUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ExportArtifactCreateWithoutCreatedByInput, ExportArtifactUncheckedCreateWithoutCreatedByInput> | ExportArtifactCreateWithoutCreatedByInput[] | ExportArtifactUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ExportArtifactCreateOrConnectWithoutCreatedByInput | ExportArtifactCreateOrConnectWithoutCreatedByInput[]
    upsert?: ExportArtifactUpsertWithWhereUniqueWithoutCreatedByInput | ExportArtifactUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ExportArtifactCreateManyCreatedByInputEnvelope
    set?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    disconnect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    delete?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    connect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    update?: ExportArtifactUpdateWithWhereUniqueWithoutCreatedByInput | ExportArtifactUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ExportArtifactUpdateManyWithWhereWithoutCreatedByInput | ExportArtifactUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ExportArtifactScalarWhereInput | ExportArtifactScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AuthSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    upsert?: AuthSessionUpsertWithWhereUniqueWithoutUserInput | AuthSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    set?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    disconnect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    delete?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    update?: AuthSessionUpdateWithWhereUniqueWithoutUserInput | AuthSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthSessionUpdateManyWithWhereWithoutUserInput | AuthSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
  }

  export type DispatchJobUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<DispatchJobCreateWithoutCreatedByInput, DispatchJobUncheckedCreateWithoutCreatedByInput> | DispatchJobCreateWithoutCreatedByInput[] | DispatchJobUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DispatchJobCreateOrConnectWithoutCreatedByInput | DispatchJobCreateOrConnectWithoutCreatedByInput[]
    upsert?: DispatchJobUpsertWithWhereUniqueWithoutCreatedByInput | DispatchJobUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: DispatchJobCreateManyCreatedByInputEnvelope
    set?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    disconnect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    delete?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    connect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    update?: DispatchJobUpdateWithWhereUniqueWithoutCreatedByInput | DispatchJobUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: DispatchJobUpdateManyWithWhereWithoutCreatedByInput | DispatchJobUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: DispatchJobScalarWhereInput | DispatchJobScalarWhereInput[]
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AppointmentCreateWithoutCreatedByInput, AppointmentUncheckedCreateWithoutCreatedByInput> | AppointmentCreateWithoutCreatedByInput[] | AppointmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCreatedByInput | AppointmentCreateOrConnectWithoutCreatedByInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutCreatedByInput | AppointmentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AppointmentCreateManyCreatedByInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutCreatedByInput | AppointmentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutCreatedByInput | AppointmentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput> | AppointmentCreateWithoutProviderInput[] | AppointmentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProviderInput | AppointmentCreateOrConnectWithoutProviderInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutProviderInput | AppointmentUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: AppointmentCreateManyProviderInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutProviderInput | AppointmentUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutProviderInput | AppointmentUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<EncounterCreateWithoutProviderInput, EncounterUncheckedCreateWithoutProviderInput> | EncounterCreateWithoutProviderInput[] | EncounterUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutProviderInput | EncounterCreateOrConnectWithoutProviderInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutProviderInput | EncounterUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: EncounterCreateManyProviderInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutProviderInput | EncounterUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutProviderInput | EncounterUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<NoteCreateWithoutCreatedByInput, NoteUncheckedCreateWithoutCreatedByInput> | NoteCreateWithoutCreatedByInput[] | NoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutCreatedByInput | NoteCreateOrConnectWithoutCreatedByInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutCreatedByInput | NoteUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: NoteCreateManyCreatedByInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutCreatedByInput | NoteUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutCreatedByInput | NoteUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<NoteCreateWithoutUpdatedByInput, NoteUncheckedCreateWithoutUpdatedByInput> | NoteCreateWithoutUpdatedByInput[] | NoteUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUpdatedByInput | NoteCreateOrConnectWithoutUpdatedByInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutUpdatedByInput | NoteUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: NoteCreateManyUpdatedByInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutUpdatedByInput | NoteUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutUpdatedByInput | NoteUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<NoteVersionCreateWithoutCreatedByInput, NoteVersionUncheckedCreateWithoutCreatedByInput> | NoteVersionCreateWithoutCreatedByInput[] | NoteVersionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NoteVersionCreateOrConnectWithoutCreatedByInput | NoteVersionCreateOrConnectWithoutCreatedByInput[]
    upsert?: NoteVersionUpsertWithWhereUniqueWithoutCreatedByInput | NoteVersionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: NoteVersionCreateManyCreatedByInputEnvelope
    set?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    disconnect?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    delete?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    connect?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    update?: NoteVersionUpdateWithWhereUniqueWithoutCreatedByInput | NoteVersionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: NoteVersionUpdateManyWithWhereWithoutCreatedByInput | NoteVersionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: NoteVersionScalarWhereInput | NoteVersionScalarWhereInput[]
  }

  export type ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ChartAssetCreateWithoutCreatedByInput, ChartAssetUncheckedCreateWithoutCreatedByInput> | ChartAssetCreateWithoutCreatedByInput[] | ChartAssetUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutCreatedByInput | ChartAssetCreateOrConnectWithoutCreatedByInput[]
    upsert?: ChartAssetUpsertWithWhereUniqueWithoutCreatedByInput | ChartAssetUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ChartAssetCreateManyCreatedByInputEnvelope
    set?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    disconnect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    delete?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    update?: ChartAssetUpdateWithWhereUniqueWithoutCreatedByInput | ChartAssetUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ChartAssetUpdateManyWithWhereWithoutCreatedByInput | ChartAssetUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ChartAssetScalarWhereInput | ChartAssetScalarWhereInput[]
  }

  export type SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SuggestionGenerationCreateWithoutCreatedByInput, SuggestionGenerationUncheckedCreateWithoutCreatedByInput> | SuggestionGenerationCreateWithoutCreatedByInput[] | SuggestionGenerationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SuggestionGenerationCreateOrConnectWithoutCreatedByInput | SuggestionGenerationCreateOrConnectWithoutCreatedByInput[]
    upsert?: SuggestionGenerationUpsertWithWhereUniqueWithoutCreatedByInput | SuggestionGenerationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SuggestionGenerationCreateManyCreatedByInputEnvelope
    set?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    disconnect?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    delete?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    connect?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    update?: SuggestionGenerationUpdateWithWhereUniqueWithoutCreatedByInput | SuggestionGenerationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SuggestionGenerationUpdateManyWithWhereWithoutCreatedByInput | SuggestionGenerationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SuggestionGenerationScalarWhereInput | SuggestionGenerationScalarWhereInput[]
  }

  export type CodeSelectionUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<CodeSelectionCreateWithoutActorInput, CodeSelectionUncheckedCreateWithoutActorInput> | CodeSelectionCreateWithoutActorInput[] | CodeSelectionUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CodeSelectionCreateOrConnectWithoutActorInput | CodeSelectionCreateOrConnectWithoutActorInput[]
    upsert?: CodeSelectionUpsertWithWhereUniqueWithoutActorInput | CodeSelectionUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: CodeSelectionCreateManyActorInputEnvelope
    set?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    disconnect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    delete?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    connect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    update?: CodeSelectionUpdateWithWhereUniqueWithoutActorInput | CodeSelectionUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: CodeSelectionUpdateManyWithWhereWithoutActorInput | CodeSelectionUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: CodeSelectionScalarWhereInput | CodeSelectionScalarWhereInput[]
  }

  export type ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<ComplianceIssueCreateWithoutActorInput, ComplianceIssueUncheckedCreateWithoutActorInput> | ComplianceIssueCreateWithoutActorInput[] | ComplianceIssueUncheckedCreateWithoutActorInput[]
    connectOrCreate?: ComplianceIssueCreateOrConnectWithoutActorInput | ComplianceIssueCreateOrConnectWithoutActorInput[]
    upsert?: ComplianceIssueUpsertWithWhereUniqueWithoutActorInput | ComplianceIssueUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: ComplianceIssueCreateManyActorInputEnvelope
    set?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    disconnect?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    delete?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    connect?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    update?: ComplianceIssueUpdateWithWhereUniqueWithoutActorInput | ComplianceIssueUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: ComplianceIssueUpdateManyWithWhereWithoutActorInput | ComplianceIssueUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: ComplianceIssueScalarWhereInput | ComplianceIssueScalarWhereInput[]
  }

  export type WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput = {
    create?: XOR<WizardStepStateCreateWithoutLastActorInput, WizardStepStateUncheckedCreateWithoutLastActorInput> | WizardStepStateCreateWithoutLastActorInput[] | WizardStepStateUncheckedCreateWithoutLastActorInput[]
    connectOrCreate?: WizardStepStateCreateOrConnectWithoutLastActorInput | WizardStepStateCreateOrConnectWithoutLastActorInput[]
    upsert?: WizardStepStateUpsertWithWhereUniqueWithoutLastActorInput | WizardStepStateUpsertWithWhereUniqueWithoutLastActorInput[]
    createMany?: WizardStepStateCreateManyLastActorInputEnvelope
    set?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    disconnect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    delete?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    connect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    update?: WizardStepStateUpdateWithWhereUniqueWithoutLastActorInput | WizardStepStateUpdateWithWhereUniqueWithoutLastActorInput[]
    updateMany?: WizardStepStateUpdateManyWithWhereWithoutLastActorInput | WizardStepStateUpdateManyWithWhereWithoutLastActorInput[]
    deleteMany?: WizardStepStateScalarWhereInput | WizardStepStateScalarWhereInput[]
  }

  export type ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ExportArtifactCreateWithoutCreatedByInput, ExportArtifactUncheckedCreateWithoutCreatedByInput> | ExportArtifactCreateWithoutCreatedByInput[] | ExportArtifactUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ExportArtifactCreateOrConnectWithoutCreatedByInput | ExportArtifactCreateOrConnectWithoutCreatedByInput[]
    upsert?: ExportArtifactUpsertWithWhereUniqueWithoutCreatedByInput | ExportArtifactUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ExportArtifactCreateManyCreatedByInputEnvelope
    set?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    disconnect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    delete?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    connect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    update?: ExportArtifactUpdateWithWhereUniqueWithoutCreatedByInput | ExportArtifactUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ExportArtifactUpdateManyWithWhereWithoutCreatedByInput | ExportArtifactUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ExportArtifactScalarWhereInput | ExportArtifactScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AuthSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    upsert?: AuthSessionUpsertWithWhereUniqueWithoutUserInput | AuthSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    set?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    disconnect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    delete?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    update?: AuthSessionUpdateWithWhereUniqueWithoutUserInput | AuthSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthSessionUpdateManyWithWhereWithoutUserInput | AuthSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
  }

  export type DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<DispatchJobCreateWithoutCreatedByInput, DispatchJobUncheckedCreateWithoutCreatedByInput> | DispatchJobCreateWithoutCreatedByInput[] | DispatchJobUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DispatchJobCreateOrConnectWithoutCreatedByInput | DispatchJobCreateOrConnectWithoutCreatedByInput[]
    upsert?: DispatchJobUpsertWithWhereUniqueWithoutCreatedByInput | DispatchJobUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: DispatchJobCreateManyCreatedByInputEnvelope
    set?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    disconnect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    delete?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    connect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    update?: DispatchJobUpdateWithWhereUniqueWithoutCreatedByInput | DispatchJobUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: DispatchJobUpdateManyWithWhereWithoutCreatedByInput | DispatchJobUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: DispatchJobScalarWhereInput | DispatchJobScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutUserSettingsInput = {
    create?: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserSettingsNestedInput = {
    create?: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsInput
    upsert?: UserUpsertWithoutUserSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSettingsInput, UserUpdateWithoutUserSettingsInput>, UserUncheckedUpdateWithoutUserSettingsInput>
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutPatientInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type ChartAssetCreateNestedManyWithoutPatientInput = {
    create?: XOR<ChartAssetCreateWithoutPatientInput, ChartAssetUncheckedCreateWithoutPatientInput> | ChartAssetCreateWithoutPatientInput[] | ChartAssetUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutPatientInput | ChartAssetCreateOrConnectWithoutPatientInput[]
    createMany?: ChartAssetCreateManyPatientInputEnvelope
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type ChartAssetUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ChartAssetCreateWithoutPatientInput, ChartAssetUncheckedCreateWithoutPatientInput> | ChartAssetCreateWithoutPatientInput[] | ChartAssetUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutPatientInput | ChartAssetCreateOrConnectWithoutPatientInput[]
    createMany?: ChartAssetCreateManyPatientInputEnvelope
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutPatientInput | EncounterUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutPatientInput | EncounterUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutPatientInput | EncounterUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type ChartAssetUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ChartAssetCreateWithoutPatientInput, ChartAssetUncheckedCreateWithoutPatientInput> | ChartAssetCreateWithoutPatientInput[] | ChartAssetUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutPatientInput | ChartAssetCreateOrConnectWithoutPatientInput[]
    upsert?: ChartAssetUpsertWithWhereUniqueWithoutPatientInput | ChartAssetUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ChartAssetCreateManyPatientInputEnvelope
    set?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    disconnect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    delete?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    update?: ChartAssetUpdateWithWhereUniqueWithoutPatientInput | ChartAssetUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ChartAssetUpdateManyWithWhereWithoutPatientInput | ChartAssetUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ChartAssetScalarWhereInput | ChartAssetScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutPatientInput | EncounterUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutPatientInput | EncounterUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutPatientInput | EncounterUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type ChartAssetUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ChartAssetCreateWithoutPatientInput, ChartAssetUncheckedCreateWithoutPatientInput> | ChartAssetCreateWithoutPatientInput[] | ChartAssetUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutPatientInput | ChartAssetCreateOrConnectWithoutPatientInput[]
    upsert?: ChartAssetUpsertWithWhereUniqueWithoutPatientInput | ChartAssetUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ChartAssetCreateManyPatientInputEnvelope
    set?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    disconnect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    delete?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    update?: ChartAssetUpdateWithWhereUniqueWithoutPatientInput | ChartAssetUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ChartAssetUpdateManyWithWhereWithoutPatientInput | ChartAssetUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ChartAssetScalarWhereInput | ChartAssetScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAppointmentsProvidedInput = {
    create?: XOR<UserCreateWithoutAppointmentsProvidedInput, UserUncheckedCreateWithoutAppointmentsProvidedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsProvidedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAppointmentsCreatedInput = {
    create?: XOR<UserCreateWithoutAppointmentsCreatedInput, UserUncheckedCreateWithoutAppointmentsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type EncounterCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutAppointmentInput
    connect?: EncounterWhereUniqueInput
  }

  export type ChartAssetCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<ChartAssetCreateWithoutAppointmentInput, ChartAssetUncheckedCreateWithoutAppointmentInput> | ChartAssetCreateWithoutAppointmentInput[] | ChartAssetUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutAppointmentInput | ChartAssetCreateOrConnectWithoutAppointmentInput[]
    createMany?: ChartAssetCreateManyAppointmentInputEnvelope
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutAppointmentInput
    connect?: EncounterWhereUniqueInput
  }

  export type ChartAssetUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<ChartAssetCreateWithoutAppointmentInput, ChartAssetUncheckedCreateWithoutAppointmentInput> | ChartAssetCreateWithoutAppointmentInput[] | ChartAssetUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutAppointmentInput | ChartAssetCreateOrConnectWithoutAppointmentInput[]
    createMany?: ChartAssetCreateManyAppointmentInputEnvelope
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type EnumAppointmentPriorityFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentPriority
  }

  export type PatientUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    upsert?: PatientUpsertWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAppointmentsInput, PatientUpdateWithoutAppointmentsInput>, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateOneWithoutAppointmentsProvidedNestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsProvidedInput, UserUncheckedCreateWithoutAppointmentsProvidedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsProvidedInput
    upsert?: UserUpsertWithoutAppointmentsProvidedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsProvidedInput, UserUpdateWithoutAppointmentsProvidedInput>, UserUncheckedUpdateWithoutAppointmentsProvidedInput>
  }

  export type UserUpdateOneWithoutAppointmentsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsCreatedInput, UserUncheckedCreateWithoutAppointmentsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsCreatedInput
    upsert?: UserUpsertWithoutAppointmentsCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsCreatedInput, UserUpdateWithoutAppointmentsCreatedInput>, UserUncheckedUpdateWithoutAppointmentsCreatedInput>
  }

  export type EncounterUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutAppointmentInput
    upsert?: EncounterUpsertWithoutAppointmentInput
    disconnect?: EncounterWhereInput | boolean
    delete?: EncounterWhereInput | boolean
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutAppointmentInput, EncounterUpdateWithoutAppointmentInput>, EncounterUncheckedUpdateWithoutAppointmentInput>
  }

  export type ChartAssetUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<ChartAssetCreateWithoutAppointmentInput, ChartAssetUncheckedCreateWithoutAppointmentInput> | ChartAssetCreateWithoutAppointmentInput[] | ChartAssetUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutAppointmentInput | ChartAssetCreateOrConnectWithoutAppointmentInput[]
    upsert?: ChartAssetUpsertWithWhereUniqueWithoutAppointmentInput | ChartAssetUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: ChartAssetCreateManyAppointmentInputEnvelope
    set?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    disconnect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    delete?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    update?: ChartAssetUpdateWithWhereUniqueWithoutAppointmentInput | ChartAssetUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: ChartAssetUpdateManyWithWhereWithoutAppointmentInput | ChartAssetUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: ChartAssetScalarWhereInput | ChartAssetScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutAppointmentInput
    upsert?: EncounterUpsertWithoutAppointmentInput
    disconnect?: EncounterWhereInput | boolean
    delete?: EncounterWhereInput | boolean
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutAppointmentInput, EncounterUpdateWithoutAppointmentInput>, EncounterUncheckedUpdateWithoutAppointmentInput>
  }

  export type ChartAssetUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<ChartAssetCreateWithoutAppointmentInput, ChartAssetUncheckedCreateWithoutAppointmentInput> | ChartAssetCreateWithoutAppointmentInput[] | ChartAssetUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutAppointmentInput | ChartAssetCreateOrConnectWithoutAppointmentInput[]
    upsert?: ChartAssetUpsertWithWhereUniqueWithoutAppointmentInput | ChartAssetUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: ChartAssetCreateManyAppointmentInputEnvelope
    set?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    disconnect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    delete?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    update?: ChartAssetUpdateWithWhereUniqueWithoutAppointmentInput | ChartAssetUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: ChartAssetUpdateManyWithWhereWithoutAppointmentInput | ChartAssetUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: ChartAssetScalarWhereInput | ChartAssetScalarWhereInput[]
  }

  export type AppointmentCreateNestedOneWithoutEncounterInput = {
    create?: XOR<AppointmentCreateWithoutEncounterInput, AppointmentUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutEncounterInput
    connect?: AppointmentWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutEncountersInput = {
    create?: XOR<PatientCreateWithoutEncountersInput, PatientUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEncountersInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEncountersProvidedInput = {
    create?: XOR<UserCreateWithoutEncountersProvidedInput, UserUncheckedCreateWithoutEncountersProvidedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEncountersProvidedInput
    connect?: UserWhereUniqueInput
  }

  export type NoteCreateNestedOneWithoutEncounterInput = {
    create?: XOR<NoteCreateWithoutEncounterInput, NoteUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: NoteCreateOrConnectWithoutEncounterInput
    connect?: NoteWhereUniqueInput
  }

  export type TranscriptSegmentCreateNestedManyWithoutEncounterInput = {
    create?: XOR<TranscriptSegmentCreateWithoutEncounterInput, TranscriptSegmentUncheckedCreateWithoutEncounterInput> | TranscriptSegmentCreateWithoutEncounterInput[] | TranscriptSegmentUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: TranscriptSegmentCreateOrConnectWithoutEncounterInput | TranscriptSegmentCreateOrConnectWithoutEncounterInput[]
    createMany?: TranscriptSegmentCreateManyEncounterInputEnvelope
    connect?: TranscriptSegmentWhereUniqueInput | TranscriptSegmentWhereUniqueInput[]
  }

  export type ChartAssetCreateNestedManyWithoutEncounterInput = {
    create?: XOR<ChartAssetCreateWithoutEncounterInput, ChartAssetUncheckedCreateWithoutEncounterInput> | ChartAssetCreateWithoutEncounterInput[] | ChartAssetUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutEncounterInput | ChartAssetCreateOrConnectWithoutEncounterInput[]
    createMany?: ChartAssetCreateManyEncounterInputEnvelope
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
  }

  export type SuggestionGenerationCreateNestedManyWithoutEncounterInput = {
    create?: XOR<SuggestionGenerationCreateWithoutEncounterInput, SuggestionGenerationUncheckedCreateWithoutEncounterInput> | SuggestionGenerationCreateWithoutEncounterInput[] | SuggestionGenerationUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: SuggestionGenerationCreateOrConnectWithoutEncounterInput | SuggestionGenerationCreateOrConnectWithoutEncounterInput[]
    createMany?: SuggestionGenerationCreateManyEncounterInputEnvelope
    connect?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
  }

  export type CodeSuggestionCreateNestedManyWithoutEncounterInput = {
    create?: XOR<CodeSuggestionCreateWithoutEncounterInput, CodeSuggestionUncheckedCreateWithoutEncounterInput> | CodeSuggestionCreateWithoutEncounterInput[] | CodeSuggestionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: CodeSuggestionCreateOrConnectWithoutEncounterInput | CodeSuggestionCreateOrConnectWithoutEncounterInput[]
    createMany?: CodeSuggestionCreateManyEncounterInputEnvelope
    connect?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
  }

  export type CodeSelectionCreateNestedManyWithoutEncounterInput = {
    create?: XOR<CodeSelectionCreateWithoutEncounterInput, CodeSelectionUncheckedCreateWithoutEncounterInput> | CodeSelectionCreateWithoutEncounterInput[] | CodeSelectionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: CodeSelectionCreateOrConnectWithoutEncounterInput | CodeSelectionCreateOrConnectWithoutEncounterInput[]
    createMany?: CodeSelectionCreateManyEncounterInputEnvelope
    connect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
  }

  export type ComplianceIssueCreateNestedManyWithoutEncounterInput = {
    create?: XOR<ComplianceIssueCreateWithoutEncounterInput, ComplianceIssueUncheckedCreateWithoutEncounterInput> | ComplianceIssueCreateWithoutEncounterInput[] | ComplianceIssueUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ComplianceIssueCreateOrConnectWithoutEncounterInput | ComplianceIssueCreateOrConnectWithoutEncounterInput[]
    createMany?: ComplianceIssueCreateManyEncounterInputEnvelope
    connect?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
  }

  export type WizardRunCreateNestedManyWithoutEncounterInput = {
    create?: XOR<WizardRunCreateWithoutEncounterInput, WizardRunUncheckedCreateWithoutEncounterInput> | WizardRunCreateWithoutEncounterInput[] | WizardRunUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: WizardRunCreateOrConnectWithoutEncounterInput | WizardRunCreateOrConnectWithoutEncounterInput[]
    createMany?: WizardRunCreateManyEncounterInputEnvelope
    connect?: WizardRunWhereUniqueInput | WizardRunWhereUniqueInput[]
  }

  export type WizardStepStateCreateNestedManyWithoutEncounterInput = {
    create?: XOR<WizardStepStateCreateWithoutEncounterInput, WizardStepStateUncheckedCreateWithoutEncounterInput> | WizardStepStateCreateWithoutEncounterInput[] | WizardStepStateUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: WizardStepStateCreateOrConnectWithoutEncounterInput | WizardStepStateCreateOrConnectWithoutEncounterInput[]
    createMany?: WizardStepStateCreateManyEncounterInputEnvelope
    connect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
  }

  export type ExportArtifactCreateNestedManyWithoutEncounterInput = {
    create?: XOR<ExportArtifactCreateWithoutEncounterInput, ExportArtifactUncheckedCreateWithoutEncounterInput> | ExportArtifactCreateWithoutEncounterInput[] | ExportArtifactUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ExportArtifactCreateOrConnectWithoutEncounterInput | ExportArtifactCreateOrConnectWithoutEncounterInput[]
    createMany?: ExportArtifactCreateManyEncounterInputEnvelope
    connect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutEncounterInput = {
    create?: XOR<AuditLogCreateWithoutEncounterInput, AuditLogUncheckedCreateWithoutEncounterInput> | AuditLogCreateWithoutEncounterInput[] | AuditLogUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutEncounterInput | AuditLogCreateOrConnectWithoutEncounterInput[]
    createMany?: AuditLogCreateManyEncounterInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DispatchJobCreateNestedManyWithoutEncounterInput = {
    create?: XOR<DispatchJobCreateWithoutEncounterInput, DispatchJobUncheckedCreateWithoutEncounterInput> | DispatchJobCreateWithoutEncounterInput[] | DispatchJobUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: DispatchJobCreateOrConnectWithoutEncounterInput | DispatchJobCreateOrConnectWithoutEncounterInput[]
    createMany?: DispatchJobCreateManyEncounterInputEnvelope
    connect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedOneWithoutEncounterInput = {
    create?: XOR<NoteCreateWithoutEncounterInput, NoteUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: NoteCreateOrConnectWithoutEncounterInput
    connect?: NoteWhereUniqueInput
  }

  export type TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<TranscriptSegmentCreateWithoutEncounterInput, TranscriptSegmentUncheckedCreateWithoutEncounterInput> | TranscriptSegmentCreateWithoutEncounterInput[] | TranscriptSegmentUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: TranscriptSegmentCreateOrConnectWithoutEncounterInput | TranscriptSegmentCreateOrConnectWithoutEncounterInput[]
    createMany?: TranscriptSegmentCreateManyEncounterInputEnvelope
    connect?: TranscriptSegmentWhereUniqueInput | TranscriptSegmentWhereUniqueInput[]
  }

  export type ChartAssetUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<ChartAssetCreateWithoutEncounterInput, ChartAssetUncheckedCreateWithoutEncounterInput> | ChartAssetCreateWithoutEncounterInput[] | ChartAssetUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutEncounterInput | ChartAssetCreateOrConnectWithoutEncounterInput[]
    createMany?: ChartAssetCreateManyEncounterInputEnvelope
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
  }

  export type SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<SuggestionGenerationCreateWithoutEncounterInput, SuggestionGenerationUncheckedCreateWithoutEncounterInput> | SuggestionGenerationCreateWithoutEncounterInput[] | SuggestionGenerationUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: SuggestionGenerationCreateOrConnectWithoutEncounterInput | SuggestionGenerationCreateOrConnectWithoutEncounterInput[]
    createMany?: SuggestionGenerationCreateManyEncounterInputEnvelope
    connect?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
  }

  export type CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<CodeSuggestionCreateWithoutEncounterInput, CodeSuggestionUncheckedCreateWithoutEncounterInput> | CodeSuggestionCreateWithoutEncounterInput[] | CodeSuggestionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: CodeSuggestionCreateOrConnectWithoutEncounterInput | CodeSuggestionCreateOrConnectWithoutEncounterInput[]
    createMany?: CodeSuggestionCreateManyEncounterInputEnvelope
    connect?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
  }

  export type CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<CodeSelectionCreateWithoutEncounterInput, CodeSelectionUncheckedCreateWithoutEncounterInput> | CodeSelectionCreateWithoutEncounterInput[] | CodeSelectionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: CodeSelectionCreateOrConnectWithoutEncounterInput | CodeSelectionCreateOrConnectWithoutEncounterInput[]
    createMany?: CodeSelectionCreateManyEncounterInputEnvelope
    connect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
  }

  export type ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<ComplianceIssueCreateWithoutEncounterInput, ComplianceIssueUncheckedCreateWithoutEncounterInput> | ComplianceIssueCreateWithoutEncounterInput[] | ComplianceIssueUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ComplianceIssueCreateOrConnectWithoutEncounterInput | ComplianceIssueCreateOrConnectWithoutEncounterInput[]
    createMany?: ComplianceIssueCreateManyEncounterInputEnvelope
    connect?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
  }

  export type WizardRunUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<WizardRunCreateWithoutEncounterInput, WizardRunUncheckedCreateWithoutEncounterInput> | WizardRunCreateWithoutEncounterInput[] | WizardRunUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: WizardRunCreateOrConnectWithoutEncounterInput | WizardRunCreateOrConnectWithoutEncounterInput[]
    createMany?: WizardRunCreateManyEncounterInputEnvelope
    connect?: WizardRunWhereUniqueInput | WizardRunWhereUniqueInput[]
  }

  export type WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<WizardStepStateCreateWithoutEncounterInput, WizardStepStateUncheckedCreateWithoutEncounterInput> | WizardStepStateCreateWithoutEncounterInput[] | WizardStepStateUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: WizardStepStateCreateOrConnectWithoutEncounterInput | WizardStepStateCreateOrConnectWithoutEncounterInput[]
    createMany?: WizardStepStateCreateManyEncounterInputEnvelope
    connect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
  }

  export type ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<ExportArtifactCreateWithoutEncounterInput, ExportArtifactUncheckedCreateWithoutEncounterInput> | ExportArtifactCreateWithoutEncounterInput[] | ExportArtifactUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ExportArtifactCreateOrConnectWithoutEncounterInput | ExportArtifactCreateOrConnectWithoutEncounterInput[]
    createMany?: ExportArtifactCreateManyEncounterInputEnvelope
    connect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<AuditLogCreateWithoutEncounterInput, AuditLogUncheckedCreateWithoutEncounterInput> | AuditLogCreateWithoutEncounterInput[] | AuditLogUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutEncounterInput | AuditLogCreateOrConnectWithoutEncounterInput[]
    createMany?: AuditLogCreateManyEncounterInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DispatchJobUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<DispatchJobCreateWithoutEncounterInput, DispatchJobUncheckedCreateWithoutEncounterInput> | DispatchJobCreateWithoutEncounterInput[] | DispatchJobUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: DispatchJobCreateOrConnectWithoutEncounterInput | DispatchJobCreateOrConnectWithoutEncounterInput[]
    createMany?: DispatchJobCreateManyEncounterInputEnvelope
    connect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
  }

  export type EnumEncounterStatusFieldUpdateOperationsInput = {
    set?: $Enums.EncounterStatus
  }

  export type AppointmentUpdateOneWithoutEncounterNestedInput = {
    create?: XOR<AppointmentCreateWithoutEncounterInput, AppointmentUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutEncounterInput
    upsert?: AppointmentUpsertWithoutEncounterInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutEncounterInput, AppointmentUpdateWithoutEncounterInput>, AppointmentUncheckedUpdateWithoutEncounterInput>
  }

  export type PatientUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<PatientCreateWithoutEncountersInput, PatientUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEncountersInput
    upsert?: PatientUpsertWithoutEncountersInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutEncountersInput, PatientUpdateWithoutEncountersInput>, PatientUncheckedUpdateWithoutEncountersInput>
  }

  export type UserUpdateOneWithoutEncountersProvidedNestedInput = {
    create?: XOR<UserCreateWithoutEncountersProvidedInput, UserUncheckedCreateWithoutEncountersProvidedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEncountersProvidedInput
    upsert?: UserUpsertWithoutEncountersProvidedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEncountersProvidedInput, UserUpdateWithoutEncountersProvidedInput>, UserUncheckedUpdateWithoutEncountersProvidedInput>
  }

  export type NoteUpdateOneWithoutEncounterNestedInput = {
    create?: XOR<NoteCreateWithoutEncounterInput, NoteUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: NoteCreateOrConnectWithoutEncounterInput
    upsert?: NoteUpsertWithoutEncounterInput
    disconnect?: NoteWhereInput | boolean
    delete?: NoteWhereInput | boolean
    connect?: NoteWhereUniqueInput
    update?: XOR<XOR<NoteUpdateToOneWithWhereWithoutEncounterInput, NoteUpdateWithoutEncounterInput>, NoteUncheckedUpdateWithoutEncounterInput>
  }

  export type TranscriptSegmentUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<TranscriptSegmentCreateWithoutEncounterInput, TranscriptSegmentUncheckedCreateWithoutEncounterInput> | TranscriptSegmentCreateWithoutEncounterInput[] | TranscriptSegmentUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: TranscriptSegmentCreateOrConnectWithoutEncounterInput | TranscriptSegmentCreateOrConnectWithoutEncounterInput[]
    upsert?: TranscriptSegmentUpsertWithWhereUniqueWithoutEncounterInput | TranscriptSegmentUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: TranscriptSegmentCreateManyEncounterInputEnvelope
    set?: TranscriptSegmentWhereUniqueInput | TranscriptSegmentWhereUniqueInput[]
    disconnect?: TranscriptSegmentWhereUniqueInput | TranscriptSegmentWhereUniqueInput[]
    delete?: TranscriptSegmentWhereUniqueInput | TranscriptSegmentWhereUniqueInput[]
    connect?: TranscriptSegmentWhereUniqueInput | TranscriptSegmentWhereUniqueInput[]
    update?: TranscriptSegmentUpdateWithWhereUniqueWithoutEncounterInput | TranscriptSegmentUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: TranscriptSegmentUpdateManyWithWhereWithoutEncounterInput | TranscriptSegmentUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: TranscriptSegmentScalarWhereInput | TranscriptSegmentScalarWhereInput[]
  }

  export type ChartAssetUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<ChartAssetCreateWithoutEncounterInput, ChartAssetUncheckedCreateWithoutEncounterInput> | ChartAssetCreateWithoutEncounterInput[] | ChartAssetUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutEncounterInput | ChartAssetCreateOrConnectWithoutEncounterInput[]
    upsert?: ChartAssetUpsertWithWhereUniqueWithoutEncounterInput | ChartAssetUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: ChartAssetCreateManyEncounterInputEnvelope
    set?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    disconnect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    delete?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    update?: ChartAssetUpdateWithWhereUniqueWithoutEncounterInput | ChartAssetUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: ChartAssetUpdateManyWithWhereWithoutEncounterInput | ChartAssetUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: ChartAssetScalarWhereInput | ChartAssetScalarWhereInput[]
  }

  export type SuggestionGenerationUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<SuggestionGenerationCreateWithoutEncounterInput, SuggestionGenerationUncheckedCreateWithoutEncounterInput> | SuggestionGenerationCreateWithoutEncounterInput[] | SuggestionGenerationUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: SuggestionGenerationCreateOrConnectWithoutEncounterInput | SuggestionGenerationCreateOrConnectWithoutEncounterInput[]
    upsert?: SuggestionGenerationUpsertWithWhereUniqueWithoutEncounterInput | SuggestionGenerationUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: SuggestionGenerationCreateManyEncounterInputEnvelope
    set?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    disconnect?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    delete?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    connect?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    update?: SuggestionGenerationUpdateWithWhereUniqueWithoutEncounterInput | SuggestionGenerationUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: SuggestionGenerationUpdateManyWithWhereWithoutEncounterInput | SuggestionGenerationUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: SuggestionGenerationScalarWhereInput | SuggestionGenerationScalarWhereInput[]
  }

  export type CodeSuggestionUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<CodeSuggestionCreateWithoutEncounterInput, CodeSuggestionUncheckedCreateWithoutEncounterInput> | CodeSuggestionCreateWithoutEncounterInput[] | CodeSuggestionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: CodeSuggestionCreateOrConnectWithoutEncounterInput | CodeSuggestionCreateOrConnectWithoutEncounterInput[]
    upsert?: CodeSuggestionUpsertWithWhereUniqueWithoutEncounterInput | CodeSuggestionUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: CodeSuggestionCreateManyEncounterInputEnvelope
    set?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    disconnect?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    delete?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    connect?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    update?: CodeSuggestionUpdateWithWhereUniqueWithoutEncounterInput | CodeSuggestionUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: CodeSuggestionUpdateManyWithWhereWithoutEncounterInput | CodeSuggestionUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: CodeSuggestionScalarWhereInput | CodeSuggestionScalarWhereInput[]
  }

  export type CodeSelectionUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<CodeSelectionCreateWithoutEncounterInput, CodeSelectionUncheckedCreateWithoutEncounterInput> | CodeSelectionCreateWithoutEncounterInput[] | CodeSelectionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: CodeSelectionCreateOrConnectWithoutEncounterInput | CodeSelectionCreateOrConnectWithoutEncounterInput[]
    upsert?: CodeSelectionUpsertWithWhereUniqueWithoutEncounterInput | CodeSelectionUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: CodeSelectionCreateManyEncounterInputEnvelope
    set?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    disconnect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    delete?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    connect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    update?: CodeSelectionUpdateWithWhereUniqueWithoutEncounterInput | CodeSelectionUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: CodeSelectionUpdateManyWithWhereWithoutEncounterInput | CodeSelectionUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: CodeSelectionScalarWhereInput | CodeSelectionScalarWhereInput[]
  }

  export type ComplianceIssueUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<ComplianceIssueCreateWithoutEncounterInput, ComplianceIssueUncheckedCreateWithoutEncounterInput> | ComplianceIssueCreateWithoutEncounterInput[] | ComplianceIssueUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ComplianceIssueCreateOrConnectWithoutEncounterInput | ComplianceIssueCreateOrConnectWithoutEncounterInput[]
    upsert?: ComplianceIssueUpsertWithWhereUniqueWithoutEncounterInput | ComplianceIssueUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: ComplianceIssueCreateManyEncounterInputEnvelope
    set?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    disconnect?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    delete?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    connect?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    update?: ComplianceIssueUpdateWithWhereUniqueWithoutEncounterInput | ComplianceIssueUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: ComplianceIssueUpdateManyWithWhereWithoutEncounterInput | ComplianceIssueUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: ComplianceIssueScalarWhereInput | ComplianceIssueScalarWhereInput[]
  }

  export type WizardRunUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<WizardRunCreateWithoutEncounterInput, WizardRunUncheckedCreateWithoutEncounterInput> | WizardRunCreateWithoutEncounterInput[] | WizardRunUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: WizardRunCreateOrConnectWithoutEncounterInput | WizardRunCreateOrConnectWithoutEncounterInput[]
    upsert?: WizardRunUpsertWithWhereUniqueWithoutEncounterInput | WizardRunUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: WizardRunCreateManyEncounterInputEnvelope
    set?: WizardRunWhereUniqueInput | WizardRunWhereUniqueInput[]
    disconnect?: WizardRunWhereUniqueInput | WizardRunWhereUniqueInput[]
    delete?: WizardRunWhereUniqueInput | WizardRunWhereUniqueInput[]
    connect?: WizardRunWhereUniqueInput | WizardRunWhereUniqueInput[]
    update?: WizardRunUpdateWithWhereUniqueWithoutEncounterInput | WizardRunUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: WizardRunUpdateManyWithWhereWithoutEncounterInput | WizardRunUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: WizardRunScalarWhereInput | WizardRunScalarWhereInput[]
  }

  export type WizardStepStateUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<WizardStepStateCreateWithoutEncounterInput, WizardStepStateUncheckedCreateWithoutEncounterInput> | WizardStepStateCreateWithoutEncounterInput[] | WizardStepStateUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: WizardStepStateCreateOrConnectWithoutEncounterInput | WizardStepStateCreateOrConnectWithoutEncounterInput[]
    upsert?: WizardStepStateUpsertWithWhereUniqueWithoutEncounterInput | WizardStepStateUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: WizardStepStateCreateManyEncounterInputEnvelope
    set?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    disconnect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    delete?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    connect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    update?: WizardStepStateUpdateWithWhereUniqueWithoutEncounterInput | WizardStepStateUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: WizardStepStateUpdateManyWithWhereWithoutEncounterInput | WizardStepStateUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: WizardStepStateScalarWhereInput | WizardStepStateScalarWhereInput[]
  }

  export type ExportArtifactUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<ExportArtifactCreateWithoutEncounterInput, ExportArtifactUncheckedCreateWithoutEncounterInput> | ExportArtifactCreateWithoutEncounterInput[] | ExportArtifactUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ExportArtifactCreateOrConnectWithoutEncounterInput | ExportArtifactCreateOrConnectWithoutEncounterInput[]
    upsert?: ExportArtifactUpsertWithWhereUniqueWithoutEncounterInput | ExportArtifactUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: ExportArtifactCreateManyEncounterInputEnvelope
    set?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    disconnect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    delete?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    connect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    update?: ExportArtifactUpdateWithWhereUniqueWithoutEncounterInput | ExportArtifactUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: ExportArtifactUpdateManyWithWhereWithoutEncounterInput | ExportArtifactUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: ExportArtifactScalarWhereInput | ExportArtifactScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<AuditLogCreateWithoutEncounterInput, AuditLogUncheckedCreateWithoutEncounterInput> | AuditLogCreateWithoutEncounterInput[] | AuditLogUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutEncounterInput | AuditLogCreateOrConnectWithoutEncounterInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutEncounterInput | AuditLogUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: AuditLogCreateManyEncounterInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutEncounterInput | AuditLogUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutEncounterInput | AuditLogUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DispatchJobUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<DispatchJobCreateWithoutEncounterInput, DispatchJobUncheckedCreateWithoutEncounterInput> | DispatchJobCreateWithoutEncounterInput[] | DispatchJobUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: DispatchJobCreateOrConnectWithoutEncounterInput | DispatchJobCreateOrConnectWithoutEncounterInput[]
    upsert?: DispatchJobUpsertWithWhereUniqueWithoutEncounterInput | DispatchJobUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: DispatchJobCreateManyEncounterInputEnvelope
    set?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    disconnect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    delete?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    connect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    update?: DispatchJobUpdateWithWhereUniqueWithoutEncounterInput | DispatchJobUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: DispatchJobUpdateManyWithWhereWithoutEncounterInput | DispatchJobUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: DispatchJobScalarWhereInput | DispatchJobScalarWhereInput[]
  }

  export type NoteUncheckedUpdateOneWithoutEncounterNestedInput = {
    create?: XOR<NoteCreateWithoutEncounterInput, NoteUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: NoteCreateOrConnectWithoutEncounterInput
    upsert?: NoteUpsertWithoutEncounterInput
    disconnect?: NoteWhereInput | boolean
    delete?: NoteWhereInput | boolean
    connect?: NoteWhereUniqueInput
    update?: XOR<XOR<NoteUpdateToOneWithWhereWithoutEncounterInput, NoteUpdateWithoutEncounterInput>, NoteUncheckedUpdateWithoutEncounterInput>
  }

  export type TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<TranscriptSegmentCreateWithoutEncounterInput, TranscriptSegmentUncheckedCreateWithoutEncounterInput> | TranscriptSegmentCreateWithoutEncounterInput[] | TranscriptSegmentUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: TranscriptSegmentCreateOrConnectWithoutEncounterInput | TranscriptSegmentCreateOrConnectWithoutEncounterInput[]
    upsert?: TranscriptSegmentUpsertWithWhereUniqueWithoutEncounterInput | TranscriptSegmentUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: TranscriptSegmentCreateManyEncounterInputEnvelope
    set?: TranscriptSegmentWhereUniqueInput | TranscriptSegmentWhereUniqueInput[]
    disconnect?: TranscriptSegmentWhereUniqueInput | TranscriptSegmentWhereUniqueInput[]
    delete?: TranscriptSegmentWhereUniqueInput | TranscriptSegmentWhereUniqueInput[]
    connect?: TranscriptSegmentWhereUniqueInput | TranscriptSegmentWhereUniqueInput[]
    update?: TranscriptSegmentUpdateWithWhereUniqueWithoutEncounterInput | TranscriptSegmentUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: TranscriptSegmentUpdateManyWithWhereWithoutEncounterInput | TranscriptSegmentUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: TranscriptSegmentScalarWhereInput | TranscriptSegmentScalarWhereInput[]
  }

  export type ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<ChartAssetCreateWithoutEncounterInput, ChartAssetUncheckedCreateWithoutEncounterInput> | ChartAssetCreateWithoutEncounterInput[] | ChartAssetUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ChartAssetCreateOrConnectWithoutEncounterInput | ChartAssetCreateOrConnectWithoutEncounterInput[]
    upsert?: ChartAssetUpsertWithWhereUniqueWithoutEncounterInput | ChartAssetUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: ChartAssetCreateManyEncounterInputEnvelope
    set?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    disconnect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    delete?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    connect?: ChartAssetWhereUniqueInput | ChartAssetWhereUniqueInput[]
    update?: ChartAssetUpdateWithWhereUniqueWithoutEncounterInput | ChartAssetUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: ChartAssetUpdateManyWithWhereWithoutEncounterInput | ChartAssetUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: ChartAssetScalarWhereInput | ChartAssetScalarWhereInput[]
  }

  export type SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<SuggestionGenerationCreateWithoutEncounterInput, SuggestionGenerationUncheckedCreateWithoutEncounterInput> | SuggestionGenerationCreateWithoutEncounterInput[] | SuggestionGenerationUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: SuggestionGenerationCreateOrConnectWithoutEncounterInput | SuggestionGenerationCreateOrConnectWithoutEncounterInput[]
    upsert?: SuggestionGenerationUpsertWithWhereUniqueWithoutEncounterInput | SuggestionGenerationUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: SuggestionGenerationCreateManyEncounterInputEnvelope
    set?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    disconnect?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    delete?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    connect?: SuggestionGenerationWhereUniqueInput | SuggestionGenerationWhereUniqueInput[]
    update?: SuggestionGenerationUpdateWithWhereUniqueWithoutEncounterInput | SuggestionGenerationUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: SuggestionGenerationUpdateManyWithWhereWithoutEncounterInput | SuggestionGenerationUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: SuggestionGenerationScalarWhereInput | SuggestionGenerationScalarWhereInput[]
  }

  export type CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<CodeSuggestionCreateWithoutEncounterInput, CodeSuggestionUncheckedCreateWithoutEncounterInput> | CodeSuggestionCreateWithoutEncounterInput[] | CodeSuggestionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: CodeSuggestionCreateOrConnectWithoutEncounterInput | CodeSuggestionCreateOrConnectWithoutEncounterInput[]
    upsert?: CodeSuggestionUpsertWithWhereUniqueWithoutEncounterInput | CodeSuggestionUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: CodeSuggestionCreateManyEncounterInputEnvelope
    set?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    disconnect?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    delete?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    connect?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    update?: CodeSuggestionUpdateWithWhereUniqueWithoutEncounterInput | CodeSuggestionUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: CodeSuggestionUpdateManyWithWhereWithoutEncounterInput | CodeSuggestionUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: CodeSuggestionScalarWhereInput | CodeSuggestionScalarWhereInput[]
  }

  export type CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<CodeSelectionCreateWithoutEncounterInput, CodeSelectionUncheckedCreateWithoutEncounterInput> | CodeSelectionCreateWithoutEncounterInput[] | CodeSelectionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: CodeSelectionCreateOrConnectWithoutEncounterInput | CodeSelectionCreateOrConnectWithoutEncounterInput[]
    upsert?: CodeSelectionUpsertWithWhereUniqueWithoutEncounterInput | CodeSelectionUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: CodeSelectionCreateManyEncounterInputEnvelope
    set?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    disconnect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    delete?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    connect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    update?: CodeSelectionUpdateWithWhereUniqueWithoutEncounterInput | CodeSelectionUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: CodeSelectionUpdateManyWithWhereWithoutEncounterInput | CodeSelectionUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: CodeSelectionScalarWhereInput | CodeSelectionScalarWhereInput[]
  }

  export type ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<ComplianceIssueCreateWithoutEncounterInput, ComplianceIssueUncheckedCreateWithoutEncounterInput> | ComplianceIssueCreateWithoutEncounterInput[] | ComplianceIssueUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ComplianceIssueCreateOrConnectWithoutEncounterInput | ComplianceIssueCreateOrConnectWithoutEncounterInput[]
    upsert?: ComplianceIssueUpsertWithWhereUniqueWithoutEncounterInput | ComplianceIssueUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: ComplianceIssueCreateManyEncounterInputEnvelope
    set?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    disconnect?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    delete?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    connect?: ComplianceIssueWhereUniqueInput | ComplianceIssueWhereUniqueInput[]
    update?: ComplianceIssueUpdateWithWhereUniqueWithoutEncounterInput | ComplianceIssueUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: ComplianceIssueUpdateManyWithWhereWithoutEncounterInput | ComplianceIssueUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: ComplianceIssueScalarWhereInput | ComplianceIssueScalarWhereInput[]
  }

  export type WizardRunUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<WizardRunCreateWithoutEncounterInput, WizardRunUncheckedCreateWithoutEncounterInput> | WizardRunCreateWithoutEncounterInput[] | WizardRunUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: WizardRunCreateOrConnectWithoutEncounterInput | WizardRunCreateOrConnectWithoutEncounterInput[]
    upsert?: WizardRunUpsertWithWhereUniqueWithoutEncounterInput | WizardRunUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: WizardRunCreateManyEncounterInputEnvelope
    set?: WizardRunWhereUniqueInput | WizardRunWhereUniqueInput[]
    disconnect?: WizardRunWhereUniqueInput | WizardRunWhereUniqueInput[]
    delete?: WizardRunWhereUniqueInput | WizardRunWhereUniqueInput[]
    connect?: WizardRunWhereUniqueInput | WizardRunWhereUniqueInput[]
    update?: WizardRunUpdateWithWhereUniqueWithoutEncounterInput | WizardRunUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: WizardRunUpdateManyWithWhereWithoutEncounterInput | WizardRunUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: WizardRunScalarWhereInput | WizardRunScalarWhereInput[]
  }

  export type WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<WizardStepStateCreateWithoutEncounterInput, WizardStepStateUncheckedCreateWithoutEncounterInput> | WizardStepStateCreateWithoutEncounterInput[] | WizardStepStateUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: WizardStepStateCreateOrConnectWithoutEncounterInput | WizardStepStateCreateOrConnectWithoutEncounterInput[]
    upsert?: WizardStepStateUpsertWithWhereUniqueWithoutEncounterInput | WizardStepStateUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: WizardStepStateCreateManyEncounterInputEnvelope
    set?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    disconnect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    delete?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    connect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    update?: WizardStepStateUpdateWithWhereUniqueWithoutEncounterInput | WizardStepStateUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: WizardStepStateUpdateManyWithWhereWithoutEncounterInput | WizardStepStateUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: WizardStepStateScalarWhereInput | WizardStepStateScalarWhereInput[]
  }

  export type ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<ExportArtifactCreateWithoutEncounterInput, ExportArtifactUncheckedCreateWithoutEncounterInput> | ExportArtifactCreateWithoutEncounterInput[] | ExportArtifactUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ExportArtifactCreateOrConnectWithoutEncounterInput | ExportArtifactCreateOrConnectWithoutEncounterInput[]
    upsert?: ExportArtifactUpsertWithWhereUniqueWithoutEncounterInput | ExportArtifactUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: ExportArtifactCreateManyEncounterInputEnvelope
    set?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    disconnect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    delete?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    connect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    update?: ExportArtifactUpdateWithWhereUniqueWithoutEncounterInput | ExportArtifactUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: ExportArtifactUpdateManyWithWhereWithoutEncounterInput | ExportArtifactUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: ExportArtifactScalarWhereInput | ExportArtifactScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<AuditLogCreateWithoutEncounterInput, AuditLogUncheckedCreateWithoutEncounterInput> | AuditLogCreateWithoutEncounterInput[] | AuditLogUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutEncounterInput | AuditLogCreateOrConnectWithoutEncounterInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutEncounterInput | AuditLogUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: AuditLogCreateManyEncounterInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutEncounterInput | AuditLogUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutEncounterInput | AuditLogUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<DispatchJobCreateWithoutEncounterInput, DispatchJobUncheckedCreateWithoutEncounterInput> | DispatchJobCreateWithoutEncounterInput[] | DispatchJobUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: DispatchJobCreateOrConnectWithoutEncounterInput | DispatchJobCreateOrConnectWithoutEncounterInput[]
    upsert?: DispatchJobUpsertWithWhereUniqueWithoutEncounterInput | DispatchJobUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: DispatchJobCreateManyEncounterInputEnvelope
    set?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    disconnect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    delete?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    connect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    update?: DispatchJobUpdateWithWhereUniqueWithoutEncounterInput | DispatchJobUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: DispatchJobUpdateManyWithWhereWithoutEncounterInput | DispatchJobUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: DispatchJobScalarWhereInput | DispatchJobScalarWhereInput[]
  }

  export type EncounterCreateNestedOneWithoutNoteInput = {
    create?: XOR<EncounterCreateWithoutNoteInput, EncounterUncheckedCreateWithoutNoteInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutNoteInput
    connect?: EncounterWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotesCreatedInput = {
    create?: XOR<UserCreateWithoutNotesCreatedInput, UserUncheckedCreateWithoutNotesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotesUpdatedInput = {
    create?: XOR<UserCreateWithoutNotesUpdatedInput, UserUncheckedCreateWithoutNotesUpdatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesUpdatedInput
    connect?: UserWhereUniqueInput
  }

  export type NoteVersionCreateNestedManyWithoutNoteInput = {
    create?: XOR<NoteVersionCreateWithoutNoteInput, NoteVersionUncheckedCreateWithoutNoteInput> | NoteVersionCreateWithoutNoteInput[] | NoteVersionUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: NoteVersionCreateOrConnectWithoutNoteInput | NoteVersionCreateOrConnectWithoutNoteInput[]
    createMany?: NoteVersionCreateManyNoteInputEnvelope
    connect?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
  }

  export type ExportArtifactCreateNestedManyWithoutNoteInput = {
    create?: XOR<ExportArtifactCreateWithoutNoteInput, ExportArtifactUncheckedCreateWithoutNoteInput> | ExportArtifactCreateWithoutNoteInput[] | ExportArtifactUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: ExportArtifactCreateOrConnectWithoutNoteInput | ExportArtifactCreateOrConnectWithoutNoteInput[]
    createMany?: ExportArtifactCreateManyNoteInputEnvelope
    connect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
  }

  export type DispatchJobCreateNestedManyWithoutNoteInput = {
    create?: XOR<DispatchJobCreateWithoutNoteInput, DispatchJobUncheckedCreateWithoutNoteInput> | DispatchJobCreateWithoutNoteInput[] | DispatchJobUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: DispatchJobCreateOrConnectWithoutNoteInput | DispatchJobCreateOrConnectWithoutNoteInput[]
    createMany?: DispatchJobCreateManyNoteInputEnvelope
    connect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
  }

  export type NoteVersionUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<NoteVersionCreateWithoutNoteInput, NoteVersionUncheckedCreateWithoutNoteInput> | NoteVersionCreateWithoutNoteInput[] | NoteVersionUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: NoteVersionCreateOrConnectWithoutNoteInput | NoteVersionCreateOrConnectWithoutNoteInput[]
    createMany?: NoteVersionCreateManyNoteInputEnvelope
    connect?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
  }

  export type ExportArtifactUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<ExportArtifactCreateWithoutNoteInput, ExportArtifactUncheckedCreateWithoutNoteInput> | ExportArtifactCreateWithoutNoteInput[] | ExportArtifactUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: ExportArtifactCreateOrConnectWithoutNoteInput | ExportArtifactCreateOrConnectWithoutNoteInput[]
    createMany?: ExportArtifactCreateManyNoteInputEnvelope
    connect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
  }

  export type DispatchJobUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<DispatchJobCreateWithoutNoteInput, DispatchJobUncheckedCreateWithoutNoteInput> | DispatchJobCreateWithoutNoteInput[] | DispatchJobUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: DispatchJobCreateOrConnectWithoutNoteInput | DispatchJobCreateOrConnectWithoutNoteInput[]
    createMany?: DispatchJobCreateManyNoteInputEnvelope
    connect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
  }

  export type EnumNoteStatusFieldUpdateOperationsInput = {
    set?: $Enums.NoteStatus
  }

  export type EnumNoteVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.NoteVisibility
  }

  export type EncounterUpdateOneRequiredWithoutNoteNestedInput = {
    create?: XOR<EncounterCreateWithoutNoteInput, EncounterUncheckedCreateWithoutNoteInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutNoteInput
    upsert?: EncounterUpsertWithoutNoteInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutNoteInput, EncounterUpdateWithoutNoteInput>, EncounterUncheckedUpdateWithoutNoteInput>
  }

  export type UserUpdateOneWithoutNotesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutNotesCreatedInput, UserUncheckedCreateWithoutNotesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesCreatedInput
    upsert?: UserUpsertWithoutNotesCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotesCreatedInput, UserUpdateWithoutNotesCreatedInput>, UserUncheckedUpdateWithoutNotesCreatedInput>
  }

  export type UserUpdateOneWithoutNotesUpdatedNestedInput = {
    create?: XOR<UserCreateWithoutNotesUpdatedInput, UserUncheckedCreateWithoutNotesUpdatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesUpdatedInput
    upsert?: UserUpsertWithoutNotesUpdatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotesUpdatedInput, UserUpdateWithoutNotesUpdatedInput>, UserUncheckedUpdateWithoutNotesUpdatedInput>
  }

  export type NoteVersionUpdateManyWithoutNoteNestedInput = {
    create?: XOR<NoteVersionCreateWithoutNoteInput, NoteVersionUncheckedCreateWithoutNoteInput> | NoteVersionCreateWithoutNoteInput[] | NoteVersionUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: NoteVersionCreateOrConnectWithoutNoteInput | NoteVersionCreateOrConnectWithoutNoteInput[]
    upsert?: NoteVersionUpsertWithWhereUniqueWithoutNoteInput | NoteVersionUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: NoteVersionCreateManyNoteInputEnvelope
    set?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    disconnect?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    delete?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    connect?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    update?: NoteVersionUpdateWithWhereUniqueWithoutNoteInput | NoteVersionUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: NoteVersionUpdateManyWithWhereWithoutNoteInput | NoteVersionUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: NoteVersionScalarWhereInput | NoteVersionScalarWhereInput[]
  }

  export type ExportArtifactUpdateManyWithoutNoteNestedInput = {
    create?: XOR<ExportArtifactCreateWithoutNoteInput, ExportArtifactUncheckedCreateWithoutNoteInput> | ExportArtifactCreateWithoutNoteInput[] | ExportArtifactUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: ExportArtifactCreateOrConnectWithoutNoteInput | ExportArtifactCreateOrConnectWithoutNoteInput[]
    upsert?: ExportArtifactUpsertWithWhereUniqueWithoutNoteInput | ExportArtifactUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: ExportArtifactCreateManyNoteInputEnvelope
    set?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    disconnect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    delete?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    connect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    update?: ExportArtifactUpdateWithWhereUniqueWithoutNoteInput | ExportArtifactUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: ExportArtifactUpdateManyWithWhereWithoutNoteInput | ExportArtifactUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: ExportArtifactScalarWhereInput | ExportArtifactScalarWhereInput[]
  }

  export type DispatchJobUpdateManyWithoutNoteNestedInput = {
    create?: XOR<DispatchJobCreateWithoutNoteInput, DispatchJobUncheckedCreateWithoutNoteInput> | DispatchJobCreateWithoutNoteInput[] | DispatchJobUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: DispatchJobCreateOrConnectWithoutNoteInput | DispatchJobCreateOrConnectWithoutNoteInput[]
    upsert?: DispatchJobUpsertWithWhereUniqueWithoutNoteInput | DispatchJobUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: DispatchJobCreateManyNoteInputEnvelope
    set?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    disconnect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    delete?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    connect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    update?: DispatchJobUpdateWithWhereUniqueWithoutNoteInput | DispatchJobUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: DispatchJobUpdateManyWithWhereWithoutNoteInput | DispatchJobUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: DispatchJobScalarWhereInput | DispatchJobScalarWhereInput[]
  }

  export type NoteVersionUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<NoteVersionCreateWithoutNoteInput, NoteVersionUncheckedCreateWithoutNoteInput> | NoteVersionCreateWithoutNoteInput[] | NoteVersionUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: NoteVersionCreateOrConnectWithoutNoteInput | NoteVersionCreateOrConnectWithoutNoteInput[]
    upsert?: NoteVersionUpsertWithWhereUniqueWithoutNoteInput | NoteVersionUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: NoteVersionCreateManyNoteInputEnvelope
    set?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    disconnect?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    delete?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    connect?: NoteVersionWhereUniqueInput | NoteVersionWhereUniqueInput[]
    update?: NoteVersionUpdateWithWhereUniqueWithoutNoteInput | NoteVersionUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: NoteVersionUpdateManyWithWhereWithoutNoteInput | NoteVersionUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: NoteVersionScalarWhereInput | NoteVersionScalarWhereInput[]
  }

  export type ExportArtifactUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<ExportArtifactCreateWithoutNoteInput, ExportArtifactUncheckedCreateWithoutNoteInput> | ExportArtifactCreateWithoutNoteInput[] | ExportArtifactUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: ExportArtifactCreateOrConnectWithoutNoteInput | ExportArtifactCreateOrConnectWithoutNoteInput[]
    upsert?: ExportArtifactUpsertWithWhereUniqueWithoutNoteInput | ExportArtifactUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: ExportArtifactCreateManyNoteInputEnvelope
    set?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    disconnect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    delete?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    connect?: ExportArtifactWhereUniqueInput | ExportArtifactWhereUniqueInput[]
    update?: ExportArtifactUpdateWithWhereUniqueWithoutNoteInput | ExportArtifactUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: ExportArtifactUpdateManyWithWhereWithoutNoteInput | ExportArtifactUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: ExportArtifactScalarWhereInput | ExportArtifactScalarWhereInput[]
  }

  export type DispatchJobUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<DispatchJobCreateWithoutNoteInput, DispatchJobUncheckedCreateWithoutNoteInput> | DispatchJobCreateWithoutNoteInput[] | DispatchJobUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: DispatchJobCreateOrConnectWithoutNoteInput | DispatchJobCreateOrConnectWithoutNoteInput[]
    upsert?: DispatchJobUpsertWithWhereUniqueWithoutNoteInput | DispatchJobUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: DispatchJobCreateManyNoteInputEnvelope
    set?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    disconnect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    delete?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    connect?: DispatchJobWhereUniqueInput | DispatchJobWhereUniqueInput[]
    update?: DispatchJobUpdateWithWhereUniqueWithoutNoteInput | DispatchJobUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: DispatchJobUpdateManyWithWhereWithoutNoteInput | DispatchJobUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: DispatchJobScalarWhereInput | DispatchJobScalarWhereInput[]
  }

  export type NoteCreateNestedOneWithoutVersionsInput = {
    create?: XOR<NoteCreateWithoutVersionsInput, NoteUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: NoteCreateOrConnectWithoutVersionsInput
    connect?: NoteWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNoteVersionsInput = {
    create?: XOR<UserCreateWithoutNoteVersionsInput, UserUncheckedCreateWithoutNoteVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteVersionsInput
    connect?: UserWhereUniqueInput
  }

  export type NoteUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<NoteCreateWithoutVersionsInput, NoteUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: NoteCreateOrConnectWithoutVersionsInput
    upsert?: NoteUpsertWithoutVersionsInput
    connect?: NoteWhereUniqueInput
    update?: XOR<XOR<NoteUpdateToOneWithWhereWithoutVersionsInput, NoteUpdateWithoutVersionsInput>, NoteUncheckedUpdateWithoutVersionsInput>
  }

  export type UserUpdateOneWithoutNoteVersionsNestedInput = {
    create?: XOR<UserCreateWithoutNoteVersionsInput, UserUncheckedCreateWithoutNoteVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteVersionsInput
    upsert?: UserUpsertWithoutNoteVersionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNoteVersionsInput, UserUpdateWithoutNoteVersionsInput>, UserUncheckedUpdateWithoutNoteVersionsInput>
  }

  export type EncounterCreateNestedOneWithoutTranscriptSegmentsInput = {
    create?: XOR<EncounterCreateWithoutTranscriptSegmentsInput, EncounterUncheckedCreateWithoutTranscriptSegmentsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutTranscriptSegmentsInput
    connect?: EncounterWhereUniqueInput
  }

  export type EnumTranscriptSourceFieldUpdateOperationsInput = {
    set?: $Enums.TranscriptSource
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EncounterUpdateOneRequiredWithoutTranscriptSegmentsNestedInput = {
    create?: XOR<EncounterCreateWithoutTranscriptSegmentsInput, EncounterUncheckedCreateWithoutTranscriptSegmentsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutTranscriptSegmentsInput
    upsert?: EncounterUpsertWithoutTranscriptSegmentsInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutTranscriptSegmentsInput, EncounterUpdateWithoutTranscriptSegmentsInput>, EncounterUncheckedUpdateWithoutTranscriptSegmentsInput>
  }

  export type AppointmentCreateNestedOneWithoutChartAssetsInput = {
    create?: XOR<AppointmentCreateWithoutChartAssetsInput, AppointmentUncheckedCreateWithoutChartAssetsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutChartAssetsInput
    connect?: AppointmentWhereUniqueInput
  }

  export type EncounterCreateNestedOneWithoutChartAssetsInput = {
    create?: XOR<EncounterCreateWithoutChartAssetsInput, EncounterUncheckedCreateWithoutChartAssetsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutChartAssetsInput
    connect?: EncounterWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutChartAssetsInput = {
    create?: XOR<PatientCreateWithoutChartAssetsInput, PatientUncheckedCreateWithoutChartAssetsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutChartAssetsInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChartAssetsInput = {
    create?: XOR<UserCreateWithoutChartAssetsInput, UserUncheckedCreateWithoutChartAssetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChartAssetsInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentUpdateOneWithoutChartAssetsNestedInput = {
    create?: XOR<AppointmentCreateWithoutChartAssetsInput, AppointmentUncheckedCreateWithoutChartAssetsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutChartAssetsInput
    upsert?: AppointmentUpsertWithoutChartAssetsInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutChartAssetsInput, AppointmentUpdateWithoutChartAssetsInput>, AppointmentUncheckedUpdateWithoutChartAssetsInput>
  }

  export type EncounterUpdateOneWithoutChartAssetsNestedInput = {
    create?: XOR<EncounterCreateWithoutChartAssetsInput, EncounterUncheckedCreateWithoutChartAssetsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutChartAssetsInput
    upsert?: EncounterUpsertWithoutChartAssetsInput
    disconnect?: EncounterWhereInput | boolean
    delete?: EncounterWhereInput | boolean
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutChartAssetsInput, EncounterUpdateWithoutChartAssetsInput>, EncounterUncheckedUpdateWithoutChartAssetsInput>
  }

  export type PatientUpdateOneWithoutChartAssetsNestedInput = {
    create?: XOR<PatientCreateWithoutChartAssetsInput, PatientUncheckedCreateWithoutChartAssetsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutChartAssetsInput
    upsert?: PatientUpsertWithoutChartAssetsInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutChartAssetsInput, PatientUpdateWithoutChartAssetsInput>, PatientUncheckedUpdateWithoutChartAssetsInput>
  }

  export type UserUpdateOneWithoutChartAssetsNestedInput = {
    create?: XOR<UserCreateWithoutChartAssetsInput, UserUncheckedCreateWithoutChartAssetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChartAssetsInput
    upsert?: UserUpsertWithoutChartAssetsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChartAssetsInput, UserUpdateWithoutChartAssetsInput>, UserUncheckedUpdateWithoutChartAssetsInput>
  }

  export type EncounterCreateNestedOneWithoutSuggestionCyclesInput = {
    create?: XOR<EncounterCreateWithoutSuggestionCyclesInput, EncounterUncheckedCreateWithoutSuggestionCyclesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutSuggestionCyclesInput
    connect?: EncounterWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSuggestionGenerationsInput = {
    create?: XOR<UserCreateWithoutSuggestionGenerationsInput, UserUncheckedCreateWithoutSuggestionGenerationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuggestionGenerationsInput
    connect?: UserWhereUniqueInput
  }

  export type CodeSuggestionCreateNestedManyWithoutGenerationInput = {
    create?: XOR<CodeSuggestionCreateWithoutGenerationInput, CodeSuggestionUncheckedCreateWithoutGenerationInput> | CodeSuggestionCreateWithoutGenerationInput[] | CodeSuggestionUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: CodeSuggestionCreateOrConnectWithoutGenerationInput | CodeSuggestionCreateOrConnectWithoutGenerationInput[]
    createMany?: CodeSuggestionCreateManyGenerationInputEnvelope
    connect?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
  }

  export type CodeSuggestionUncheckedCreateNestedManyWithoutGenerationInput = {
    create?: XOR<CodeSuggestionCreateWithoutGenerationInput, CodeSuggestionUncheckedCreateWithoutGenerationInput> | CodeSuggestionCreateWithoutGenerationInput[] | CodeSuggestionUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: CodeSuggestionCreateOrConnectWithoutGenerationInput | CodeSuggestionCreateOrConnectWithoutGenerationInput[]
    createMany?: CodeSuggestionCreateManyGenerationInputEnvelope
    connect?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
  }

  export type EncounterUpdateOneRequiredWithoutSuggestionCyclesNestedInput = {
    create?: XOR<EncounterCreateWithoutSuggestionCyclesInput, EncounterUncheckedCreateWithoutSuggestionCyclesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutSuggestionCyclesInput
    upsert?: EncounterUpsertWithoutSuggestionCyclesInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutSuggestionCyclesInput, EncounterUpdateWithoutSuggestionCyclesInput>, EncounterUncheckedUpdateWithoutSuggestionCyclesInput>
  }

  export type UserUpdateOneWithoutSuggestionGenerationsNestedInput = {
    create?: XOR<UserCreateWithoutSuggestionGenerationsInput, UserUncheckedCreateWithoutSuggestionGenerationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuggestionGenerationsInput
    upsert?: UserUpsertWithoutSuggestionGenerationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSuggestionGenerationsInput, UserUpdateWithoutSuggestionGenerationsInput>, UserUncheckedUpdateWithoutSuggestionGenerationsInput>
  }

  export type CodeSuggestionUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<CodeSuggestionCreateWithoutGenerationInput, CodeSuggestionUncheckedCreateWithoutGenerationInput> | CodeSuggestionCreateWithoutGenerationInput[] | CodeSuggestionUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: CodeSuggestionCreateOrConnectWithoutGenerationInput | CodeSuggestionCreateOrConnectWithoutGenerationInput[]
    upsert?: CodeSuggestionUpsertWithWhereUniqueWithoutGenerationInput | CodeSuggestionUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: CodeSuggestionCreateManyGenerationInputEnvelope
    set?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    disconnect?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    delete?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    connect?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    update?: CodeSuggestionUpdateWithWhereUniqueWithoutGenerationInput | CodeSuggestionUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: CodeSuggestionUpdateManyWithWhereWithoutGenerationInput | CodeSuggestionUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: CodeSuggestionScalarWhereInput | CodeSuggestionScalarWhereInput[]
  }

  export type CodeSuggestionUncheckedUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<CodeSuggestionCreateWithoutGenerationInput, CodeSuggestionUncheckedCreateWithoutGenerationInput> | CodeSuggestionCreateWithoutGenerationInput[] | CodeSuggestionUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: CodeSuggestionCreateOrConnectWithoutGenerationInput | CodeSuggestionCreateOrConnectWithoutGenerationInput[]
    upsert?: CodeSuggestionUpsertWithWhereUniqueWithoutGenerationInput | CodeSuggestionUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: CodeSuggestionCreateManyGenerationInputEnvelope
    set?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    disconnect?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    delete?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    connect?: CodeSuggestionWhereUniqueInput | CodeSuggestionWhereUniqueInput[]
    update?: CodeSuggestionUpdateWithWhereUniqueWithoutGenerationInput | CodeSuggestionUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: CodeSuggestionUpdateManyWithWhereWithoutGenerationInput | CodeSuggestionUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: CodeSuggestionScalarWhereInput | CodeSuggestionScalarWhereInput[]
  }

  export type EncounterCreateNestedOneWithoutCodeSuggestionsInput = {
    create?: XOR<EncounterCreateWithoutCodeSuggestionsInput, EncounterUncheckedCreateWithoutCodeSuggestionsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutCodeSuggestionsInput
    connect?: EncounterWhereUniqueInput
  }

  export type SuggestionGenerationCreateNestedOneWithoutSuggestionsInput = {
    create?: XOR<SuggestionGenerationCreateWithoutSuggestionsInput, SuggestionGenerationUncheckedCreateWithoutSuggestionsInput>
    connectOrCreate?: SuggestionGenerationCreateOrConnectWithoutSuggestionsInput
    connect?: SuggestionGenerationWhereUniqueInput
  }

  export type CodeSelectionCreateNestedManyWithoutCodeSuggestionInput = {
    create?: XOR<CodeSelectionCreateWithoutCodeSuggestionInput, CodeSelectionUncheckedCreateWithoutCodeSuggestionInput> | CodeSelectionCreateWithoutCodeSuggestionInput[] | CodeSelectionUncheckedCreateWithoutCodeSuggestionInput[]
    connectOrCreate?: CodeSelectionCreateOrConnectWithoutCodeSuggestionInput | CodeSelectionCreateOrConnectWithoutCodeSuggestionInput[]
    createMany?: CodeSelectionCreateManyCodeSuggestionInputEnvelope
    connect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
  }

  export type CodeSelectionUncheckedCreateNestedManyWithoutCodeSuggestionInput = {
    create?: XOR<CodeSelectionCreateWithoutCodeSuggestionInput, CodeSelectionUncheckedCreateWithoutCodeSuggestionInput> | CodeSelectionCreateWithoutCodeSuggestionInput[] | CodeSelectionUncheckedCreateWithoutCodeSuggestionInput[]
    connectOrCreate?: CodeSelectionCreateOrConnectWithoutCodeSuggestionInput | CodeSelectionCreateOrConnectWithoutCodeSuggestionInput[]
    createMany?: CodeSelectionCreateManyCodeSuggestionInputEnvelope
    connect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
  }

  export type EnumSuggestionCategoryFieldUpdateOperationsInput = {
    set?: $Enums.SuggestionCategory
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumSuggestionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SuggestionStatus
  }

  export type EncounterUpdateOneRequiredWithoutCodeSuggestionsNestedInput = {
    create?: XOR<EncounterCreateWithoutCodeSuggestionsInput, EncounterUncheckedCreateWithoutCodeSuggestionsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutCodeSuggestionsInput
    upsert?: EncounterUpsertWithoutCodeSuggestionsInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutCodeSuggestionsInput, EncounterUpdateWithoutCodeSuggestionsInput>, EncounterUncheckedUpdateWithoutCodeSuggestionsInput>
  }

  export type SuggestionGenerationUpdateOneRequiredWithoutSuggestionsNestedInput = {
    create?: XOR<SuggestionGenerationCreateWithoutSuggestionsInput, SuggestionGenerationUncheckedCreateWithoutSuggestionsInput>
    connectOrCreate?: SuggestionGenerationCreateOrConnectWithoutSuggestionsInput
    upsert?: SuggestionGenerationUpsertWithoutSuggestionsInput
    connect?: SuggestionGenerationWhereUniqueInput
    update?: XOR<XOR<SuggestionGenerationUpdateToOneWithWhereWithoutSuggestionsInput, SuggestionGenerationUpdateWithoutSuggestionsInput>, SuggestionGenerationUncheckedUpdateWithoutSuggestionsInput>
  }

  export type CodeSelectionUpdateManyWithoutCodeSuggestionNestedInput = {
    create?: XOR<CodeSelectionCreateWithoutCodeSuggestionInput, CodeSelectionUncheckedCreateWithoutCodeSuggestionInput> | CodeSelectionCreateWithoutCodeSuggestionInput[] | CodeSelectionUncheckedCreateWithoutCodeSuggestionInput[]
    connectOrCreate?: CodeSelectionCreateOrConnectWithoutCodeSuggestionInput | CodeSelectionCreateOrConnectWithoutCodeSuggestionInput[]
    upsert?: CodeSelectionUpsertWithWhereUniqueWithoutCodeSuggestionInput | CodeSelectionUpsertWithWhereUniqueWithoutCodeSuggestionInput[]
    createMany?: CodeSelectionCreateManyCodeSuggestionInputEnvelope
    set?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    disconnect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    delete?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    connect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    update?: CodeSelectionUpdateWithWhereUniqueWithoutCodeSuggestionInput | CodeSelectionUpdateWithWhereUniqueWithoutCodeSuggestionInput[]
    updateMany?: CodeSelectionUpdateManyWithWhereWithoutCodeSuggestionInput | CodeSelectionUpdateManyWithWhereWithoutCodeSuggestionInput[]
    deleteMany?: CodeSelectionScalarWhereInput | CodeSelectionScalarWhereInput[]
  }

  export type CodeSelectionUncheckedUpdateManyWithoutCodeSuggestionNestedInput = {
    create?: XOR<CodeSelectionCreateWithoutCodeSuggestionInput, CodeSelectionUncheckedCreateWithoutCodeSuggestionInput> | CodeSelectionCreateWithoutCodeSuggestionInput[] | CodeSelectionUncheckedCreateWithoutCodeSuggestionInput[]
    connectOrCreate?: CodeSelectionCreateOrConnectWithoutCodeSuggestionInput | CodeSelectionCreateOrConnectWithoutCodeSuggestionInput[]
    upsert?: CodeSelectionUpsertWithWhereUniqueWithoutCodeSuggestionInput | CodeSelectionUpsertWithWhereUniqueWithoutCodeSuggestionInput[]
    createMany?: CodeSelectionCreateManyCodeSuggestionInputEnvelope
    set?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    disconnect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    delete?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    connect?: CodeSelectionWhereUniqueInput | CodeSelectionWhereUniqueInput[]
    update?: CodeSelectionUpdateWithWhereUniqueWithoutCodeSuggestionInput | CodeSelectionUpdateWithWhereUniqueWithoutCodeSuggestionInput[]
    updateMany?: CodeSelectionUpdateManyWithWhereWithoutCodeSuggestionInput | CodeSelectionUpdateManyWithWhereWithoutCodeSuggestionInput[]
    deleteMany?: CodeSelectionScalarWhereInput | CodeSelectionScalarWhereInput[]
  }

  export type EncounterCreateNestedOneWithoutCodeSelectionsInput = {
    create?: XOR<EncounterCreateWithoutCodeSelectionsInput, EncounterUncheckedCreateWithoutCodeSelectionsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutCodeSelectionsInput
    connect?: EncounterWhereUniqueInput
  }

  export type CodeSuggestionCreateNestedOneWithoutSelectionsInput = {
    create?: XOR<CodeSuggestionCreateWithoutSelectionsInput, CodeSuggestionUncheckedCreateWithoutSelectionsInput>
    connectOrCreate?: CodeSuggestionCreateOrConnectWithoutSelectionsInput
    connect?: CodeSuggestionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCodeSelectionsInput = {
    create?: XOR<UserCreateWithoutCodeSelectionsInput, UserUncheckedCreateWithoutCodeSelectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodeSelectionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSelectionActionFieldUpdateOperationsInput = {
    set?: $Enums.SelectionAction
  }

  export type EncounterUpdateOneRequiredWithoutCodeSelectionsNestedInput = {
    create?: XOR<EncounterCreateWithoutCodeSelectionsInput, EncounterUncheckedCreateWithoutCodeSelectionsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutCodeSelectionsInput
    upsert?: EncounterUpsertWithoutCodeSelectionsInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutCodeSelectionsInput, EncounterUpdateWithoutCodeSelectionsInput>, EncounterUncheckedUpdateWithoutCodeSelectionsInput>
  }

  export type CodeSuggestionUpdateOneWithoutSelectionsNestedInput = {
    create?: XOR<CodeSuggestionCreateWithoutSelectionsInput, CodeSuggestionUncheckedCreateWithoutSelectionsInput>
    connectOrCreate?: CodeSuggestionCreateOrConnectWithoutSelectionsInput
    upsert?: CodeSuggestionUpsertWithoutSelectionsInput
    disconnect?: CodeSuggestionWhereInput | boolean
    delete?: CodeSuggestionWhereInput | boolean
    connect?: CodeSuggestionWhereUniqueInput
    update?: XOR<XOR<CodeSuggestionUpdateToOneWithWhereWithoutSelectionsInput, CodeSuggestionUpdateWithoutSelectionsInput>, CodeSuggestionUncheckedUpdateWithoutSelectionsInput>
  }

  export type UserUpdateOneWithoutCodeSelectionsNestedInput = {
    create?: XOR<UserCreateWithoutCodeSelectionsInput, UserUncheckedCreateWithoutCodeSelectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodeSelectionsInput
    upsert?: UserUpsertWithoutCodeSelectionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCodeSelectionsInput, UserUpdateWithoutCodeSelectionsInput>, UserUncheckedUpdateWithoutCodeSelectionsInput>
  }

  export type EncounterCreateNestedOneWithoutComplianceIssuesInput = {
    create?: XOR<EncounterCreateWithoutComplianceIssuesInput, EncounterUncheckedCreateWithoutComplianceIssuesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutComplianceIssuesInput
    connect?: EncounterWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutComplianceIssuesInput = {
    create?: XOR<UserCreateWithoutComplianceIssuesInput, UserUncheckedCreateWithoutComplianceIssuesInput>
    connectOrCreate?: UserCreateOrConnectWithoutComplianceIssuesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumComplianceSeverityFieldUpdateOperationsInput = {
    set?: $Enums.ComplianceSeverity
  }

  export type EnumComplianceStatusFieldUpdateOperationsInput = {
    set?: $Enums.ComplianceStatus
  }

  export type EncounterUpdateOneRequiredWithoutComplianceIssuesNestedInput = {
    create?: XOR<EncounterCreateWithoutComplianceIssuesInput, EncounterUncheckedCreateWithoutComplianceIssuesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutComplianceIssuesInput
    upsert?: EncounterUpsertWithoutComplianceIssuesInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutComplianceIssuesInput, EncounterUpdateWithoutComplianceIssuesInput>, EncounterUncheckedUpdateWithoutComplianceIssuesInput>
  }

  export type UserUpdateOneWithoutComplianceIssuesNestedInput = {
    create?: XOR<UserCreateWithoutComplianceIssuesInput, UserUncheckedCreateWithoutComplianceIssuesInput>
    connectOrCreate?: UserCreateOrConnectWithoutComplianceIssuesInput
    upsert?: UserUpsertWithoutComplianceIssuesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutComplianceIssuesInput, UserUpdateWithoutComplianceIssuesInput>, UserUncheckedUpdateWithoutComplianceIssuesInput>
  }

  export type EncounterCreateNestedOneWithoutWizardRunsInput = {
    create?: XOR<EncounterCreateWithoutWizardRunsInput, EncounterUncheckedCreateWithoutWizardRunsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutWizardRunsInput
    connect?: EncounterWhereUniqueInput
  }

  export type WizardStepStateCreateNestedManyWithoutWizardRunInput = {
    create?: XOR<WizardStepStateCreateWithoutWizardRunInput, WizardStepStateUncheckedCreateWithoutWizardRunInput> | WizardStepStateCreateWithoutWizardRunInput[] | WizardStepStateUncheckedCreateWithoutWizardRunInput[]
    connectOrCreate?: WizardStepStateCreateOrConnectWithoutWizardRunInput | WizardStepStateCreateOrConnectWithoutWizardRunInput[]
    createMany?: WizardStepStateCreateManyWizardRunInputEnvelope
    connect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
  }

  export type WizardStepStateUncheckedCreateNestedManyWithoutWizardRunInput = {
    create?: XOR<WizardStepStateCreateWithoutWizardRunInput, WizardStepStateUncheckedCreateWithoutWizardRunInput> | WizardStepStateCreateWithoutWizardRunInput[] | WizardStepStateUncheckedCreateWithoutWizardRunInput[]
    connectOrCreate?: WizardStepStateCreateOrConnectWithoutWizardRunInput | WizardStepStateCreateOrConnectWithoutWizardRunInput[]
    createMany?: WizardStepStateCreateManyWizardRunInputEnvelope
    connect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
  }

  export type EnumWizardRunStatusFieldUpdateOperationsInput = {
    set?: $Enums.WizardRunStatus
  }

  export type EncounterUpdateOneRequiredWithoutWizardRunsNestedInput = {
    create?: XOR<EncounterCreateWithoutWizardRunsInput, EncounterUncheckedCreateWithoutWizardRunsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutWizardRunsInput
    upsert?: EncounterUpsertWithoutWizardRunsInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutWizardRunsInput, EncounterUpdateWithoutWizardRunsInput>, EncounterUncheckedUpdateWithoutWizardRunsInput>
  }

  export type WizardStepStateUpdateManyWithoutWizardRunNestedInput = {
    create?: XOR<WizardStepStateCreateWithoutWizardRunInput, WizardStepStateUncheckedCreateWithoutWizardRunInput> | WizardStepStateCreateWithoutWizardRunInput[] | WizardStepStateUncheckedCreateWithoutWizardRunInput[]
    connectOrCreate?: WizardStepStateCreateOrConnectWithoutWizardRunInput | WizardStepStateCreateOrConnectWithoutWizardRunInput[]
    upsert?: WizardStepStateUpsertWithWhereUniqueWithoutWizardRunInput | WizardStepStateUpsertWithWhereUniqueWithoutWizardRunInput[]
    createMany?: WizardStepStateCreateManyWizardRunInputEnvelope
    set?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    disconnect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    delete?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    connect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    update?: WizardStepStateUpdateWithWhereUniqueWithoutWizardRunInput | WizardStepStateUpdateWithWhereUniqueWithoutWizardRunInput[]
    updateMany?: WizardStepStateUpdateManyWithWhereWithoutWizardRunInput | WizardStepStateUpdateManyWithWhereWithoutWizardRunInput[]
    deleteMany?: WizardStepStateScalarWhereInput | WizardStepStateScalarWhereInput[]
  }

  export type WizardStepStateUncheckedUpdateManyWithoutWizardRunNestedInput = {
    create?: XOR<WizardStepStateCreateWithoutWizardRunInput, WizardStepStateUncheckedCreateWithoutWizardRunInput> | WizardStepStateCreateWithoutWizardRunInput[] | WizardStepStateUncheckedCreateWithoutWizardRunInput[]
    connectOrCreate?: WizardStepStateCreateOrConnectWithoutWizardRunInput | WizardStepStateCreateOrConnectWithoutWizardRunInput[]
    upsert?: WizardStepStateUpsertWithWhereUniqueWithoutWizardRunInput | WizardStepStateUpsertWithWhereUniqueWithoutWizardRunInput[]
    createMany?: WizardStepStateCreateManyWizardRunInputEnvelope
    set?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    disconnect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    delete?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    connect?: WizardStepStateWhereUniqueInput | WizardStepStateWhereUniqueInput[]
    update?: WizardStepStateUpdateWithWhereUniqueWithoutWizardRunInput | WizardStepStateUpdateWithWhereUniqueWithoutWizardRunInput[]
    updateMany?: WizardStepStateUpdateManyWithWhereWithoutWizardRunInput | WizardStepStateUpdateManyWithWhereWithoutWizardRunInput[]
    deleteMany?: WizardStepStateScalarWhereInput | WizardStepStateScalarWhereInput[]
  }

  export type WizardRunCreateNestedOneWithoutStepStatesInput = {
    create?: XOR<WizardRunCreateWithoutStepStatesInput, WizardRunUncheckedCreateWithoutStepStatesInput>
    connectOrCreate?: WizardRunCreateOrConnectWithoutStepStatesInput
    connect?: WizardRunWhereUniqueInput
  }

  export type EncounterCreateNestedOneWithoutWizardStepStatesInput = {
    create?: XOR<EncounterCreateWithoutWizardStepStatesInput, EncounterUncheckedCreateWithoutWizardStepStatesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutWizardStepStatesInput
    connect?: EncounterWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWizardStepStatesInput = {
    create?: XOR<UserCreateWithoutWizardStepStatesInput, UserUncheckedCreateWithoutWizardStepStatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWizardStepStatesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumWizardStepFieldUpdateOperationsInput = {
    set?: $Enums.WizardStep
  }

  export type EnumWizardStepStatusFieldUpdateOperationsInput = {
    set?: $Enums.WizardStepStatus
  }

  export type WizardRunUpdateOneRequiredWithoutStepStatesNestedInput = {
    create?: XOR<WizardRunCreateWithoutStepStatesInput, WizardRunUncheckedCreateWithoutStepStatesInput>
    connectOrCreate?: WizardRunCreateOrConnectWithoutStepStatesInput
    upsert?: WizardRunUpsertWithoutStepStatesInput
    connect?: WizardRunWhereUniqueInput
    update?: XOR<XOR<WizardRunUpdateToOneWithWhereWithoutStepStatesInput, WizardRunUpdateWithoutStepStatesInput>, WizardRunUncheckedUpdateWithoutStepStatesInput>
  }

  export type EncounterUpdateOneRequiredWithoutWizardStepStatesNestedInput = {
    create?: XOR<EncounterCreateWithoutWizardStepStatesInput, EncounterUncheckedCreateWithoutWizardStepStatesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutWizardStepStatesInput
    upsert?: EncounterUpsertWithoutWizardStepStatesInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutWizardStepStatesInput, EncounterUpdateWithoutWizardStepStatesInput>, EncounterUncheckedUpdateWithoutWizardStepStatesInput>
  }

  export type UserUpdateOneWithoutWizardStepStatesNestedInput = {
    create?: XOR<UserCreateWithoutWizardStepStatesInput, UserUncheckedCreateWithoutWizardStepStatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWizardStepStatesInput
    upsert?: UserUpsertWithoutWizardStepStatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWizardStepStatesInput, UserUpdateWithoutWizardStepStatesInput>, UserUncheckedUpdateWithoutWizardStepStatesInput>
  }

  export type EncounterCreateNestedOneWithoutExportArtifactsInput = {
    create?: XOR<EncounterCreateWithoutExportArtifactsInput, EncounterUncheckedCreateWithoutExportArtifactsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutExportArtifactsInput
    connect?: EncounterWhereUniqueInput
  }

  export type NoteCreateNestedOneWithoutExportArtifactsInput = {
    create?: XOR<NoteCreateWithoutExportArtifactsInput, NoteUncheckedCreateWithoutExportArtifactsInput>
    connectOrCreate?: NoteCreateOrConnectWithoutExportArtifactsInput
    connect?: NoteWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExportArtifactsInput = {
    create?: XOR<UserCreateWithoutExportArtifactsInput, UserUncheckedCreateWithoutExportArtifactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExportArtifactsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumArtifactTypeFieldUpdateOperationsInput = {
    set?: $Enums.ArtifactType
  }

  export type EncounterUpdateOneRequiredWithoutExportArtifactsNestedInput = {
    create?: XOR<EncounterCreateWithoutExportArtifactsInput, EncounterUncheckedCreateWithoutExportArtifactsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutExportArtifactsInput
    upsert?: EncounterUpsertWithoutExportArtifactsInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutExportArtifactsInput, EncounterUpdateWithoutExportArtifactsInput>, EncounterUncheckedUpdateWithoutExportArtifactsInput>
  }

  export type NoteUpdateOneWithoutExportArtifactsNestedInput = {
    create?: XOR<NoteCreateWithoutExportArtifactsInput, NoteUncheckedCreateWithoutExportArtifactsInput>
    connectOrCreate?: NoteCreateOrConnectWithoutExportArtifactsInput
    upsert?: NoteUpsertWithoutExportArtifactsInput
    disconnect?: NoteWhereInput | boolean
    delete?: NoteWhereInput | boolean
    connect?: NoteWhereUniqueInput
    update?: XOR<XOR<NoteUpdateToOneWithWhereWithoutExportArtifactsInput, NoteUpdateWithoutExportArtifactsInput>, NoteUncheckedUpdateWithoutExportArtifactsInput>
  }

  export type UserUpdateOneWithoutExportArtifactsNestedInput = {
    create?: XOR<UserCreateWithoutExportArtifactsInput, UserUncheckedCreateWithoutExportArtifactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExportArtifactsInput
    upsert?: UserUpsertWithoutExportArtifactsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExportArtifactsInput, UserUpdateWithoutExportArtifactsInput>, UserUncheckedUpdateWithoutExportArtifactsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EncounterCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<EncounterCreateWithoutAuditLogsInput, EncounterUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutAuditLogsInput
    connect?: EncounterWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type EncounterUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<EncounterCreateWithoutAuditLogsInput, EncounterUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutAuditLogsInput
    upsert?: EncounterUpsertWithoutAuditLogsInput
    disconnect?: EncounterWhereInput | boolean
    delete?: EncounterWhereInput | boolean
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutAuditLogsInput, EncounterUpdateWithoutAuditLogsInput>, EncounterUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutAuthSessionsInput = {
    create?: XOR<UserCreateWithoutAuthSessionsInput, UserUncheckedCreateWithoutAuthSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuthSessionsNestedInput = {
    create?: XOR<UserCreateWithoutAuthSessionsInput, UserUncheckedCreateWithoutAuthSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthSessionsInput
    upsert?: UserUpsertWithoutAuthSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthSessionsInput, UserUpdateWithoutAuthSessionsInput>, UserUncheckedUpdateWithoutAuthSessionsInput>
  }

  export type EncounterCreateNestedOneWithoutDispatchJobsInput = {
    create?: XOR<EncounterCreateWithoutDispatchJobsInput, EncounterUncheckedCreateWithoutDispatchJobsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutDispatchJobsInput
    connect?: EncounterWhereUniqueInput
  }

  export type NoteCreateNestedOneWithoutDispatchJobsInput = {
    create?: XOR<NoteCreateWithoutDispatchJobsInput, NoteUncheckedCreateWithoutDispatchJobsInput>
    connectOrCreate?: NoteCreateOrConnectWithoutDispatchJobsInput
    connect?: NoteWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDispatchJobsInput = {
    create?: XOR<UserCreateWithoutDispatchJobsInput, UserUncheckedCreateWithoutDispatchJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDispatchJobsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDispatchTargetFieldUpdateOperationsInput = {
    set?: $Enums.DispatchTarget
  }

  export type EnumDispatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.DispatchStatus
  }

  export type EncounterUpdateOneRequiredWithoutDispatchJobsNestedInput = {
    create?: XOR<EncounterCreateWithoutDispatchJobsInput, EncounterUncheckedCreateWithoutDispatchJobsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutDispatchJobsInput
    upsert?: EncounterUpsertWithoutDispatchJobsInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutDispatchJobsInput, EncounterUpdateWithoutDispatchJobsInput>, EncounterUncheckedUpdateWithoutDispatchJobsInput>
  }

  export type NoteUpdateOneWithoutDispatchJobsNestedInput = {
    create?: XOR<NoteCreateWithoutDispatchJobsInput, NoteUncheckedCreateWithoutDispatchJobsInput>
    connectOrCreate?: NoteCreateOrConnectWithoutDispatchJobsInput
    upsert?: NoteUpsertWithoutDispatchJobsInput
    disconnect?: NoteWhereInput | boolean
    delete?: NoteWhereInput | boolean
    connect?: NoteWhereUniqueInput
    update?: XOR<XOR<NoteUpdateToOneWithWhereWithoutDispatchJobsInput, NoteUpdateWithoutDispatchJobsInput>, NoteUncheckedUpdateWithoutDispatchJobsInput>
  }

  export type UserUpdateOneWithoutDispatchJobsNestedInput = {
    create?: XOR<UserCreateWithoutDispatchJobsInput, UserUncheckedCreateWithoutDispatchJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDispatchJobsInput
    upsert?: UserUpsertWithoutDispatchJobsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDispatchJobsInput, UserUpdateWithoutDispatchJobsInput>, UserUncheckedUpdateWithoutDispatchJobsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedEnumAppointmentPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentPriority | EnumAppointmentPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentPriority[] | ListEnumAppointmentPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentPriority[] | ListEnumAppointmentPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentPriorityFilter<$PrismaModel> | $Enums.AppointmentPriority
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentPriority | EnumAppointmentPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentPriority[] | ListEnumAppointmentPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentPriority[] | ListEnumAppointmentPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentPriorityWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentPriorityFilter<$PrismaModel>
    _max?: NestedEnumAppointmentPriorityFilter<$PrismaModel>
  }

  export type NestedEnumEncounterStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterStatus | EnumEncounterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterStatus[] | ListEnumEncounterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EncounterStatus[] | ListEnumEncounterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEncounterStatusFilter<$PrismaModel> | $Enums.EncounterStatus
  }

  export type NestedEnumEncounterStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterStatus | EnumEncounterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterStatus[] | ListEnumEncounterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EncounterStatus[] | ListEnumEncounterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEncounterStatusWithAggregatesFilter<$PrismaModel> | $Enums.EncounterStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEncounterStatusFilter<$PrismaModel>
    _max?: NestedEnumEncounterStatusFilter<$PrismaModel>
  }

  export type NestedEnumNoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteStatus | EnumNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NoteStatus[] | ListEnumNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteStatus[] | ListEnumNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteStatusFilter<$PrismaModel> | $Enums.NoteStatus
  }

  export type NestedEnumNoteVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteVisibility | EnumNoteVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.NoteVisibility[] | ListEnumNoteVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteVisibility[] | ListEnumNoteVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteVisibilityFilter<$PrismaModel> | $Enums.NoteVisibility
  }

  export type NestedEnumNoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteStatus | EnumNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NoteStatus[] | ListEnumNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteStatus[] | ListEnumNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.NoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteStatusFilter<$PrismaModel>
    _max?: NestedEnumNoteStatusFilter<$PrismaModel>
  }

  export type NestedEnumNoteVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteVisibility | EnumNoteVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.NoteVisibility[] | ListEnumNoteVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteVisibility[] | ListEnumNoteVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.NoteVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteVisibilityFilter<$PrismaModel>
    _max?: NestedEnumNoteVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumTranscriptSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptSource | EnumTranscriptSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptSource[] | ListEnumTranscriptSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptSource[] | ListEnumTranscriptSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptSourceFilter<$PrismaModel> | $Enums.TranscriptSource
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTranscriptSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptSource | EnumTranscriptSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptSource[] | ListEnumTranscriptSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptSource[] | ListEnumTranscriptSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptSourceWithAggregatesFilter<$PrismaModel> | $Enums.TranscriptSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranscriptSourceFilter<$PrismaModel>
    _max?: NestedEnumTranscriptSourceFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumSuggestionCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SuggestionCategory | EnumSuggestionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SuggestionCategory[] | ListEnumSuggestionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SuggestionCategory[] | ListEnumSuggestionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSuggestionCategoryFilter<$PrismaModel> | $Enums.SuggestionCategory
  }

  export type NestedEnumSuggestionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SuggestionStatus | EnumSuggestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SuggestionStatus[] | ListEnumSuggestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SuggestionStatus[] | ListEnumSuggestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSuggestionStatusFilter<$PrismaModel> | $Enums.SuggestionStatus
  }

  export type NestedEnumSuggestionCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SuggestionCategory | EnumSuggestionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SuggestionCategory[] | ListEnumSuggestionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SuggestionCategory[] | ListEnumSuggestionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSuggestionCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SuggestionCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSuggestionCategoryFilter<$PrismaModel>
    _max?: NestedEnumSuggestionCategoryFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumSuggestionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SuggestionStatus | EnumSuggestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SuggestionStatus[] | ListEnumSuggestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SuggestionStatus[] | ListEnumSuggestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSuggestionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SuggestionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSuggestionStatusFilter<$PrismaModel>
    _max?: NestedEnumSuggestionStatusFilter<$PrismaModel>
  }

  export type NestedEnumSelectionActionFilter<$PrismaModel = never> = {
    equals?: $Enums.SelectionAction | EnumSelectionActionFieldRefInput<$PrismaModel>
    in?: $Enums.SelectionAction[] | ListEnumSelectionActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SelectionAction[] | ListEnumSelectionActionFieldRefInput<$PrismaModel>
    not?: NestedEnumSelectionActionFilter<$PrismaModel> | $Enums.SelectionAction
  }

  export type NestedEnumSelectionActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SelectionAction | EnumSelectionActionFieldRefInput<$PrismaModel>
    in?: $Enums.SelectionAction[] | ListEnumSelectionActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SelectionAction[] | ListEnumSelectionActionFieldRefInput<$PrismaModel>
    not?: NestedEnumSelectionActionWithAggregatesFilter<$PrismaModel> | $Enums.SelectionAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSelectionActionFilter<$PrismaModel>
    _max?: NestedEnumSelectionActionFilter<$PrismaModel>
  }

  export type NestedEnumComplianceSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceSeverity | EnumComplianceSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceSeverity[] | ListEnumComplianceSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceSeverity[] | ListEnumComplianceSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceSeverityFilter<$PrismaModel> | $Enums.ComplianceSeverity
  }

  export type NestedEnumComplianceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusFilter<$PrismaModel> | $Enums.ComplianceStatus
  }

  export type NestedEnumComplianceSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceSeverity | EnumComplianceSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceSeverity[] | ListEnumComplianceSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceSeverity[] | ListEnumComplianceSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceSeverityWithAggregatesFilter<$PrismaModel> | $Enums.ComplianceSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplianceSeverityFilter<$PrismaModel>
    _max?: NestedEnumComplianceSeverityFilter<$PrismaModel>
  }

  export type NestedEnumComplianceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplianceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplianceStatusFilter<$PrismaModel>
    _max?: NestedEnumComplianceStatusFilter<$PrismaModel>
  }

  export type NestedEnumWizardRunStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WizardRunStatus | EnumWizardRunStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WizardRunStatus[] | ListEnumWizardRunStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WizardRunStatus[] | ListEnumWizardRunStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWizardRunStatusFilter<$PrismaModel> | $Enums.WizardRunStatus
  }

  export type NestedEnumWizardRunStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WizardRunStatus | EnumWizardRunStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WizardRunStatus[] | ListEnumWizardRunStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WizardRunStatus[] | ListEnumWizardRunStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWizardRunStatusWithAggregatesFilter<$PrismaModel> | $Enums.WizardRunStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWizardRunStatusFilter<$PrismaModel>
    _max?: NestedEnumWizardRunStatusFilter<$PrismaModel>
  }

  export type NestedEnumWizardStepFilter<$PrismaModel = never> = {
    equals?: $Enums.WizardStep | EnumWizardStepFieldRefInput<$PrismaModel>
    in?: $Enums.WizardStep[] | ListEnumWizardStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.WizardStep[] | ListEnumWizardStepFieldRefInput<$PrismaModel>
    not?: NestedEnumWizardStepFilter<$PrismaModel> | $Enums.WizardStep
  }

  export type NestedEnumWizardStepStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WizardStepStatus | EnumWizardStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WizardStepStatus[] | ListEnumWizardStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WizardStepStatus[] | ListEnumWizardStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWizardStepStatusFilter<$PrismaModel> | $Enums.WizardStepStatus
  }

  export type NestedEnumWizardStepWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WizardStep | EnumWizardStepFieldRefInput<$PrismaModel>
    in?: $Enums.WizardStep[] | ListEnumWizardStepFieldRefInput<$PrismaModel>
    notIn?: $Enums.WizardStep[] | ListEnumWizardStepFieldRefInput<$PrismaModel>
    not?: NestedEnumWizardStepWithAggregatesFilter<$PrismaModel> | $Enums.WizardStep
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWizardStepFilter<$PrismaModel>
    _max?: NestedEnumWizardStepFilter<$PrismaModel>
  }

  export type NestedEnumWizardStepStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WizardStepStatus | EnumWizardStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WizardStepStatus[] | ListEnumWizardStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WizardStepStatus[] | ListEnumWizardStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWizardStepStatusWithAggregatesFilter<$PrismaModel> | $Enums.WizardStepStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWizardStepStatusFilter<$PrismaModel>
    _max?: NestedEnumWizardStepStatusFilter<$PrismaModel>
  }

  export type NestedEnumArtifactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtifactType | EnumArtifactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtifactTypeFilter<$PrismaModel> | $Enums.ArtifactType
  }

  export type NestedEnumArtifactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtifactType | EnumArtifactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtifactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ArtifactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArtifactTypeFilter<$PrismaModel>
    _max?: NestedEnumArtifactTypeFilter<$PrismaModel>
  }

  export type NestedEnumDispatchTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.DispatchTarget | EnumDispatchTargetFieldRefInput<$PrismaModel>
    in?: $Enums.DispatchTarget[] | ListEnumDispatchTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.DispatchTarget[] | ListEnumDispatchTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumDispatchTargetFilter<$PrismaModel> | $Enums.DispatchTarget
  }

  export type NestedEnumDispatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DispatchStatus | EnumDispatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DispatchStatus[] | ListEnumDispatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DispatchStatus[] | ListEnumDispatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDispatchStatusFilter<$PrismaModel> | $Enums.DispatchStatus
  }

  export type NestedEnumDispatchTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DispatchTarget | EnumDispatchTargetFieldRefInput<$PrismaModel>
    in?: $Enums.DispatchTarget[] | ListEnumDispatchTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.DispatchTarget[] | ListEnumDispatchTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumDispatchTargetWithAggregatesFilter<$PrismaModel> | $Enums.DispatchTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDispatchTargetFilter<$PrismaModel>
    _max?: NestedEnumDispatchTargetFilter<$PrismaModel>
  }

  export type NestedEnumDispatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DispatchStatus | EnumDispatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DispatchStatus[] | ListEnumDispatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DispatchStatus[] | ListEnumDispatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDispatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.DispatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDispatchStatusFilter<$PrismaModel>
    _max?: NestedEnumDispatchStatusFilter<$PrismaModel>
  }

  export type AppointmentCreateWithoutCreatedByInput = {
    id?: string
    externalId: string
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    provider?: UserCreateNestedOneWithoutAppointmentsProvidedInput
    encounter?: EncounterCreateNestedOneWithoutAppointmentInput
    chartAssets?: ChartAssetCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutCreatedByInput = {
    id?: string
    externalId: string
    patientId: string
    providerId?: string | null
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter?: EncounterUncheckedCreateNestedOneWithoutAppointmentInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutCreatedByInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutCreatedByInput, AppointmentUncheckedCreateWithoutCreatedByInput>
  }

  export type AppointmentCreateManyCreatedByInputEnvelope = {
    data: AppointmentCreateManyCreatedByInput | AppointmentCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutProviderInput = {
    id?: string
    externalId: string
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    createdBy?: UserCreateNestedOneWithoutAppointmentsCreatedInput
    encounter?: EncounterCreateNestedOneWithoutAppointmentInput
    chartAssets?: ChartAssetCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutProviderInput = {
    id?: string
    externalId: string
    patientId: string
    createdById?: string | null
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter?: EncounterUncheckedCreateNestedOneWithoutAppointmentInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutProviderInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput>
  }

  export type AppointmentCreateManyProviderInputEnvelope = {
    data: AppointmentCreateManyProviderInput | AppointmentCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type EncounterCreateWithoutProviderInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutProviderInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutProviderInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutProviderInput, EncounterUncheckedCreateWithoutProviderInput>
  }

  export type EncounterCreateManyProviderInputEnvelope = {
    data: EncounterCreateManyProviderInput | EncounterCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutCreatedByInput = {
    id?: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutNoteInput
    updatedBy?: UserCreateNestedOneWithoutNotesUpdatedInput
    versions?: NoteVersionCreateNestedManyWithoutNoteInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutNoteInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateWithoutCreatedByInput = {
    id?: string
    encounterId: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    updatedById?: string | null
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: NoteVersionUncheckedCreateNestedManyWithoutNoteInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutNoteInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteCreateOrConnectWithoutCreatedByInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutCreatedByInput, NoteUncheckedCreateWithoutCreatedByInput>
  }

  export type NoteCreateManyCreatedByInputEnvelope = {
    data: NoteCreateManyCreatedByInput | NoteCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutUpdatedByInput = {
    id?: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutNoteInput
    createdBy?: UserCreateNestedOneWithoutNotesCreatedInput
    versions?: NoteVersionCreateNestedManyWithoutNoteInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutNoteInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    encounterId: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    createdById?: string | null
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: NoteVersionUncheckedCreateNestedManyWithoutNoteInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutNoteInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteCreateOrConnectWithoutUpdatedByInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutUpdatedByInput, NoteUncheckedCreateWithoutUpdatedByInput>
  }

  export type NoteCreateManyUpdatedByInputEnvelope = {
    data: NoteCreateManyUpdatedByInput | NoteCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type NoteVersionCreateWithoutCreatedByInput = {
    id?: string
    versionNumber: number
    source: string
    content: string
    patientSummary: string
    traceId?: string | null
    createdAt?: Date | string
    note: NoteCreateNestedOneWithoutVersionsInput
  }

  export type NoteVersionUncheckedCreateWithoutCreatedByInput = {
    id?: string
    noteId: string
    versionNumber: number
    source: string
    content: string
    patientSummary: string
    traceId?: string | null
    createdAt?: Date | string
  }

  export type NoteVersionCreateOrConnectWithoutCreatedByInput = {
    where: NoteVersionWhereUniqueInput
    create: XOR<NoteVersionCreateWithoutCreatedByInput, NoteVersionUncheckedCreateWithoutCreatedByInput>
  }

  export type NoteVersionCreateManyCreatedByInputEnvelope = {
    data: NoteVersionCreateManyCreatedByInput | NoteVersionCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ChartAssetCreateWithoutCreatedByInput = {
    id?: string
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutChartAssetsInput
    encounter?: EncounterCreateNestedOneWithoutChartAssetsInput
    patient?: PatientCreateNestedOneWithoutChartAssetsInput
  }

  export type ChartAssetUncheckedCreateWithoutCreatedByInput = {
    id?: string
    appointmentId?: string | null
    encounterId?: string | null
    patientId?: string | null
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdAt?: Date | string
  }

  export type ChartAssetCreateOrConnectWithoutCreatedByInput = {
    where: ChartAssetWhereUniqueInput
    create: XOR<ChartAssetCreateWithoutCreatedByInput, ChartAssetUncheckedCreateWithoutCreatedByInput>
  }

  export type ChartAssetCreateManyCreatedByInputEnvelope = {
    data: ChartAssetCreateManyCreatedByInput | ChartAssetCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SuggestionGenerationCreateWithoutCreatedByInput = {
    id?: string
    trigger: string
    textDelta?: number
    transcriptDelta?: number
    inputHash?: string | null
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutSuggestionCyclesInput
    suggestions?: CodeSuggestionCreateNestedManyWithoutGenerationInput
  }

  export type SuggestionGenerationUncheckedCreateWithoutCreatedByInput = {
    id?: string
    encounterId: string
    trigger: string
    textDelta?: number
    transcriptDelta?: number
    inputHash?: string | null
    createdAt?: Date | string
    suggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type SuggestionGenerationCreateOrConnectWithoutCreatedByInput = {
    where: SuggestionGenerationWhereUniqueInput
    create: XOR<SuggestionGenerationCreateWithoutCreatedByInput, SuggestionGenerationUncheckedCreateWithoutCreatedByInput>
  }

  export type SuggestionGenerationCreateManyCreatedByInputEnvelope = {
    data: SuggestionGenerationCreateManyCreatedByInput | SuggestionGenerationCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CodeSelectionCreateWithoutActorInput = {
    id?: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    action: $Enums.SelectionAction
    decisionReason?: string | null
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutCodeSelectionsInput
    codeSuggestion?: CodeSuggestionCreateNestedOneWithoutSelectionsInput
  }

  export type CodeSelectionUncheckedCreateWithoutActorInput = {
    id?: string
    encounterId: string
    codeSuggestionId?: string | null
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    action: $Enums.SelectionAction
    decisionReason?: string | null
    createdAt?: Date | string
  }

  export type CodeSelectionCreateOrConnectWithoutActorInput = {
    where: CodeSelectionWhereUniqueInput
    create: XOR<CodeSelectionCreateWithoutActorInput, CodeSelectionUncheckedCreateWithoutActorInput>
  }

  export type CodeSelectionCreateManyActorInputEnvelope = {
    data: CodeSelectionCreateManyActorInput | CodeSelectionCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type ComplianceIssueCreateWithoutActorInput = {
    id?: string
    severity: $Enums.ComplianceSeverity
    status?: $Enums.ComplianceStatus
    title: string
    description: string
    rationale: string
    remediation: string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint: string
    resolvedAt?: Date | string | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutComplianceIssuesInput
  }

  export type ComplianceIssueUncheckedCreateWithoutActorInput = {
    id?: string
    encounterId: string
    severity: $Enums.ComplianceSeverity
    status?: $Enums.ComplianceStatus
    title: string
    description: string
    rationale: string
    remediation: string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint: string
    resolvedAt?: Date | string | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceIssueCreateOrConnectWithoutActorInput = {
    where: ComplianceIssueWhereUniqueInput
    create: XOR<ComplianceIssueCreateWithoutActorInput, ComplianceIssueUncheckedCreateWithoutActorInput>
  }

  export type ComplianceIssueCreateManyActorInputEnvelope = {
    data: ComplianceIssueCreateManyActorInput | ComplianceIssueCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type WizardStepStateCreateWithoutLastActorInput = {
    id?: string
    step: $Enums.WizardStep
    status?: $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    wizardRun: WizardRunCreateNestedOneWithoutStepStatesInput
    encounter: EncounterCreateNestedOneWithoutWizardStepStatesInput
  }

  export type WizardStepStateUncheckedCreateWithoutLastActorInput = {
    id?: string
    wizardRunId: string
    encounterId: string
    step: $Enums.WizardStep
    status?: $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WizardStepStateCreateOrConnectWithoutLastActorInput = {
    where: WizardStepStateWhereUniqueInput
    create: XOR<WizardStepStateCreateWithoutLastActorInput, WizardStepStateUncheckedCreateWithoutLastActorInput>
  }

  export type WizardStepStateCreateManyLastActorInputEnvelope = {
    data: WizardStepStateCreateManyLastActorInput | WizardStepStateCreateManyLastActorInput[]
    skipDuplicates?: boolean
  }

  export type ExportArtifactCreateWithoutCreatedByInput = {
    id?: string
    type: $Enums.ArtifactType
    filePath: string
    mimeType: string
    fileName: string
    sizeBytes: number
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutExportArtifactsInput
    note?: NoteCreateNestedOneWithoutExportArtifactsInput
  }

  export type ExportArtifactUncheckedCreateWithoutCreatedByInput = {
    id?: string
    encounterId: string
    noteId?: string | null
    type: $Enums.ArtifactType
    filePath: string
    mimeType: string
    fileName: string
    sizeBytes: number
    createdAt?: Date | string
  }

  export type ExportArtifactCreateOrConnectWithoutCreatedByInput = {
    where: ExportArtifactWhereUniqueInput
    create: XOR<ExportArtifactCreateWithoutCreatedByInput, ExportArtifactUncheckedCreateWithoutCreatedByInput>
  }

  export type ExportArtifactCreateManyCreatedByInputEnvelope = {
    data: ExportArtifactCreateManyCreatedByInput | ExportArtifactCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutActorInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    encounter?: EncounterCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: string
    encounterId?: string | null
    action: string
    entity: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type AuthSessionCreateWithoutUserInput = {
    id?: string
    refreshTokenHash: string
    expiresAt: Date | string
    revokedAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthSessionUncheckedCreateWithoutUserInput = {
    id?: string
    refreshTokenHash: string
    expiresAt: Date | string
    revokedAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthSessionCreateOrConnectWithoutUserInput = {
    where: AuthSessionWhereUniqueInput
    create: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput>
  }

  export type AuthSessionCreateManyUserInputEnvelope = {
    data: AuthSessionCreateManyUserInput | AuthSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DispatchJobCreateWithoutCreatedByInput = {
    id?: string
    target?: $Enums.DispatchTarget
    status?: $Enums.DispatchStatus
    contractType?: string | null
    attemptCount?: number
    maxAttempts?: number
    nextRetryAt?: Date | string | null
    dispatchedAt?: Date | string | null
    deadLetteredAt?: Date | string | null
    externalMessageId?: string | null
    lastError?: string | null
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutDispatchJobsInput
    note?: NoteCreateNestedOneWithoutDispatchJobsInput
  }

  export type DispatchJobUncheckedCreateWithoutCreatedByInput = {
    id?: string
    encounterId: string
    noteId?: string | null
    target?: $Enums.DispatchTarget
    status?: $Enums.DispatchStatus
    contractType?: string | null
    attemptCount?: number
    maxAttempts?: number
    nextRetryAt?: Date | string | null
    dispatchedAt?: Date | string | null
    deadLetteredAt?: Date | string | null
    externalMessageId?: string | null
    lastError?: string | null
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DispatchJobCreateOrConnectWithoutCreatedByInput = {
    where: DispatchJobWhereUniqueInput
    create: XOR<DispatchJobCreateWithoutCreatedByInput, DispatchJobUncheckedCreateWithoutCreatedByInput>
  }

  export type DispatchJobCreateManyCreatedByInputEnvelope = {
    data: DispatchJobCreateManyCreatedByInput | DispatchJobCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingsCreateWithoutUserInput = {
    id?: string
    payload: JsonNullValueInput | InputJsonValue
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    payload: JsonNullValueInput | InputJsonValue
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutCreatedByInput, AppointmentUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AppointmentCreateWithoutCreatedByInput, AppointmentUncheckedCreateWithoutCreatedByInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutCreatedByInput, AppointmentUncheckedUpdateWithoutCreatedByInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutCreatedByInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    externalId?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    providerId?: StringNullableFilter<"Appointment"> | string | null
    createdById?: StringNullableFilter<"Appointment"> | string | null
    scheduledAt?: DateTimeFilter<"Appointment"> | Date | string
    durationMinutes?: IntFilter<"Appointment"> | number
    appointmentType?: StringFilter<"Appointment"> | string
    location?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFilter<"Appointment"> | $Enums.AppointmentPriority
    isVirtual?: BoolFilter<"Appointment"> | boolean
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutProviderInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutProviderInput, AppointmentUncheckedUpdateWithoutProviderInput>
    create: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutProviderInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutProviderInput, AppointmentUncheckedUpdateWithoutProviderInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutProviderInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutProviderInput>
  }

  export type EncounterUpsertWithWhereUniqueWithoutProviderInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutProviderInput, EncounterUncheckedUpdateWithoutProviderInput>
    create: XOR<EncounterCreateWithoutProviderInput, EncounterUncheckedCreateWithoutProviderInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutProviderInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutProviderInput, EncounterUncheckedUpdateWithoutProviderInput>
  }

  export type EncounterUpdateManyWithWhereWithoutProviderInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutProviderInput>
  }

  export type EncounterScalarWhereInput = {
    AND?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    OR?: EncounterScalarWhereInput[]
    NOT?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    id?: StringFilter<"Encounter"> | string
    externalId?: StringFilter<"Encounter"> | string
    appointmentId?: StringNullableFilter<"Encounter"> | string | null
    patientId?: StringFilter<"Encounter"> | string
    providerId?: StringNullableFilter<"Encounter"> | string | null
    status?: EnumEncounterStatusFilter<"Encounter"> | $Enums.EncounterStatus
    startedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    stoppedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    hiddenDraftCreated?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    draftUnhiddenAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    finalizedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeFilter<"Encounter"> | Date | string
  }

  export type NoteUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutCreatedByInput, NoteUncheckedUpdateWithoutCreatedByInput>
    create: XOR<NoteCreateWithoutCreatedByInput, NoteUncheckedCreateWithoutCreatedByInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutCreatedByInput, NoteUncheckedUpdateWithoutCreatedByInput>
  }

  export type NoteUpdateManyWithWhereWithoutCreatedByInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type NoteScalarWhereInput = {
    AND?: NoteScalarWhereInput | NoteScalarWhereInput[]
    OR?: NoteScalarWhereInput[]
    NOT?: NoteScalarWhereInput | NoteScalarWhereInput[]
    id?: StringFilter<"Note"> | string
    encounterId?: StringFilter<"Note"> | string
    status?: EnumNoteStatusFilter<"Note"> | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFilter<"Note"> | $Enums.NoteVisibility
    content?: StringFilter<"Note"> | string
    patientSummary?: StringFilter<"Note"> | string
    createdById?: StringNullableFilter<"Note"> | string | null
    updatedById?: StringNullableFilter<"Note"> | string | null
    finalizedAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    lockedAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
  }

  export type NoteUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutUpdatedByInput, NoteUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<NoteCreateWithoutUpdatedByInput, NoteUncheckedCreateWithoutUpdatedByInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutUpdatedByInput, NoteUncheckedUpdateWithoutUpdatedByInput>
  }

  export type NoteUpdateManyWithWhereWithoutUpdatedByInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type NoteVersionUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: NoteVersionWhereUniqueInput
    update: XOR<NoteVersionUpdateWithoutCreatedByInput, NoteVersionUncheckedUpdateWithoutCreatedByInput>
    create: XOR<NoteVersionCreateWithoutCreatedByInput, NoteVersionUncheckedCreateWithoutCreatedByInput>
  }

  export type NoteVersionUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: NoteVersionWhereUniqueInput
    data: XOR<NoteVersionUpdateWithoutCreatedByInput, NoteVersionUncheckedUpdateWithoutCreatedByInput>
  }

  export type NoteVersionUpdateManyWithWhereWithoutCreatedByInput = {
    where: NoteVersionScalarWhereInput
    data: XOR<NoteVersionUpdateManyMutationInput, NoteVersionUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type NoteVersionScalarWhereInput = {
    AND?: NoteVersionScalarWhereInput | NoteVersionScalarWhereInput[]
    OR?: NoteVersionScalarWhereInput[]
    NOT?: NoteVersionScalarWhereInput | NoteVersionScalarWhereInput[]
    id?: StringFilter<"NoteVersion"> | string
    noteId?: StringFilter<"NoteVersion"> | string
    versionNumber?: IntFilter<"NoteVersion"> | number
    source?: StringFilter<"NoteVersion"> | string
    content?: StringFilter<"NoteVersion"> | string
    patientSummary?: StringFilter<"NoteVersion"> | string
    traceId?: StringNullableFilter<"NoteVersion"> | string | null
    createdById?: StringNullableFilter<"NoteVersion"> | string | null
    createdAt?: DateTimeFilter<"NoteVersion"> | Date | string
  }

  export type ChartAssetUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ChartAssetWhereUniqueInput
    update: XOR<ChartAssetUpdateWithoutCreatedByInput, ChartAssetUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ChartAssetCreateWithoutCreatedByInput, ChartAssetUncheckedCreateWithoutCreatedByInput>
  }

  export type ChartAssetUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ChartAssetWhereUniqueInput
    data: XOR<ChartAssetUpdateWithoutCreatedByInput, ChartAssetUncheckedUpdateWithoutCreatedByInput>
  }

  export type ChartAssetUpdateManyWithWhereWithoutCreatedByInput = {
    where: ChartAssetScalarWhereInput
    data: XOR<ChartAssetUpdateManyMutationInput, ChartAssetUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ChartAssetScalarWhereInput = {
    AND?: ChartAssetScalarWhereInput | ChartAssetScalarWhereInput[]
    OR?: ChartAssetScalarWhereInput[]
    NOT?: ChartAssetScalarWhereInput | ChartAssetScalarWhereInput[]
    id?: StringFilter<"ChartAsset"> | string
    appointmentId?: StringNullableFilter<"ChartAsset"> | string | null
    encounterId?: StringNullableFilter<"ChartAsset"> | string | null
    patientId?: StringNullableFilter<"ChartAsset"> | string | null
    fileName?: StringFilter<"ChartAsset"> | string
    mimeType?: StringFilter<"ChartAsset"> | string
    sizeBytes?: IntFilter<"ChartAsset"> | number
    storagePath?: StringFilter<"ChartAsset"> | string
    extractedJson?: JsonNullableFilter<"ChartAsset">
    rawText?: StringNullableFilter<"ChartAsset"> | string | null
    createdById?: StringNullableFilter<"ChartAsset"> | string | null
    createdAt?: DateTimeFilter<"ChartAsset"> | Date | string
  }

  export type SuggestionGenerationUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SuggestionGenerationWhereUniqueInput
    update: XOR<SuggestionGenerationUpdateWithoutCreatedByInput, SuggestionGenerationUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SuggestionGenerationCreateWithoutCreatedByInput, SuggestionGenerationUncheckedCreateWithoutCreatedByInput>
  }

  export type SuggestionGenerationUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SuggestionGenerationWhereUniqueInput
    data: XOR<SuggestionGenerationUpdateWithoutCreatedByInput, SuggestionGenerationUncheckedUpdateWithoutCreatedByInput>
  }

  export type SuggestionGenerationUpdateManyWithWhereWithoutCreatedByInput = {
    where: SuggestionGenerationScalarWhereInput
    data: XOR<SuggestionGenerationUpdateManyMutationInput, SuggestionGenerationUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SuggestionGenerationScalarWhereInput = {
    AND?: SuggestionGenerationScalarWhereInput | SuggestionGenerationScalarWhereInput[]
    OR?: SuggestionGenerationScalarWhereInput[]
    NOT?: SuggestionGenerationScalarWhereInput | SuggestionGenerationScalarWhereInput[]
    id?: StringFilter<"SuggestionGeneration"> | string
    encounterId?: StringFilter<"SuggestionGeneration"> | string
    trigger?: StringFilter<"SuggestionGeneration"> | string
    textDelta?: IntFilter<"SuggestionGeneration"> | number
    transcriptDelta?: IntFilter<"SuggestionGeneration"> | number
    inputHash?: StringNullableFilter<"SuggestionGeneration"> | string | null
    createdById?: StringNullableFilter<"SuggestionGeneration"> | string | null
    createdAt?: DateTimeFilter<"SuggestionGeneration"> | Date | string
  }

  export type CodeSelectionUpsertWithWhereUniqueWithoutActorInput = {
    where: CodeSelectionWhereUniqueInput
    update: XOR<CodeSelectionUpdateWithoutActorInput, CodeSelectionUncheckedUpdateWithoutActorInput>
    create: XOR<CodeSelectionCreateWithoutActorInput, CodeSelectionUncheckedCreateWithoutActorInput>
  }

  export type CodeSelectionUpdateWithWhereUniqueWithoutActorInput = {
    where: CodeSelectionWhereUniqueInput
    data: XOR<CodeSelectionUpdateWithoutActorInput, CodeSelectionUncheckedUpdateWithoutActorInput>
  }

  export type CodeSelectionUpdateManyWithWhereWithoutActorInput = {
    where: CodeSelectionScalarWhereInput
    data: XOR<CodeSelectionUpdateManyMutationInput, CodeSelectionUncheckedUpdateManyWithoutActorInput>
  }

  export type CodeSelectionScalarWhereInput = {
    AND?: CodeSelectionScalarWhereInput | CodeSelectionScalarWhereInput[]
    OR?: CodeSelectionScalarWhereInput[]
    NOT?: CodeSelectionScalarWhereInput | CodeSelectionScalarWhereInput[]
    id?: StringFilter<"CodeSelection"> | string
    encounterId?: StringFilter<"CodeSelection"> | string
    codeSuggestionId?: StringNullableFilter<"CodeSelection"> | string | null
    code?: StringFilter<"CodeSelection"> | string
    codeType?: StringFilter<"CodeSelection"> | string
    category?: EnumSuggestionCategoryFilter<"CodeSelection"> | $Enums.SuggestionCategory
    action?: EnumSelectionActionFilter<"CodeSelection"> | $Enums.SelectionAction
    decisionReason?: StringNullableFilter<"CodeSelection"> | string | null
    actorId?: StringNullableFilter<"CodeSelection"> | string | null
    createdAt?: DateTimeFilter<"CodeSelection"> | Date | string
  }

  export type ComplianceIssueUpsertWithWhereUniqueWithoutActorInput = {
    where: ComplianceIssueWhereUniqueInput
    update: XOR<ComplianceIssueUpdateWithoutActorInput, ComplianceIssueUncheckedUpdateWithoutActorInput>
    create: XOR<ComplianceIssueCreateWithoutActorInput, ComplianceIssueUncheckedCreateWithoutActorInput>
  }

  export type ComplianceIssueUpdateWithWhereUniqueWithoutActorInput = {
    where: ComplianceIssueWhereUniqueInput
    data: XOR<ComplianceIssueUpdateWithoutActorInput, ComplianceIssueUncheckedUpdateWithoutActorInput>
  }

  export type ComplianceIssueUpdateManyWithWhereWithoutActorInput = {
    where: ComplianceIssueScalarWhereInput
    data: XOR<ComplianceIssueUpdateManyMutationInput, ComplianceIssueUncheckedUpdateManyWithoutActorInput>
  }

  export type ComplianceIssueScalarWhereInput = {
    AND?: ComplianceIssueScalarWhereInput | ComplianceIssueScalarWhereInput[]
    OR?: ComplianceIssueScalarWhereInput[]
    NOT?: ComplianceIssueScalarWhereInput | ComplianceIssueScalarWhereInput[]
    id?: StringFilter<"ComplianceIssue"> | string
    encounterId?: StringFilter<"ComplianceIssue"> | string
    severity?: EnumComplianceSeverityFilter<"ComplianceIssue"> | $Enums.ComplianceSeverity
    status?: EnumComplianceStatusFilter<"ComplianceIssue"> | $Enums.ComplianceStatus
    title?: StringFilter<"ComplianceIssue"> | string
    description?: StringFilter<"ComplianceIssue"> | string
    rationale?: StringFilter<"ComplianceIssue"> | string
    remediation?: StringFilter<"ComplianceIssue"> | string
    evidence?: JsonNullableFilter<"ComplianceIssue">
    fingerprint?: StringFilter<"ComplianceIssue"> | string
    actorId?: StringNullableFilter<"ComplianceIssue"> | string | null
    resolvedAt?: DateTimeNullableFilter<"ComplianceIssue"> | Date | string | null
    dismissedAt?: DateTimeNullableFilter<"ComplianceIssue"> | Date | string | null
    createdAt?: DateTimeFilter<"ComplianceIssue"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceIssue"> | Date | string
  }

  export type WizardStepStateUpsertWithWhereUniqueWithoutLastActorInput = {
    where: WizardStepStateWhereUniqueInput
    update: XOR<WizardStepStateUpdateWithoutLastActorInput, WizardStepStateUncheckedUpdateWithoutLastActorInput>
    create: XOR<WizardStepStateCreateWithoutLastActorInput, WizardStepStateUncheckedCreateWithoutLastActorInput>
  }

  export type WizardStepStateUpdateWithWhereUniqueWithoutLastActorInput = {
    where: WizardStepStateWhereUniqueInput
    data: XOR<WizardStepStateUpdateWithoutLastActorInput, WizardStepStateUncheckedUpdateWithoutLastActorInput>
  }

  export type WizardStepStateUpdateManyWithWhereWithoutLastActorInput = {
    where: WizardStepStateScalarWhereInput
    data: XOR<WizardStepStateUpdateManyMutationInput, WizardStepStateUncheckedUpdateManyWithoutLastActorInput>
  }

  export type WizardStepStateScalarWhereInput = {
    AND?: WizardStepStateScalarWhereInput | WizardStepStateScalarWhereInput[]
    OR?: WizardStepStateScalarWhereInput[]
    NOT?: WizardStepStateScalarWhereInput | WizardStepStateScalarWhereInput[]
    id?: StringFilter<"WizardStepState"> | string
    wizardRunId?: StringFilter<"WizardStepState"> | string
    encounterId?: StringFilter<"WizardStepState"> | string
    step?: EnumWizardStepFilter<"WizardStepState"> | $Enums.WizardStep
    status?: EnumWizardStepStatusFilter<"WizardStepState"> | $Enums.WizardStepStatus
    payload?: JsonNullableFilter<"WizardStepState">
    lastActorId?: StringNullableFilter<"WizardStepState"> | string | null
    createdAt?: DateTimeFilter<"WizardStepState"> | Date | string
    updatedAt?: DateTimeFilter<"WizardStepState"> | Date | string
  }

  export type ExportArtifactUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ExportArtifactWhereUniqueInput
    update: XOR<ExportArtifactUpdateWithoutCreatedByInput, ExportArtifactUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ExportArtifactCreateWithoutCreatedByInput, ExportArtifactUncheckedCreateWithoutCreatedByInput>
  }

  export type ExportArtifactUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ExportArtifactWhereUniqueInput
    data: XOR<ExportArtifactUpdateWithoutCreatedByInput, ExportArtifactUncheckedUpdateWithoutCreatedByInput>
  }

  export type ExportArtifactUpdateManyWithWhereWithoutCreatedByInput = {
    where: ExportArtifactScalarWhereInput
    data: XOR<ExportArtifactUpdateManyMutationInput, ExportArtifactUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ExportArtifactScalarWhereInput = {
    AND?: ExportArtifactScalarWhereInput | ExportArtifactScalarWhereInput[]
    OR?: ExportArtifactScalarWhereInput[]
    NOT?: ExportArtifactScalarWhereInput | ExportArtifactScalarWhereInput[]
    id?: StringFilter<"ExportArtifact"> | string
    encounterId?: StringFilter<"ExportArtifact"> | string
    noteId?: StringNullableFilter<"ExportArtifact"> | string | null
    type?: EnumArtifactTypeFilter<"ExportArtifact"> | $Enums.ArtifactType
    filePath?: StringFilter<"ExportArtifact"> | string
    mimeType?: StringFilter<"ExportArtifact"> | string
    fileName?: StringFilter<"ExportArtifact"> | string
    sizeBytes?: IntFilter<"ExportArtifact"> | number
    createdById?: StringNullableFilter<"ExportArtifact"> | string | null
    createdAt?: DateTimeFilter<"ExportArtifact"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    encounterId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuthSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: AuthSessionWhereUniqueInput
    update: XOR<AuthSessionUpdateWithoutUserInput, AuthSessionUncheckedUpdateWithoutUserInput>
    create: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput>
  }

  export type AuthSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: AuthSessionWhereUniqueInput
    data: XOR<AuthSessionUpdateWithoutUserInput, AuthSessionUncheckedUpdateWithoutUserInput>
  }

  export type AuthSessionUpdateManyWithWhereWithoutUserInput = {
    where: AuthSessionScalarWhereInput
    data: XOR<AuthSessionUpdateManyMutationInput, AuthSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type AuthSessionScalarWhereInput = {
    AND?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
    OR?: AuthSessionScalarWhereInput[]
    NOT?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
    id?: StringFilter<"AuthSession"> | string
    userId?: StringFilter<"AuthSession"> | string
    refreshTokenHash?: StringFilter<"AuthSession"> | string
    expiresAt?: DateTimeFilter<"AuthSession"> | Date | string
    revokedAt?: DateTimeNullableFilter<"AuthSession"> | Date | string | null
    ip?: StringNullableFilter<"AuthSession"> | string | null
    userAgent?: StringNullableFilter<"AuthSession"> | string | null
    createdAt?: DateTimeFilter<"AuthSession"> | Date | string
    updatedAt?: DateTimeFilter<"AuthSession"> | Date | string
  }

  export type DispatchJobUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: DispatchJobWhereUniqueInput
    update: XOR<DispatchJobUpdateWithoutCreatedByInput, DispatchJobUncheckedUpdateWithoutCreatedByInput>
    create: XOR<DispatchJobCreateWithoutCreatedByInput, DispatchJobUncheckedCreateWithoutCreatedByInput>
  }

  export type DispatchJobUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: DispatchJobWhereUniqueInput
    data: XOR<DispatchJobUpdateWithoutCreatedByInput, DispatchJobUncheckedUpdateWithoutCreatedByInput>
  }

  export type DispatchJobUpdateManyWithWhereWithoutCreatedByInput = {
    where: DispatchJobScalarWhereInput
    data: XOR<DispatchJobUpdateManyMutationInput, DispatchJobUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type DispatchJobScalarWhereInput = {
    AND?: DispatchJobScalarWhereInput | DispatchJobScalarWhereInput[]
    OR?: DispatchJobScalarWhereInput[]
    NOT?: DispatchJobScalarWhereInput | DispatchJobScalarWhereInput[]
    id?: StringFilter<"DispatchJob"> | string
    encounterId?: StringFilter<"DispatchJob"> | string
    noteId?: StringNullableFilter<"DispatchJob"> | string | null
    target?: EnumDispatchTargetFilter<"DispatchJob"> | $Enums.DispatchTarget
    status?: EnumDispatchStatusFilter<"DispatchJob"> | $Enums.DispatchStatus
    contractType?: StringNullableFilter<"DispatchJob"> | string | null
    attemptCount?: IntFilter<"DispatchJob"> | number
    maxAttempts?: IntFilter<"DispatchJob"> | number
    nextRetryAt?: DateTimeNullableFilter<"DispatchJob"> | Date | string | null
    dispatchedAt?: DateTimeNullableFilter<"DispatchJob"> | Date | string | null
    deadLetteredAt?: DateTimeNullableFilter<"DispatchJob"> | Date | string | null
    externalMessageId?: StringNullableFilter<"DispatchJob"> | string | null
    lastError?: StringNullableFilter<"DispatchJob"> | string | null
    payload?: JsonFilter<"DispatchJob">
    response?: JsonNullableFilter<"DispatchJob">
    createdById?: StringNullableFilter<"DispatchJob"> | string | null
    createdAt?: DateTimeFilter<"DispatchJob"> | Date | string
    updatedAt?: DateTimeFilter<"DispatchJob"> | Date | string
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUserSettingsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutUserSettingsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutUserSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
  }

  export type UserUpsertWithoutUserSettingsInput = {
    update: XOR<UserUpdateWithoutUserSettingsInput, UserUncheckedUpdateWithoutUserSettingsInput>
    create: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSettingsInput, UserUncheckedUpdateWithoutUserSettingsInput>
  }

  export type UserUpdateWithoutUserSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type AppointmentCreateWithoutPatientInput = {
    id?: string
    externalId: string
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    provider?: UserCreateNestedOneWithoutAppointmentsProvidedInput
    createdBy?: UserCreateNestedOneWithoutAppointmentsCreatedInput
    encounter?: EncounterCreateNestedOneWithoutAppointmentInput
    chartAssets?: ChartAssetCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: string
    externalId: string
    providerId?: string | null
    createdById?: string | null
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter?: EncounterUncheckedCreateNestedOneWithoutAppointmentInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: AppointmentCreateManyPatientInput | AppointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type EncounterCreateWithoutPatientInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutPatientInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutPatientInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput>
  }

  export type EncounterCreateManyPatientInputEnvelope = {
    data: EncounterCreateManyPatientInput | EncounterCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ChartAssetCreateWithoutPatientInput = {
    id?: string
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutChartAssetsInput
    encounter?: EncounterCreateNestedOneWithoutChartAssetsInput
    createdBy?: UserCreateNestedOneWithoutChartAssetsInput
  }

  export type ChartAssetUncheckedCreateWithoutPatientInput = {
    id?: string
    appointmentId?: string | null
    encounterId?: string | null
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type ChartAssetCreateOrConnectWithoutPatientInput = {
    where: ChartAssetWhereUniqueInput
    create: XOR<ChartAssetCreateWithoutPatientInput, ChartAssetUncheckedCreateWithoutPatientInput>
  }

  export type ChartAssetCreateManyPatientInputEnvelope = {
    data: ChartAssetCreateManyPatientInput | ChartAssetCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type EncounterUpsertWithWhereUniqueWithoutPatientInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutPatientInput, EncounterUncheckedUpdateWithoutPatientInput>
    create: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutPatientInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutPatientInput, EncounterUncheckedUpdateWithoutPatientInput>
  }

  export type EncounterUpdateManyWithWhereWithoutPatientInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutPatientInput>
  }

  export type ChartAssetUpsertWithWhereUniqueWithoutPatientInput = {
    where: ChartAssetWhereUniqueInput
    update: XOR<ChartAssetUpdateWithoutPatientInput, ChartAssetUncheckedUpdateWithoutPatientInput>
    create: XOR<ChartAssetCreateWithoutPatientInput, ChartAssetUncheckedCreateWithoutPatientInput>
  }

  export type ChartAssetUpdateWithWhereUniqueWithoutPatientInput = {
    where: ChartAssetWhereUniqueInput
    data: XOR<ChartAssetUpdateWithoutPatientInput, ChartAssetUncheckedUpdateWithoutPatientInput>
  }

  export type ChartAssetUpdateManyWithWhereWithoutPatientInput = {
    where: ChartAssetScalarWhereInput
    data: XOR<ChartAssetUpdateManyMutationInput, ChartAssetUncheckedUpdateManyWithoutPatientInput>
  }

  export type PatientCreateWithoutAppointmentsInput = {
    id?: string
    externalId: string
    firstName: string
    lastName: string
    dateOfBirth?: Date | string | null
    email?: string | null
    phone?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterCreateNestedManyWithoutPatientInput
    chartAssets?: ChartAssetCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    externalId: string
    firstName: string
    lastName: string
    dateOfBirth?: Date | string | null
    email?: string | null
    phone?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAppointmentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserCreateWithoutAppointmentsProvidedInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAppointmentsProvidedInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAppointmentsProvidedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsProvidedInput, UserUncheckedCreateWithoutAppointmentsProvidedInput>
  }

  export type UserCreateWithoutAppointmentsCreatedInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAppointmentsCreatedInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAppointmentsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsCreatedInput, UserUncheckedCreateWithoutAppointmentsCreatedInput>
  }

  export type EncounterCreateWithoutAppointmentInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEncountersInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutAppointmentInput = {
    id?: string
    externalId: string
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutAppointmentInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput>
  }

  export type ChartAssetCreateWithoutAppointmentInput = {
    id?: string
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdAt?: Date | string
    encounter?: EncounterCreateNestedOneWithoutChartAssetsInput
    patient?: PatientCreateNestedOneWithoutChartAssetsInput
    createdBy?: UserCreateNestedOneWithoutChartAssetsInput
  }

  export type ChartAssetUncheckedCreateWithoutAppointmentInput = {
    id?: string
    encounterId?: string | null
    patientId?: string | null
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type ChartAssetCreateOrConnectWithoutAppointmentInput = {
    where: ChartAssetWhereUniqueInput
    create: XOR<ChartAssetCreateWithoutAppointmentInput, ChartAssetUncheckedCreateWithoutAppointmentInput>
  }

  export type ChartAssetCreateManyAppointmentInputEnvelope = {
    data: ChartAssetCreateManyAppointmentInput | ChartAssetCreateManyAppointmentInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutAppointmentsInput = {
    update: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutAppointmentsProvidedInput = {
    update: XOR<UserUpdateWithoutAppointmentsProvidedInput, UserUncheckedUpdateWithoutAppointmentsProvidedInput>
    create: XOR<UserCreateWithoutAppointmentsProvidedInput, UserUncheckedCreateWithoutAppointmentsProvidedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsProvidedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsProvidedInput, UserUncheckedUpdateWithoutAppointmentsProvidedInput>
  }

  export type UserUpdateWithoutAppointmentsProvidedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsProvidedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutAppointmentsCreatedInput = {
    update: XOR<UserUpdateWithoutAppointmentsCreatedInput, UserUncheckedUpdateWithoutAppointmentsCreatedInput>
    create: XOR<UserCreateWithoutAppointmentsCreatedInput, UserUncheckedCreateWithoutAppointmentsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsCreatedInput, UserUncheckedUpdateWithoutAppointmentsCreatedInput>
  }

  export type UserUpdateWithoutAppointmentsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EncounterUpsertWithoutAppointmentInput = {
    update: XOR<EncounterUpdateWithoutAppointmentInput, EncounterUncheckedUpdateWithoutAppointmentInput>
    create: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutAppointmentInput, EncounterUncheckedUpdateWithoutAppointmentInput>
  }

  export type EncounterUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type ChartAssetUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: ChartAssetWhereUniqueInput
    update: XOR<ChartAssetUpdateWithoutAppointmentInput, ChartAssetUncheckedUpdateWithoutAppointmentInput>
    create: XOR<ChartAssetCreateWithoutAppointmentInput, ChartAssetUncheckedCreateWithoutAppointmentInput>
  }

  export type ChartAssetUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: ChartAssetWhereUniqueInput
    data: XOR<ChartAssetUpdateWithoutAppointmentInput, ChartAssetUncheckedUpdateWithoutAppointmentInput>
  }

  export type ChartAssetUpdateManyWithWhereWithoutAppointmentInput = {
    where: ChartAssetScalarWhereInput
    data: XOR<ChartAssetUpdateManyMutationInput, ChartAssetUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type AppointmentCreateWithoutEncounterInput = {
    id?: string
    externalId: string
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    provider?: UserCreateNestedOneWithoutAppointmentsProvidedInput
    createdBy?: UserCreateNestedOneWithoutAppointmentsCreatedInput
    chartAssets?: ChartAssetCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutEncounterInput = {
    id?: string
    externalId: string
    patientId: string
    providerId?: string | null
    createdById?: string | null
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutEncounterInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutEncounterInput, AppointmentUncheckedCreateWithoutEncounterInput>
  }

  export type PatientCreateWithoutEncountersInput = {
    id?: string
    externalId: string
    firstName: string
    lastName: string
    dateOfBirth?: Date | string | null
    email?: string | null
    phone?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    chartAssets?: ChartAssetCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutEncountersInput = {
    id?: string
    externalId: string
    firstName: string
    lastName: string
    dateOfBirth?: Date | string | null
    email?: string | null
    phone?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutEncountersInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutEncountersInput, PatientUncheckedCreateWithoutEncountersInput>
  }

  export type UserCreateWithoutEncountersProvidedInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEncountersProvidedInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEncountersProvidedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEncountersProvidedInput, UserUncheckedCreateWithoutEncountersProvidedInput>
  }

  export type NoteCreateWithoutEncounterInput = {
    id?: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutNotesCreatedInput
    updatedBy?: UserCreateNestedOneWithoutNotesUpdatedInput
    versions?: NoteVersionCreateNestedManyWithoutNoteInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutNoteInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateWithoutEncounterInput = {
    id?: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    createdById?: string | null
    updatedById?: string | null
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: NoteVersionUncheckedCreateNestedManyWithoutNoteInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutNoteInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteCreateOrConnectWithoutEncounterInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutEncounterInput, NoteUncheckedCreateWithoutEncounterInput>
  }

  export type TranscriptSegmentCreateWithoutEncounterInput = {
    id?: string
    speaker: string
    speakerLabel?: string | null
    text: string
    startMs: number
    endMs: number
    source?: $Enums.TranscriptSource
    confidence?: number | null
    createdAt?: Date | string
  }

  export type TranscriptSegmentUncheckedCreateWithoutEncounterInput = {
    id?: string
    speaker: string
    speakerLabel?: string | null
    text: string
    startMs: number
    endMs: number
    source?: $Enums.TranscriptSource
    confidence?: number | null
    createdAt?: Date | string
  }

  export type TranscriptSegmentCreateOrConnectWithoutEncounterInput = {
    where: TranscriptSegmentWhereUniqueInput
    create: XOR<TranscriptSegmentCreateWithoutEncounterInput, TranscriptSegmentUncheckedCreateWithoutEncounterInput>
  }

  export type TranscriptSegmentCreateManyEncounterInputEnvelope = {
    data: TranscriptSegmentCreateManyEncounterInput | TranscriptSegmentCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type ChartAssetCreateWithoutEncounterInput = {
    id?: string
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutChartAssetsInput
    patient?: PatientCreateNestedOneWithoutChartAssetsInput
    createdBy?: UserCreateNestedOneWithoutChartAssetsInput
  }

  export type ChartAssetUncheckedCreateWithoutEncounterInput = {
    id?: string
    appointmentId?: string | null
    patientId?: string | null
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type ChartAssetCreateOrConnectWithoutEncounterInput = {
    where: ChartAssetWhereUniqueInput
    create: XOR<ChartAssetCreateWithoutEncounterInput, ChartAssetUncheckedCreateWithoutEncounterInput>
  }

  export type ChartAssetCreateManyEncounterInputEnvelope = {
    data: ChartAssetCreateManyEncounterInput | ChartAssetCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type SuggestionGenerationCreateWithoutEncounterInput = {
    id?: string
    trigger: string
    textDelta?: number
    transcriptDelta?: number
    inputHash?: string | null
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutSuggestionGenerationsInput
    suggestions?: CodeSuggestionCreateNestedManyWithoutGenerationInput
  }

  export type SuggestionGenerationUncheckedCreateWithoutEncounterInput = {
    id?: string
    trigger: string
    textDelta?: number
    transcriptDelta?: number
    inputHash?: string | null
    createdById?: string | null
    createdAt?: Date | string
    suggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type SuggestionGenerationCreateOrConnectWithoutEncounterInput = {
    where: SuggestionGenerationWhereUniqueInput
    create: XOR<SuggestionGenerationCreateWithoutEncounterInput, SuggestionGenerationUncheckedCreateWithoutEncounterInput>
  }

  export type SuggestionGenerationCreateManyEncounterInputEnvelope = {
    data: SuggestionGenerationCreateManyEncounterInput | SuggestionGenerationCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type CodeSuggestionCreateWithoutEncounterInput = {
    id?: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    title: string
    description: string
    rationale: string
    confidence: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.SuggestionStatus
    recommended?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    generation: SuggestionGenerationCreateNestedOneWithoutSuggestionsInput
    selections?: CodeSelectionCreateNestedManyWithoutCodeSuggestionInput
  }

  export type CodeSuggestionUncheckedCreateWithoutEncounterInput = {
    id?: string
    generationId: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    title: string
    description: string
    rationale: string
    confidence: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.SuggestionStatus
    recommended?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    selections?: CodeSelectionUncheckedCreateNestedManyWithoutCodeSuggestionInput
  }

  export type CodeSuggestionCreateOrConnectWithoutEncounterInput = {
    where: CodeSuggestionWhereUniqueInput
    create: XOR<CodeSuggestionCreateWithoutEncounterInput, CodeSuggestionUncheckedCreateWithoutEncounterInput>
  }

  export type CodeSuggestionCreateManyEncounterInputEnvelope = {
    data: CodeSuggestionCreateManyEncounterInput | CodeSuggestionCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type CodeSelectionCreateWithoutEncounterInput = {
    id?: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    action: $Enums.SelectionAction
    decisionReason?: string | null
    createdAt?: Date | string
    codeSuggestion?: CodeSuggestionCreateNestedOneWithoutSelectionsInput
    actor?: UserCreateNestedOneWithoutCodeSelectionsInput
  }

  export type CodeSelectionUncheckedCreateWithoutEncounterInput = {
    id?: string
    codeSuggestionId?: string | null
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    action: $Enums.SelectionAction
    decisionReason?: string | null
    actorId?: string | null
    createdAt?: Date | string
  }

  export type CodeSelectionCreateOrConnectWithoutEncounterInput = {
    where: CodeSelectionWhereUniqueInput
    create: XOR<CodeSelectionCreateWithoutEncounterInput, CodeSelectionUncheckedCreateWithoutEncounterInput>
  }

  export type CodeSelectionCreateManyEncounterInputEnvelope = {
    data: CodeSelectionCreateManyEncounterInput | CodeSelectionCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type ComplianceIssueCreateWithoutEncounterInput = {
    id?: string
    severity: $Enums.ComplianceSeverity
    status?: $Enums.ComplianceStatus
    title: string
    description: string
    rationale: string
    remediation: string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint: string
    resolvedAt?: Date | string | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor?: UserCreateNestedOneWithoutComplianceIssuesInput
  }

  export type ComplianceIssueUncheckedCreateWithoutEncounterInput = {
    id?: string
    severity: $Enums.ComplianceSeverity
    status?: $Enums.ComplianceStatus
    title: string
    description: string
    rationale: string
    remediation: string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint: string
    actorId?: string | null
    resolvedAt?: Date | string | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceIssueCreateOrConnectWithoutEncounterInput = {
    where: ComplianceIssueWhereUniqueInput
    create: XOR<ComplianceIssueCreateWithoutEncounterInput, ComplianceIssueUncheckedCreateWithoutEncounterInput>
  }

  export type ComplianceIssueCreateManyEncounterInputEnvelope = {
    data: ComplianceIssueCreateManyEncounterInput | ComplianceIssueCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type WizardRunCreateWithoutEncounterInput = {
    id?: string
    status?: $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    stepStates?: WizardStepStateCreateNestedManyWithoutWizardRunInput
  }

  export type WizardRunUncheckedCreateWithoutEncounterInput = {
    id?: string
    status?: $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    stepStates?: WizardStepStateUncheckedCreateNestedManyWithoutWizardRunInput
  }

  export type WizardRunCreateOrConnectWithoutEncounterInput = {
    where: WizardRunWhereUniqueInput
    create: XOR<WizardRunCreateWithoutEncounterInput, WizardRunUncheckedCreateWithoutEncounterInput>
  }

  export type WizardRunCreateManyEncounterInputEnvelope = {
    data: WizardRunCreateManyEncounterInput | WizardRunCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type WizardStepStateCreateWithoutEncounterInput = {
    id?: string
    step: $Enums.WizardStep
    status?: $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    wizardRun: WizardRunCreateNestedOneWithoutStepStatesInput
    lastActor?: UserCreateNestedOneWithoutWizardStepStatesInput
  }

  export type WizardStepStateUncheckedCreateWithoutEncounterInput = {
    id?: string
    wizardRunId: string
    step: $Enums.WizardStep
    status?: $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    lastActorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WizardStepStateCreateOrConnectWithoutEncounterInput = {
    where: WizardStepStateWhereUniqueInput
    create: XOR<WizardStepStateCreateWithoutEncounterInput, WizardStepStateUncheckedCreateWithoutEncounterInput>
  }

  export type WizardStepStateCreateManyEncounterInputEnvelope = {
    data: WizardStepStateCreateManyEncounterInput | WizardStepStateCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type ExportArtifactCreateWithoutEncounterInput = {
    id?: string
    type: $Enums.ArtifactType
    filePath: string
    mimeType: string
    fileName: string
    sizeBytes: number
    createdAt?: Date | string
    note?: NoteCreateNestedOneWithoutExportArtifactsInput
    createdBy?: UserCreateNestedOneWithoutExportArtifactsInput
  }

  export type ExportArtifactUncheckedCreateWithoutEncounterInput = {
    id?: string
    noteId?: string | null
    type: $Enums.ArtifactType
    filePath: string
    mimeType: string
    fileName: string
    sizeBytes: number
    createdById?: string | null
    createdAt?: Date | string
  }

  export type ExportArtifactCreateOrConnectWithoutEncounterInput = {
    where: ExportArtifactWhereUniqueInput
    create: XOR<ExportArtifactCreateWithoutEncounterInput, ExportArtifactUncheckedCreateWithoutEncounterInput>
  }

  export type ExportArtifactCreateManyEncounterInputEnvelope = {
    data: ExportArtifactCreateManyEncounterInput | ExportArtifactCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutEncounterInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutEncounterInput = {
    id?: string
    actorId?: string | null
    action: string
    entity: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutEncounterInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutEncounterInput, AuditLogUncheckedCreateWithoutEncounterInput>
  }

  export type AuditLogCreateManyEncounterInputEnvelope = {
    data: AuditLogCreateManyEncounterInput | AuditLogCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type DispatchJobCreateWithoutEncounterInput = {
    id?: string
    target?: $Enums.DispatchTarget
    status?: $Enums.DispatchStatus
    contractType?: string | null
    attemptCount?: number
    maxAttempts?: number
    nextRetryAt?: Date | string | null
    dispatchedAt?: Date | string | null
    deadLetteredAt?: Date | string | null
    externalMessageId?: string | null
    lastError?: string | null
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteCreateNestedOneWithoutDispatchJobsInput
    createdBy?: UserCreateNestedOneWithoutDispatchJobsInput
  }

  export type DispatchJobUncheckedCreateWithoutEncounterInput = {
    id?: string
    noteId?: string | null
    target?: $Enums.DispatchTarget
    status?: $Enums.DispatchStatus
    contractType?: string | null
    attemptCount?: number
    maxAttempts?: number
    nextRetryAt?: Date | string | null
    dispatchedAt?: Date | string | null
    deadLetteredAt?: Date | string | null
    externalMessageId?: string | null
    lastError?: string | null
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DispatchJobCreateOrConnectWithoutEncounterInput = {
    where: DispatchJobWhereUniqueInput
    create: XOR<DispatchJobCreateWithoutEncounterInput, DispatchJobUncheckedCreateWithoutEncounterInput>
  }

  export type DispatchJobCreateManyEncounterInputEnvelope = {
    data: DispatchJobCreateManyEncounterInput | DispatchJobCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithoutEncounterInput = {
    update: XOR<AppointmentUpdateWithoutEncounterInput, AppointmentUncheckedUpdateWithoutEncounterInput>
    create: XOR<AppointmentCreateWithoutEncounterInput, AppointmentUncheckedCreateWithoutEncounterInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutEncounterInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutEncounterInput, AppointmentUncheckedUpdateWithoutEncounterInput>
  }

  export type AppointmentUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    provider?: UserUpdateOneWithoutAppointmentsProvidedNestedInput
    createdBy?: UserUpdateOneWithoutAppointmentsCreatedNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type PatientUpsertWithoutEncountersInput = {
    update: XOR<PatientUpdateWithoutEncountersInput, PatientUncheckedUpdateWithoutEncountersInput>
    create: XOR<PatientCreateWithoutEncountersInput, PatientUncheckedCreateWithoutEncountersInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutEncountersInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutEncountersInput, PatientUncheckedUpdateWithoutEncountersInput>
  }

  export type PatientUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutEncountersProvidedInput = {
    update: XOR<UserUpdateWithoutEncountersProvidedInput, UserUncheckedUpdateWithoutEncountersProvidedInput>
    create: XOR<UserCreateWithoutEncountersProvidedInput, UserUncheckedCreateWithoutEncountersProvidedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEncountersProvidedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEncountersProvidedInput, UserUncheckedUpdateWithoutEncountersProvidedInput>
  }

  export type UserUpdateWithoutEncountersProvidedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEncountersProvidedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type NoteUpsertWithoutEncounterInput = {
    update: XOR<NoteUpdateWithoutEncounterInput, NoteUncheckedUpdateWithoutEncounterInput>
    create: XOR<NoteCreateWithoutEncounterInput, NoteUncheckedCreateWithoutEncounterInput>
    where?: NoteWhereInput
  }

  export type NoteUpdateToOneWithWhereWithoutEncounterInput = {
    where?: NoteWhereInput
    data: XOR<NoteUpdateWithoutEncounterInput, NoteUncheckedUpdateWithoutEncounterInput>
  }

  export type NoteUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutNotesCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutNotesUpdatedNestedInput
    versions?: NoteVersionUpdateManyWithoutNoteNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutNoteNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: NoteVersionUncheckedUpdateManyWithoutNoteNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutNoteNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type TranscriptSegmentUpsertWithWhereUniqueWithoutEncounterInput = {
    where: TranscriptSegmentWhereUniqueInput
    update: XOR<TranscriptSegmentUpdateWithoutEncounterInput, TranscriptSegmentUncheckedUpdateWithoutEncounterInput>
    create: XOR<TranscriptSegmentCreateWithoutEncounterInput, TranscriptSegmentUncheckedCreateWithoutEncounterInput>
  }

  export type TranscriptSegmentUpdateWithWhereUniqueWithoutEncounterInput = {
    where: TranscriptSegmentWhereUniqueInput
    data: XOR<TranscriptSegmentUpdateWithoutEncounterInput, TranscriptSegmentUncheckedUpdateWithoutEncounterInput>
  }

  export type TranscriptSegmentUpdateManyWithWhereWithoutEncounterInput = {
    where: TranscriptSegmentScalarWhereInput
    data: XOR<TranscriptSegmentUpdateManyMutationInput, TranscriptSegmentUncheckedUpdateManyWithoutEncounterInput>
  }

  export type TranscriptSegmentScalarWhereInput = {
    AND?: TranscriptSegmentScalarWhereInput | TranscriptSegmentScalarWhereInput[]
    OR?: TranscriptSegmentScalarWhereInput[]
    NOT?: TranscriptSegmentScalarWhereInput | TranscriptSegmentScalarWhereInput[]
    id?: StringFilter<"TranscriptSegment"> | string
    encounterId?: StringFilter<"TranscriptSegment"> | string
    speaker?: StringFilter<"TranscriptSegment"> | string
    speakerLabel?: StringNullableFilter<"TranscriptSegment"> | string | null
    text?: StringFilter<"TranscriptSegment"> | string
    startMs?: IntFilter<"TranscriptSegment"> | number
    endMs?: IntFilter<"TranscriptSegment"> | number
    source?: EnumTranscriptSourceFilter<"TranscriptSegment"> | $Enums.TranscriptSource
    confidence?: FloatNullableFilter<"TranscriptSegment"> | number | null
    createdAt?: DateTimeFilter<"TranscriptSegment"> | Date | string
  }

  export type ChartAssetUpsertWithWhereUniqueWithoutEncounterInput = {
    where: ChartAssetWhereUniqueInput
    update: XOR<ChartAssetUpdateWithoutEncounterInput, ChartAssetUncheckedUpdateWithoutEncounterInput>
    create: XOR<ChartAssetCreateWithoutEncounterInput, ChartAssetUncheckedCreateWithoutEncounterInput>
  }

  export type ChartAssetUpdateWithWhereUniqueWithoutEncounterInput = {
    where: ChartAssetWhereUniqueInput
    data: XOR<ChartAssetUpdateWithoutEncounterInput, ChartAssetUncheckedUpdateWithoutEncounterInput>
  }

  export type ChartAssetUpdateManyWithWhereWithoutEncounterInput = {
    where: ChartAssetScalarWhereInput
    data: XOR<ChartAssetUpdateManyMutationInput, ChartAssetUncheckedUpdateManyWithoutEncounterInput>
  }

  export type SuggestionGenerationUpsertWithWhereUniqueWithoutEncounterInput = {
    where: SuggestionGenerationWhereUniqueInput
    update: XOR<SuggestionGenerationUpdateWithoutEncounterInput, SuggestionGenerationUncheckedUpdateWithoutEncounterInput>
    create: XOR<SuggestionGenerationCreateWithoutEncounterInput, SuggestionGenerationUncheckedCreateWithoutEncounterInput>
  }

  export type SuggestionGenerationUpdateWithWhereUniqueWithoutEncounterInput = {
    where: SuggestionGenerationWhereUniqueInput
    data: XOR<SuggestionGenerationUpdateWithoutEncounterInput, SuggestionGenerationUncheckedUpdateWithoutEncounterInput>
  }

  export type SuggestionGenerationUpdateManyWithWhereWithoutEncounterInput = {
    where: SuggestionGenerationScalarWhereInput
    data: XOR<SuggestionGenerationUpdateManyMutationInput, SuggestionGenerationUncheckedUpdateManyWithoutEncounterInput>
  }

  export type CodeSuggestionUpsertWithWhereUniqueWithoutEncounterInput = {
    where: CodeSuggestionWhereUniqueInput
    update: XOR<CodeSuggestionUpdateWithoutEncounterInput, CodeSuggestionUncheckedUpdateWithoutEncounterInput>
    create: XOR<CodeSuggestionCreateWithoutEncounterInput, CodeSuggestionUncheckedCreateWithoutEncounterInput>
  }

  export type CodeSuggestionUpdateWithWhereUniqueWithoutEncounterInput = {
    where: CodeSuggestionWhereUniqueInput
    data: XOR<CodeSuggestionUpdateWithoutEncounterInput, CodeSuggestionUncheckedUpdateWithoutEncounterInput>
  }

  export type CodeSuggestionUpdateManyWithWhereWithoutEncounterInput = {
    where: CodeSuggestionScalarWhereInput
    data: XOR<CodeSuggestionUpdateManyMutationInput, CodeSuggestionUncheckedUpdateManyWithoutEncounterInput>
  }

  export type CodeSuggestionScalarWhereInput = {
    AND?: CodeSuggestionScalarWhereInput | CodeSuggestionScalarWhereInput[]
    OR?: CodeSuggestionScalarWhereInput[]
    NOT?: CodeSuggestionScalarWhereInput | CodeSuggestionScalarWhereInput[]
    id?: StringFilter<"CodeSuggestion"> | string
    encounterId?: StringFilter<"CodeSuggestion"> | string
    generationId?: StringFilter<"CodeSuggestion"> | string
    code?: StringFilter<"CodeSuggestion"> | string
    codeType?: StringFilter<"CodeSuggestion"> | string
    category?: EnumSuggestionCategoryFilter<"CodeSuggestion"> | $Enums.SuggestionCategory
    title?: StringFilter<"CodeSuggestion"> | string
    description?: StringFilter<"CodeSuggestion"> | string
    rationale?: StringFilter<"CodeSuggestion"> | string
    confidence?: FloatFilter<"CodeSuggestion"> | number
    evidence?: JsonNullableFilter<"CodeSuggestion">
    status?: EnumSuggestionStatusFilter<"CodeSuggestion"> | $Enums.SuggestionStatus
    recommended?: BoolFilter<"CodeSuggestion"> | boolean
    metadata?: JsonNullableFilter<"CodeSuggestion">
    createdAt?: DateTimeFilter<"CodeSuggestion"> | Date | string
    updatedAt?: DateTimeFilter<"CodeSuggestion"> | Date | string
  }

  export type CodeSelectionUpsertWithWhereUniqueWithoutEncounterInput = {
    where: CodeSelectionWhereUniqueInput
    update: XOR<CodeSelectionUpdateWithoutEncounterInput, CodeSelectionUncheckedUpdateWithoutEncounterInput>
    create: XOR<CodeSelectionCreateWithoutEncounterInput, CodeSelectionUncheckedCreateWithoutEncounterInput>
  }

  export type CodeSelectionUpdateWithWhereUniqueWithoutEncounterInput = {
    where: CodeSelectionWhereUniqueInput
    data: XOR<CodeSelectionUpdateWithoutEncounterInput, CodeSelectionUncheckedUpdateWithoutEncounterInput>
  }

  export type CodeSelectionUpdateManyWithWhereWithoutEncounterInput = {
    where: CodeSelectionScalarWhereInput
    data: XOR<CodeSelectionUpdateManyMutationInput, CodeSelectionUncheckedUpdateManyWithoutEncounterInput>
  }

  export type ComplianceIssueUpsertWithWhereUniqueWithoutEncounterInput = {
    where: ComplianceIssueWhereUniqueInput
    update: XOR<ComplianceIssueUpdateWithoutEncounterInput, ComplianceIssueUncheckedUpdateWithoutEncounterInput>
    create: XOR<ComplianceIssueCreateWithoutEncounterInput, ComplianceIssueUncheckedCreateWithoutEncounterInput>
  }

  export type ComplianceIssueUpdateWithWhereUniqueWithoutEncounterInput = {
    where: ComplianceIssueWhereUniqueInput
    data: XOR<ComplianceIssueUpdateWithoutEncounterInput, ComplianceIssueUncheckedUpdateWithoutEncounterInput>
  }

  export type ComplianceIssueUpdateManyWithWhereWithoutEncounterInput = {
    where: ComplianceIssueScalarWhereInput
    data: XOR<ComplianceIssueUpdateManyMutationInput, ComplianceIssueUncheckedUpdateManyWithoutEncounterInput>
  }

  export type WizardRunUpsertWithWhereUniqueWithoutEncounterInput = {
    where: WizardRunWhereUniqueInput
    update: XOR<WizardRunUpdateWithoutEncounterInput, WizardRunUncheckedUpdateWithoutEncounterInput>
    create: XOR<WizardRunCreateWithoutEncounterInput, WizardRunUncheckedCreateWithoutEncounterInput>
  }

  export type WizardRunUpdateWithWhereUniqueWithoutEncounterInput = {
    where: WizardRunWhereUniqueInput
    data: XOR<WizardRunUpdateWithoutEncounterInput, WizardRunUncheckedUpdateWithoutEncounterInput>
  }

  export type WizardRunUpdateManyWithWhereWithoutEncounterInput = {
    where: WizardRunScalarWhereInput
    data: XOR<WizardRunUpdateManyMutationInput, WizardRunUncheckedUpdateManyWithoutEncounterInput>
  }

  export type WizardRunScalarWhereInput = {
    AND?: WizardRunScalarWhereInput | WizardRunScalarWhereInput[]
    OR?: WizardRunScalarWhereInput[]
    NOT?: WizardRunScalarWhereInput | WizardRunScalarWhereInput[]
    id?: StringFilter<"WizardRun"> | string
    encounterId?: StringFilter<"WizardRun"> | string
    status?: EnumWizardRunStatusFilter<"WizardRun"> | $Enums.WizardRunStatus
    runState?: JsonNullableFilter<"WizardRun">
    startedAt?: DateTimeFilter<"WizardRun"> | Date | string
    completedAt?: DateTimeNullableFilter<"WizardRun"> | Date | string | null
  }

  export type WizardStepStateUpsertWithWhereUniqueWithoutEncounterInput = {
    where: WizardStepStateWhereUniqueInput
    update: XOR<WizardStepStateUpdateWithoutEncounterInput, WizardStepStateUncheckedUpdateWithoutEncounterInput>
    create: XOR<WizardStepStateCreateWithoutEncounterInput, WizardStepStateUncheckedCreateWithoutEncounterInput>
  }

  export type WizardStepStateUpdateWithWhereUniqueWithoutEncounterInput = {
    where: WizardStepStateWhereUniqueInput
    data: XOR<WizardStepStateUpdateWithoutEncounterInput, WizardStepStateUncheckedUpdateWithoutEncounterInput>
  }

  export type WizardStepStateUpdateManyWithWhereWithoutEncounterInput = {
    where: WizardStepStateScalarWhereInput
    data: XOR<WizardStepStateUpdateManyMutationInput, WizardStepStateUncheckedUpdateManyWithoutEncounterInput>
  }

  export type ExportArtifactUpsertWithWhereUniqueWithoutEncounterInput = {
    where: ExportArtifactWhereUniqueInput
    update: XOR<ExportArtifactUpdateWithoutEncounterInput, ExportArtifactUncheckedUpdateWithoutEncounterInput>
    create: XOR<ExportArtifactCreateWithoutEncounterInput, ExportArtifactUncheckedCreateWithoutEncounterInput>
  }

  export type ExportArtifactUpdateWithWhereUniqueWithoutEncounterInput = {
    where: ExportArtifactWhereUniqueInput
    data: XOR<ExportArtifactUpdateWithoutEncounterInput, ExportArtifactUncheckedUpdateWithoutEncounterInput>
  }

  export type ExportArtifactUpdateManyWithWhereWithoutEncounterInput = {
    where: ExportArtifactScalarWhereInput
    data: XOR<ExportArtifactUpdateManyMutationInput, ExportArtifactUncheckedUpdateManyWithoutEncounterInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutEncounterInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutEncounterInput, AuditLogUncheckedUpdateWithoutEncounterInput>
    create: XOR<AuditLogCreateWithoutEncounterInput, AuditLogUncheckedCreateWithoutEncounterInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutEncounterInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutEncounterInput, AuditLogUncheckedUpdateWithoutEncounterInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutEncounterInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutEncounterInput>
  }

  export type DispatchJobUpsertWithWhereUniqueWithoutEncounterInput = {
    where: DispatchJobWhereUniqueInput
    update: XOR<DispatchJobUpdateWithoutEncounterInput, DispatchJobUncheckedUpdateWithoutEncounterInput>
    create: XOR<DispatchJobCreateWithoutEncounterInput, DispatchJobUncheckedCreateWithoutEncounterInput>
  }

  export type DispatchJobUpdateWithWhereUniqueWithoutEncounterInput = {
    where: DispatchJobWhereUniqueInput
    data: XOR<DispatchJobUpdateWithoutEncounterInput, DispatchJobUncheckedUpdateWithoutEncounterInput>
  }

  export type DispatchJobUpdateManyWithWhereWithoutEncounterInput = {
    where: DispatchJobScalarWhereInput
    data: XOR<DispatchJobUpdateManyMutationInput, DispatchJobUncheckedUpdateManyWithoutEncounterInput>
  }

  export type EncounterCreateWithoutNoteInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutNoteInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutNoteInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutNoteInput, EncounterUncheckedCreateWithoutNoteInput>
  }

  export type UserCreateWithoutNotesCreatedInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotesCreatedInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotesCreatedInput, UserUncheckedCreateWithoutNotesCreatedInput>
  }

  export type UserCreateWithoutNotesUpdatedInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotesUpdatedInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotesUpdatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotesUpdatedInput, UserUncheckedCreateWithoutNotesUpdatedInput>
  }

  export type NoteVersionCreateWithoutNoteInput = {
    id?: string
    versionNumber: number
    source: string
    content: string
    patientSummary: string
    traceId?: string | null
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutNoteVersionsInput
  }

  export type NoteVersionUncheckedCreateWithoutNoteInput = {
    id?: string
    versionNumber: number
    source: string
    content: string
    patientSummary: string
    traceId?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type NoteVersionCreateOrConnectWithoutNoteInput = {
    where: NoteVersionWhereUniqueInput
    create: XOR<NoteVersionCreateWithoutNoteInput, NoteVersionUncheckedCreateWithoutNoteInput>
  }

  export type NoteVersionCreateManyNoteInputEnvelope = {
    data: NoteVersionCreateManyNoteInput | NoteVersionCreateManyNoteInput[]
    skipDuplicates?: boolean
  }

  export type ExportArtifactCreateWithoutNoteInput = {
    id?: string
    type: $Enums.ArtifactType
    filePath: string
    mimeType: string
    fileName: string
    sizeBytes: number
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutExportArtifactsInput
    createdBy?: UserCreateNestedOneWithoutExportArtifactsInput
  }

  export type ExportArtifactUncheckedCreateWithoutNoteInput = {
    id?: string
    encounterId: string
    type: $Enums.ArtifactType
    filePath: string
    mimeType: string
    fileName: string
    sizeBytes: number
    createdById?: string | null
    createdAt?: Date | string
  }

  export type ExportArtifactCreateOrConnectWithoutNoteInput = {
    where: ExportArtifactWhereUniqueInput
    create: XOR<ExportArtifactCreateWithoutNoteInput, ExportArtifactUncheckedCreateWithoutNoteInput>
  }

  export type ExportArtifactCreateManyNoteInputEnvelope = {
    data: ExportArtifactCreateManyNoteInput | ExportArtifactCreateManyNoteInput[]
    skipDuplicates?: boolean
  }

  export type DispatchJobCreateWithoutNoteInput = {
    id?: string
    target?: $Enums.DispatchTarget
    status?: $Enums.DispatchStatus
    contractType?: string | null
    attemptCount?: number
    maxAttempts?: number
    nextRetryAt?: Date | string | null
    dispatchedAt?: Date | string | null
    deadLetteredAt?: Date | string | null
    externalMessageId?: string | null
    lastError?: string | null
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutDispatchJobsInput
    createdBy?: UserCreateNestedOneWithoutDispatchJobsInput
  }

  export type DispatchJobUncheckedCreateWithoutNoteInput = {
    id?: string
    encounterId: string
    target?: $Enums.DispatchTarget
    status?: $Enums.DispatchStatus
    contractType?: string | null
    attemptCount?: number
    maxAttempts?: number
    nextRetryAt?: Date | string | null
    dispatchedAt?: Date | string | null
    deadLetteredAt?: Date | string | null
    externalMessageId?: string | null
    lastError?: string | null
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DispatchJobCreateOrConnectWithoutNoteInput = {
    where: DispatchJobWhereUniqueInput
    create: XOR<DispatchJobCreateWithoutNoteInput, DispatchJobUncheckedCreateWithoutNoteInput>
  }

  export type DispatchJobCreateManyNoteInputEnvelope = {
    data: DispatchJobCreateManyNoteInput | DispatchJobCreateManyNoteInput[]
    skipDuplicates?: boolean
  }

  export type EncounterUpsertWithoutNoteInput = {
    update: XOR<EncounterUpdateWithoutNoteInput, EncounterUncheckedUpdateWithoutNoteInput>
    create: XOR<EncounterCreateWithoutNoteInput, EncounterUncheckedCreateWithoutNoteInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutNoteInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutNoteInput, EncounterUncheckedUpdateWithoutNoteInput>
  }

  export type EncounterUpdateWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type UserUpsertWithoutNotesCreatedInput = {
    update: XOR<UserUpdateWithoutNotesCreatedInput, UserUncheckedUpdateWithoutNotesCreatedInput>
    create: XOR<UserCreateWithoutNotesCreatedInput, UserUncheckedCreateWithoutNotesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotesCreatedInput, UserUncheckedUpdateWithoutNotesCreatedInput>
  }

  export type UserUpdateWithoutNotesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutNotesUpdatedInput = {
    update: XOR<UserUpdateWithoutNotesUpdatedInput, UserUncheckedUpdateWithoutNotesUpdatedInput>
    create: XOR<UserCreateWithoutNotesUpdatedInput, UserUncheckedCreateWithoutNotesUpdatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotesUpdatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotesUpdatedInput, UserUncheckedUpdateWithoutNotesUpdatedInput>
  }

  export type UserUpdateWithoutNotesUpdatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotesUpdatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type NoteVersionUpsertWithWhereUniqueWithoutNoteInput = {
    where: NoteVersionWhereUniqueInput
    update: XOR<NoteVersionUpdateWithoutNoteInput, NoteVersionUncheckedUpdateWithoutNoteInput>
    create: XOR<NoteVersionCreateWithoutNoteInput, NoteVersionUncheckedCreateWithoutNoteInput>
  }

  export type NoteVersionUpdateWithWhereUniqueWithoutNoteInput = {
    where: NoteVersionWhereUniqueInput
    data: XOR<NoteVersionUpdateWithoutNoteInput, NoteVersionUncheckedUpdateWithoutNoteInput>
  }

  export type NoteVersionUpdateManyWithWhereWithoutNoteInput = {
    where: NoteVersionScalarWhereInput
    data: XOR<NoteVersionUpdateManyMutationInput, NoteVersionUncheckedUpdateManyWithoutNoteInput>
  }

  export type ExportArtifactUpsertWithWhereUniqueWithoutNoteInput = {
    where: ExportArtifactWhereUniqueInput
    update: XOR<ExportArtifactUpdateWithoutNoteInput, ExportArtifactUncheckedUpdateWithoutNoteInput>
    create: XOR<ExportArtifactCreateWithoutNoteInput, ExportArtifactUncheckedCreateWithoutNoteInput>
  }

  export type ExportArtifactUpdateWithWhereUniqueWithoutNoteInput = {
    where: ExportArtifactWhereUniqueInput
    data: XOR<ExportArtifactUpdateWithoutNoteInput, ExportArtifactUncheckedUpdateWithoutNoteInput>
  }

  export type ExportArtifactUpdateManyWithWhereWithoutNoteInput = {
    where: ExportArtifactScalarWhereInput
    data: XOR<ExportArtifactUpdateManyMutationInput, ExportArtifactUncheckedUpdateManyWithoutNoteInput>
  }

  export type DispatchJobUpsertWithWhereUniqueWithoutNoteInput = {
    where: DispatchJobWhereUniqueInput
    update: XOR<DispatchJobUpdateWithoutNoteInput, DispatchJobUncheckedUpdateWithoutNoteInput>
    create: XOR<DispatchJobCreateWithoutNoteInput, DispatchJobUncheckedCreateWithoutNoteInput>
  }

  export type DispatchJobUpdateWithWhereUniqueWithoutNoteInput = {
    where: DispatchJobWhereUniqueInput
    data: XOR<DispatchJobUpdateWithoutNoteInput, DispatchJobUncheckedUpdateWithoutNoteInput>
  }

  export type DispatchJobUpdateManyWithWhereWithoutNoteInput = {
    where: DispatchJobScalarWhereInput
    data: XOR<DispatchJobUpdateManyMutationInput, DispatchJobUncheckedUpdateManyWithoutNoteInput>
  }

  export type NoteCreateWithoutVersionsInput = {
    id?: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutNoteInput
    createdBy?: UserCreateNestedOneWithoutNotesCreatedInput
    updatedBy?: UserCreateNestedOneWithoutNotesUpdatedInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutNoteInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateWithoutVersionsInput = {
    id?: string
    encounterId: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    createdById?: string | null
    updatedById?: string | null
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutNoteInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteCreateOrConnectWithoutVersionsInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutVersionsInput, NoteUncheckedCreateWithoutVersionsInput>
  }

  export type UserCreateWithoutNoteVersionsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNoteVersionsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNoteVersionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNoteVersionsInput, UserUncheckedCreateWithoutNoteVersionsInput>
  }

  export type NoteUpsertWithoutVersionsInput = {
    update: XOR<NoteUpdateWithoutVersionsInput, NoteUncheckedUpdateWithoutVersionsInput>
    create: XOR<NoteCreateWithoutVersionsInput, NoteUncheckedCreateWithoutVersionsInput>
    where?: NoteWhereInput
  }

  export type NoteUpdateToOneWithWhereWithoutVersionsInput = {
    where?: NoteWhereInput
    data: XOR<NoteUpdateWithoutVersionsInput, NoteUncheckedUpdateWithoutVersionsInput>
  }

  export type NoteUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutNoteNestedInput
    createdBy?: UserUpdateOneWithoutNotesCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutNotesUpdatedNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutNoteNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutNoteNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type UserUpsertWithoutNoteVersionsInput = {
    update: XOR<UserUpdateWithoutNoteVersionsInput, UserUncheckedUpdateWithoutNoteVersionsInput>
    create: XOR<UserCreateWithoutNoteVersionsInput, UserUncheckedCreateWithoutNoteVersionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNoteVersionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNoteVersionsInput, UserUncheckedUpdateWithoutNoteVersionsInput>
  }

  export type UserUpdateWithoutNoteVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNoteVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EncounterCreateWithoutTranscriptSegmentsInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutTranscriptSegmentsInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutTranscriptSegmentsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutTranscriptSegmentsInput, EncounterUncheckedCreateWithoutTranscriptSegmentsInput>
  }

  export type EncounterUpsertWithoutTranscriptSegmentsInput = {
    update: XOR<EncounterUpdateWithoutTranscriptSegmentsInput, EncounterUncheckedUpdateWithoutTranscriptSegmentsInput>
    create: XOR<EncounterCreateWithoutTranscriptSegmentsInput, EncounterUncheckedCreateWithoutTranscriptSegmentsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutTranscriptSegmentsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutTranscriptSegmentsInput, EncounterUncheckedUpdateWithoutTranscriptSegmentsInput>
  }

  export type EncounterUpdateWithoutTranscriptSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutTranscriptSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type AppointmentCreateWithoutChartAssetsInput = {
    id?: string
    externalId: string
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    provider?: UserCreateNestedOneWithoutAppointmentsProvidedInput
    createdBy?: UserCreateNestedOneWithoutAppointmentsCreatedInput
    encounter?: EncounterCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutChartAssetsInput = {
    id?: string
    externalId: string
    patientId: string
    providerId?: string | null
    createdById?: string | null
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter?: EncounterUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutChartAssetsInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutChartAssetsInput, AppointmentUncheckedCreateWithoutChartAssetsInput>
  }

  export type EncounterCreateWithoutChartAssetsInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutChartAssetsInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutChartAssetsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutChartAssetsInput, EncounterUncheckedCreateWithoutChartAssetsInput>
  }

  export type PatientCreateWithoutChartAssetsInput = {
    id?: string
    externalId: string
    firstName: string
    lastName: string
    dateOfBirth?: Date | string | null
    email?: string | null
    phone?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    encounters?: EncounterCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutChartAssetsInput = {
    id?: string
    externalId: string
    firstName: string
    lastName: string
    dateOfBirth?: Date | string | null
    email?: string | null
    phone?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutChartAssetsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutChartAssetsInput, PatientUncheckedCreateWithoutChartAssetsInput>
  }

  export type UserCreateWithoutChartAssetsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChartAssetsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChartAssetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChartAssetsInput, UserUncheckedCreateWithoutChartAssetsInput>
  }

  export type AppointmentUpsertWithoutChartAssetsInput = {
    update: XOR<AppointmentUpdateWithoutChartAssetsInput, AppointmentUncheckedUpdateWithoutChartAssetsInput>
    create: XOR<AppointmentCreateWithoutChartAssetsInput, AppointmentUncheckedCreateWithoutChartAssetsInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutChartAssetsInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutChartAssetsInput, AppointmentUncheckedUpdateWithoutChartAssetsInput>
  }

  export type AppointmentUpdateWithoutChartAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    provider?: UserUpdateOneWithoutAppointmentsProvidedNestedInput
    createdBy?: UserUpdateOneWithoutAppointmentsCreatedNestedInput
    encounter?: EncounterUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutChartAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type EncounterUpsertWithoutChartAssetsInput = {
    update: XOR<EncounterUpdateWithoutChartAssetsInput, EncounterUncheckedUpdateWithoutChartAssetsInput>
    create: XOR<EncounterCreateWithoutChartAssetsInput, EncounterUncheckedCreateWithoutChartAssetsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutChartAssetsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutChartAssetsInput, EncounterUncheckedUpdateWithoutChartAssetsInput>
  }

  export type EncounterUpdateWithoutChartAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutChartAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type PatientUpsertWithoutChartAssetsInput = {
    update: XOR<PatientUpdateWithoutChartAssetsInput, PatientUncheckedUpdateWithoutChartAssetsInput>
    create: XOR<PatientCreateWithoutChartAssetsInput, PatientUncheckedCreateWithoutChartAssetsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutChartAssetsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutChartAssetsInput, PatientUncheckedUpdateWithoutChartAssetsInput>
  }

  export type PatientUpdateWithoutChartAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutChartAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutChartAssetsInput = {
    update: XOR<UserUpdateWithoutChartAssetsInput, UserUncheckedUpdateWithoutChartAssetsInput>
    create: XOR<UserCreateWithoutChartAssetsInput, UserUncheckedCreateWithoutChartAssetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChartAssetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChartAssetsInput, UserUncheckedUpdateWithoutChartAssetsInput>
  }

  export type UserUpdateWithoutChartAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChartAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EncounterCreateWithoutSuggestionCyclesInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutSuggestionCyclesInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutSuggestionCyclesInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutSuggestionCyclesInput, EncounterUncheckedCreateWithoutSuggestionCyclesInput>
  }

  export type UserCreateWithoutSuggestionGenerationsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSuggestionGenerationsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSuggestionGenerationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSuggestionGenerationsInput, UserUncheckedCreateWithoutSuggestionGenerationsInput>
  }

  export type CodeSuggestionCreateWithoutGenerationInput = {
    id?: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    title: string
    description: string
    rationale: string
    confidence: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.SuggestionStatus
    recommended?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutCodeSuggestionsInput
    selections?: CodeSelectionCreateNestedManyWithoutCodeSuggestionInput
  }

  export type CodeSuggestionUncheckedCreateWithoutGenerationInput = {
    id?: string
    encounterId: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    title: string
    description: string
    rationale: string
    confidence: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.SuggestionStatus
    recommended?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    selections?: CodeSelectionUncheckedCreateNestedManyWithoutCodeSuggestionInput
  }

  export type CodeSuggestionCreateOrConnectWithoutGenerationInput = {
    where: CodeSuggestionWhereUniqueInput
    create: XOR<CodeSuggestionCreateWithoutGenerationInput, CodeSuggestionUncheckedCreateWithoutGenerationInput>
  }

  export type CodeSuggestionCreateManyGenerationInputEnvelope = {
    data: CodeSuggestionCreateManyGenerationInput | CodeSuggestionCreateManyGenerationInput[]
    skipDuplicates?: boolean
  }

  export type EncounterUpsertWithoutSuggestionCyclesInput = {
    update: XOR<EncounterUpdateWithoutSuggestionCyclesInput, EncounterUncheckedUpdateWithoutSuggestionCyclesInput>
    create: XOR<EncounterCreateWithoutSuggestionCyclesInput, EncounterUncheckedCreateWithoutSuggestionCyclesInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutSuggestionCyclesInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutSuggestionCyclesInput, EncounterUncheckedUpdateWithoutSuggestionCyclesInput>
  }

  export type EncounterUpdateWithoutSuggestionCyclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutSuggestionCyclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type UserUpsertWithoutSuggestionGenerationsInput = {
    update: XOR<UserUpdateWithoutSuggestionGenerationsInput, UserUncheckedUpdateWithoutSuggestionGenerationsInput>
    create: XOR<UserCreateWithoutSuggestionGenerationsInput, UserUncheckedCreateWithoutSuggestionGenerationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSuggestionGenerationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSuggestionGenerationsInput, UserUncheckedUpdateWithoutSuggestionGenerationsInput>
  }

  export type UserUpdateWithoutSuggestionGenerationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSuggestionGenerationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CodeSuggestionUpsertWithWhereUniqueWithoutGenerationInput = {
    where: CodeSuggestionWhereUniqueInput
    update: XOR<CodeSuggestionUpdateWithoutGenerationInput, CodeSuggestionUncheckedUpdateWithoutGenerationInput>
    create: XOR<CodeSuggestionCreateWithoutGenerationInput, CodeSuggestionUncheckedCreateWithoutGenerationInput>
  }

  export type CodeSuggestionUpdateWithWhereUniqueWithoutGenerationInput = {
    where: CodeSuggestionWhereUniqueInput
    data: XOR<CodeSuggestionUpdateWithoutGenerationInput, CodeSuggestionUncheckedUpdateWithoutGenerationInput>
  }

  export type CodeSuggestionUpdateManyWithWhereWithoutGenerationInput = {
    where: CodeSuggestionScalarWhereInput
    data: XOR<CodeSuggestionUpdateManyMutationInput, CodeSuggestionUncheckedUpdateManyWithoutGenerationInput>
  }

  export type EncounterCreateWithoutCodeSuggestionsInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutCodeSuggestionsInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutCodeSuggestionsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutCodeSuggestionsInput, EncounterUncheckedCreateWithoutCodeSuggestionsInput>
  }

  export type SuggestionGenerationCreateWithoutSuggestionsInput = {
    id?: string
    trigger: string
    textDelta?: number
    transcriptDelta?: number
    inputHash?: string | null
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutSuggestionCyclesInput
    createdBy?: UserCreateNestedOneWithoutSuggestionGenerationsInput
  }

  export type SuggestionGenerationUncheckedCreateWithoutSuggestionsInput = {
    id?: string
    encounterId: string
    trigger: string
    textDelta?: number
    transcriptDelta?: number
    inputHash?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type SuggestionGenerationCreateOrConnectWithoutSuggestionsInput = {
    where: SuggestionGenerationWhereUniqueInput
    create: XOR<SuggestionGenerationCreateWithoutSuggestionsInput, SuggestionGenerationUncheckedCreateWithoutSuggestionsInput>
  }

  export type CodeSelectionCreateWithoutCodeSuggestionInput = {
    id?: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    action: $Enums.SelectionAction
    decisionReason?: string | null
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutCodeSelectionsInput
    actor?: UserCreateNestedOneWithoutCodeSelectionsInput
  }

  export type CodeSelectionUncheckedCreateWithoutCodeSuggestionInput = {
    id?: string
    encounterId: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    action: $Enums.SelectionAction
    decisionReason?: string | null
    actorId?: string | null
    createdAt?: Date | string
  }

  export type CodeSelectionCreateOrConnectWithoutCodeSuggestionInput = {
    where: CodeSelectionWhereUniqueInput
    create: XOR<CodeSelectionCreateWithoutCodeSuggestionInput, CodeSelectionUncheckedCreateWithoutCodeSuggestionInput>
  }

  export type CodeSelectionCreateManyCodeSuggestionInputEnvelope = {
    data: CodeSelectionCreateManyCodeSuggestionInput | CodeSelectionCreateManyCodeSuggestionInput[]
    skipDuplicates?: boolean
  }

  export type EncounterUpsertWithoutCodeSuggestionsInput = {
    update: XOR<EncounterUpdateWithoutCodeSuggestionsInput, EncounterUncheckedUpdateWithoutCodeSuggestionsInput>
    create: XOR<EncounterCreateWithoutCodeSuggestionsInput, EncounterUncheckedCreateWithoutCodeSuggestionsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutCodeSuggestionsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutCodeSuggestionsInput, EncounterUncheckedUpdateWithoutCodeSuggestionsInput>
  }

  export type EncounterUpdateWithoutCodeSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutCodeSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type SuggestionGenerationUpsertWithoutSuggestionsInput = {
    update: XOR<SuggestionGenerationUpdateWithoutSuggestionsInput, SuggestionGenerationUncheckedUpdateWithoutSuggestionsInput>
    create: XOR<SuggestionGenerationCreateWithoutSuggestionsInput, SuggestionGenerationUncheckedCreateWithoutSuggestionsInput>
    where?: SuggestionGenerationWhereInput
  }

  export type SuggestionGenerationUpdateToOneWithWhereWithoutSuggestionsInput = {
    where?: SuggestionGenerationWhereInput
    data: XOR<SuggestionGenerationUpdateWithoutSuggestionsInput, SuggestionGenerationUncheckedUpdateWithoutSuggestionsInput>
  }

  export type SuggestionGenerationUpdateWithoutSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    textDelta?: IntFieldUpdateOperationsInput | number
    transcriptDelta?: IntFieldUpdateOperationsInput | number
    inputHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutSuggestionCyclesNestedInput
    createdBy?: UserUpdateOneWithoutSuggestionGenerationsNestedInput
  }

  export type SuggestionGenerationUncheckedUpdateWithoutSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    textDelta?: IntFieldUpdateOperationsInput | number
    transcriptDelta?: IntFieldUpdateOperationsInput | number
    inputHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSelectionUpsertWithWhereUniqueWithoutCodeSuggestionInput = {
    where: CodeSelectionWhereUniqueInput
    update: XOR<CodeSelectionUpdateWithoutCodeSuggestionInput, CodeSelectionUncheckedUpdateWithoutCodeSuggestionInput>
    create: XOR<CodeSelectionCreateWithoutCodeSuggestionInput, CodeSelectionUncheckedCreateWithoutCodeSuggestionInput>
  }

  export type CodeSelectionUpdateWithWhereUniqueWithoutCodeSuggestionInput = {
    where: CodeSelectionWhereUniqueInput
    data: XOR<CodeSelectionUpdateWithoutCodeSuggestionInput, CodeSelectionUncheckedUpdateWithoutCodeSuggestionInput>
  }

  export type CodeSelectionUpdateManyWithWhereWithoutCodeSuggestionInput = {
    where: CodeSelectionScalarWhereInput
    data: XOR<CodeSelectionUpdateManyMutationInput, CodeSelectionUncheckedUpdateManyWithoutCodeSuggestionInput>
  }

  export type EncounterCreateWithoutCodeSelectionsInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutCodeSelectionsInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutCodeSelectionsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutCodeSelectionsInput, EncounterUncheckedCreateWithoutCodeSelectionsInput>
  }

  export type CodeSuggestionCreateWithoutSelectionsInput = {
    id?: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    title: string
    description: string
    rationale: string
    confidence: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.SuggestionStatus
    recommended?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutCodeSuggestionsInput
    generation: SuggestionGenerationCreateNestedOneWithoutSuggestionsInput
  }

  export type CodeSuggestionUncheckedCreateWithoutSelectionsInput = {
    id?: string
    encounterId: string
    generationId: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    title: string
    description: string
    rationale: string
    confidence: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.SuggestionStatus
    recommended?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeSuggestionCreateOrConnectWithoutSelectionsInput = {
    where: CodeSuggestionWhereUniqueInput
    create: XOR<CodeSuggestionCreateWithoutSelectionsInput, CodeSuggestionUncheckedCreateWithoutSelectionsInput>
  }

  export type UserCreateWithoutCodeSelectionsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCodeSelectionsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCodeSelectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCodeSelectionsInput, UserUncheckedCreateWithoutCodeSelectionsInput>
  }

  export type EncounterUpsertWithoutCodeSelectionsInput = {
    update: XOR<EncounterUpdateWithoutCodeSelectionsInput, EncounterUncheckedUpdateWithoutCodeSelectionsInput>
    create: XOR<EncounterCreateWithoutCodeSelectionsInput, EncounterUncheckedCreateWithoutCodeSelectionsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutCodeSelectionsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutCodeSelectionsInput, EncounterUncheckedUpdateWithoutCodeSelectionsInput>
  }

  export type EncounterUpdateWithoutCodeSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutCodeSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type CodeSuggestionUpsertWithoutSelectionsInput = {
    update: XOR<CodeSuggestionUpdateWithoutSelectionsInput, CodeSuggestionUncheckedUpdateWithoutSelectionsInput>
    create: XOR<CodeSuggestionCreateWithoutSelectionsInput, CodeSuggestionUncheckedCreateWithoutSelectionsInput>
    where?: CodeSuggestionWhereInput
  }

  export type CodeSuggestionUpdateToOneWithWhereWithoutSelectionsInput = {
    where?: CodeSuggestionWhereInput
    data: XOR<CodeSuggestionUpdateWithoutSelectionsInput, CodeSuggestionUncheckedUpdateWithoutSelectionsInput>
  }

  export type CodeSuggestionUpdateWithoutSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumSuggestionStatusFieldUpdateOperationsInput | $Enums.SuggestionStatus
    recommended?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutCodeSuggestionsNestedInput
    generation?: SuggestionGenerationUpdateOneRequiredWithoutSuggestionsNestedInput
  }

  export type CodeSuggestionUncheckedUpdateWithoutSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    generationId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumSuggestionStatusFieldUpdateOperationsInput | $Enums.SuggestionStatus
    recommended?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCodeSelectionsInput = {
    update: XOR<UserUpdateWithoutCodeSelectionsInput, UserUncheckedUpdateWithoutCodeSelectionsInput>
    create: XOR<UserCreateWithoutCodeSelectionsInput, UserUncheckedCreateWithoutCodeSelectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCodeSelectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCodeSelectionsInput, UserUncheckedUpdateWithoutCodeSelectionsInput>
  }

  export type UserUpdateWithoutCodeSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCodeSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EncounterCreateWithoutComplianceIssuesInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutComplianceIssuesInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutComplianceIssuesInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutComplianceIssuesInput, EncounterUncheckedCreateWithoutComplianceIssuesInput>
  }

  export type UserCreateWithoutComplianceIssuesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutComplianceIssuesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutComplianceIssuesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutComplianceIssuesInput, UserUncheckedCreateWithoutComplianceIssuesInput>
  }

  export type EncounterUpsertWithoutComplianceIssuesInput = {
    update: XOR<EncounterUpdateWithoutComplianceIssuesInput, EncounterUncheckedUpdateWithoutComplianceIssuesInput>
    create: XOR<EncounterCreateWithoutComplianceIssuesInput, EncounterUncheckedCreateWithoutComplianceIssuesInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutComplianceIssuesInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutComplianceIssuesInput, EncounterUncheckedUpdateWithoutComplianceIssuesInput>
  }

  export type EncounterUpdateWithoutComplianceIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutComplianceIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type UserUpsertWithoutComplianceIssuesInput = {
    update: XOR<UserUpdateWithoutComplianceIssuesInput, UserUncheckedUpdateWithoutComplianceIssuesInput>
    create: XOR<UserCreateWithoutComplianceIssuesInput, UserUncheckedCreateWithoutComplianceIssuesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutComplianceIssuesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutComplianceIssuesInput, UserUncheckedUpdateWithoutComplianceIssuesInput>
  }

  export type UserUpdateWithoutComplianceIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutComplianceIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EncounterCreateWithoutWizardRunsInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutWizardRunsInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutWizardRunsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutWizardRunsInput, EncounterUncheckedCreateWithoutWizardRunsInput>
  }

  export type WizardStepStateCreateWithoutWizardRunInput = {
    id?: string
    step: $Enums.WizardStep
    status?: $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutWizardStepStatesInput
    lastActor?: UserCreateNestedOneWithoutWizardStepStatesInput
  }

  export type WizardStepStateUncheckedCreateWithoutWizardRunInput = {
    id?: string
    encounterId: string
    step: $Enums.WizardStep
    status?: $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    lastActorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WizardStepStateCreateOrConnectWithoutWizardRunInput = {
    where: WizardStepStateWhereUniqueInput
    create: XOR<WizardStepStateCreateWithoutWizardRunInput, WizardStepStateUncheckedCreateWithoutWizardRunInput>
  }

  export type WizardStepStateCreateManyWizardRunInputEnvelope = {
    data: WizardStepStateCreateManyWizardRunInput | WizardStepStateCreateManyWizardRunInput[]
    skipDuplicates?: boolean
  }

  export type EncounterUpsertWithoutWizardRunsInput = {
    update: XOR<EncounterUpdateWithoutWizardRunsInput, EncounterUncheckedUpdateWithoutWizardRunsInput>
    create: XOR<EncounterCreateWithoutWizardRunsInput, EncounterUncheckedCreateWithoutWizardRunsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutWizardRunsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutWizardRunsInput, EncounterUncheckedUpdateWithoutWizardRunsInput>
  }

  export type EncounterUpdateWithoutWizardRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutWizardRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type WizardStepStateUpsertWithWhereUniqueWithoutWizardRunInput = {
    where: WizardStepStateWhereUniqueInput
    update: XOR<WizardStepStateUpdateWithoutWizardRunInput, WizardStepStateUncheckedUpdateWithoutWizardRunInput>
    create: XOR<WizardStepStateCreateWithoutWizardRunInput, WizardStepStateUncheckedCreateWithoutWizardRunInput>
  }

  export type WizardStepStateUpdateWithWhereUniqueWithoutWizardRunInput = {
    where: WizardStepStateWhereUniqueInput
    data: XOR<WizardStepStateUpdateWithoutWizardRunInput, WizardStepStateUncheckedUpdateWithoutWizardRunInput>
  }

  export type WizardStepStateUpdateManyWithWhereWithoutWizardRunInput = {
    where: WizardStepStateScalarWhereInput
    data: XOR<WizardStepStateUpdateManyMutationInput, WizardStepStateUncheckedUpdateManyWithoutWizardRunInput>
  }

  export type WizardRunCreateWithoutStepStatesInput = {
    id?: string
    status?: $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    encounter: EncounterCreateNestedOneWithoutWizardRunsInput
  }

  export type WizardRunUncheckedCreateWithoutStepStatesInput = {
    id?: string
    encounterId: string
    status?: $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type WizardRunCreateOrConnectWithoutStepStatesInput = {
    where: WizardRunWhereUniqueInput
    create: XOR<WizardRunCreateWithoutStepStatesInput, WizardRunUncheckedCreateWithoutStepStatesInput>
  }

  export type EncounterCreateWithoutWizardStepStatesInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutWizardStepStatesInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutWizardStepStatesInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutWizardStepStatesInput, EncounterUncheckedCreateWithoutWizardStepStatesInput>
  }

  export type UserCreateWithoutWizardStepStatesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWizardStepStatesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWizardStepStatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWizardStepStatesInput, UserUncheckedCreateWithoutWizardStepStatesInput>
  }

  export type WizardRunUpsertWithoutStepStatesInput = {
    update: XOR<WizardRunUpdateWithoutStepStatesInput, WizardRunUncheckedUpdateWithoutStepStatesInput>
    create: XOR<WizardRunCreateWithoutStepStatesInput, WizardRunUncheckedCreateWithoutStepStatesInput>
    where?: WizardRunWhereInput
  }

  export type WizardRunUpdateToOneWithWhereWithoutStepStatesInput = {
    where?: WizardRunWhereInput
    data: XOR<WizardRunUpdateWithoutStepStatesInput, WizardRunUncheckedUpdateWithoutStepStatesInput>
  }

  export type WizardRunUpdateWithoutStepStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWizardRunStatusFieldUpdateOperationsInput | $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    encounter?: EncounterUpdateOneRequiredWithoutWizardRunsNestedInput
  }

  export type WizardRunUncheckedUpdateWithoutStepStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    status?: EnumWizardRunStatusFieldUpdateOperationsInput | $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EncounterUpsertWithoutWizardStepStatesInput = {
    update: XOR<EncounterUpdateWithoutWizardStepStatesInput, EncounterUncheckedUpdateWithoutWizardStepStatesInput>
    create: XOR<EncounterCreateWithoutWizardStepStatesInput, EncounterUncheckedCreateWithoutWizardStepStatesInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutWizardStepStatesInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutWizardStepStatesInput, EncounterUncheckedUpdateWithoutWizardStepStatesInput>
  }

  export type EncounterUpdateWithoutWizardStepStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutWizardStepStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type UserUpsertWithoutWizardStepStatesInput = {
    update: XOR<UserUpdateWithoutWizardStepStatesInput, UserUncheckedUpdateWithoutWizardStepStatesInput>
    create: XOR<UserCreateWithoutWizardStepStatesInput, UserUncheckedCreateWithoutWizardStepStatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWizardStepStatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWizardStepStatesInput, UserUncheckedUpdateWithoutWizardStepStatesInput>
  }

  export type UserUpdateWithoutWizardStepStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWizardStepStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EncounterCreateWithoutExportArtifactsInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutExportArtifactsInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutExportArtifactsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutExportArtifactsInput, EncounterUncheckedCreateWithoutExportArtifactsInput>
  }

  export type NoteCreateWithoutExportArtifactsInput = {
    id?: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutNoteInput
    createdBy?: UserCreateNestedOneWithoutNotesCreatedInput
    updatedBy?: UserCreateNestedOneWithoutNotesUpdatedInput
    versions?: NoteVersionCreateNestedManyWithoutNoteInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateWithoutExportArtifactsInput = {
    id?: string
    encounterId: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    createdById?: string | null
    updatedById?: string | null
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: NoteVersionUncheckedCreateNestedManyWithoutNoteInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteCreateOrConnectWithoutExportArtifactsInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutExportArtifactsInput, NoteUncheckedCreateWithoutExportArtifactsInput>
  }

  export type UserCreateWithoutExportArtifactsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExportArtifactsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExportArtifactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExportArtifactsInput, UserUncheckedCreateWithoutExportArtifactsInput>
  }

  export type EncounterUpsertWithoutExportArtifactsInput = {
    update: XOR<EncounterUpdateWithoutExportArtifactsInput, EncounterUncheckedUpdateWithoutExportArtifactsInput>
    create: XOR<EncounterCreateWithoutExportArtifactsInput, EncounterUncheckedCreateWithoutExportArtifactsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutExportArtifactsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutExportArtifactsInput, EncounterUncheckedUpdateWithoutExportArtifactsInput>
  }

  export type EncounterUpdateWithoutExportArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutExportArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type NoteUpsertWithoutExportArtifactsInput = {
    update: XOR<NoteUpdateWithoutExportArtifactsInput, NoteUncheckedUpdateWithoutExportArtifactsInput>
    create: XOR<NoteCreateWithoutExportArtifactsInput, NoteUncheckedCreateWithoutExportArtifactsInput>
    where?: NoteWhereInput
  }

  export type NoteUpdateToOneWithWhereWithoutExportArtifactsInput = {
    where?: NoteWhereInput
    data: XOR<NoteUpdateWithoutExportArtifactsInput, NoteUncheckedUpdateWithoutExportArtifactsInput>
  }

  export type NoteUpdateWithoutExportArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutNoteNestedInput
    createdBy?: UserUpdateOneWithoutNotesCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutNotesUpdatedNestedInput
    versions?: NoteVersionUpdateManyWithoutNoteNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateWithoutExportArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: NoteVersionUncheckedUpdateManyWithoutNoteNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type UserUpsertWithoutExportArtifactsInput = {
    update: XOR<UserUpdateWithoutExportArtifactsInput, UserUncheckedUpdateWithoutExportArtifactsInput>
    create: XOR<UserCreateWithoutExportArtifactsInput, UserUncheckedCreateWithoutExportArtifactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExportArtifactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExportArtifactsInput, UserUncheckedUpdateWithoutExportArtifactsInput>
  }

  export type UserUpdateWithoutExportArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExportArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type EncounterCreateWithoutAuditLogsInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutAuditLogsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutAuditLogsInput, EncounterUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EncounterUpsertWithoutAuditLogsInput = {
    update: XOR<EncounterUpdateWithoutAuditLogsInput, EncounterUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<EncounterCreateWithoutAuditLogsInput, EncounterUncheckedCreateWithoutAuditLogsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutAuditLogsInput, EncounterUncheckedUpdateWithoutAuditLogsInput>
  }

  export type EncounterUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type UserCreateWithoutAuthSessionsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    dispatchJobs?: DispatchJobCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuthSessionsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    dispatchJobs?: DispatchJobUncheckedCreateNestedManyWithoutCreatedByInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuthSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthSessionsInput, UserUncheckedCreateWithoutAuthSessionsInput>
  }

  export type UserUpsertWithoutAuthSessionsInput = {
    update: XOR<UserUpdateWithoutAuthSessionsInput, UserUncheckedUpdateWithoutAuthSessionsInput>
    create: XOR<UserCreateWithoutAuthSessionsInput, UserUncheckedCreateWithoutAuthSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthSessionsInput, UserUncheckedUpdateWithoutAuthSessionsInput>
  }

  export type UserUpdateWithoutAuthSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutCreatedByNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EncounterCreateWithoutDispatchJobsInput = {
    id?: string
    externalId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    provider?: UserCreateNestedOneWithoutEncountersProvidedInput
    note?: NoteCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutDispatchJobsInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: NoteUncheckedCreateNestedOneWithoutEncounterInput
    transcriptSegments?: TranscriptSegmentUncheckedCreateNestedManyWithoutEncounterInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutEncounterInput
    suggestionCycles?: SuggestionGenerationUncheckedCreateNestedManyWithoutEncounterInput
    codeSuggestions?: CodeSuggestionUncheckedCreateNestedManyWithoutEncounterInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutEncounterInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutEncounterInput
    wizardRuns?: WizardRunUncheckedCreateNestedManyWithoutEncounterInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutEncounterInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutEncounterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutDispatchJobsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutDispatchJobsInput, EncounterUncheckedCreateWithoutDispatchJobsInput>
  }

  export type NoteCreateWithoutDispatchJobsInput = {
    id?: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutNoteInput
    createdBy?: UserCreateNestedOneWithoutNotesCreatedInput
    updatedBy?: UserCreateNestedOneWithoutNotesUpdatedInput
    versions?: NoteVersionCreateNestedManyWithoutNoteInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateWithoutDispatchJobsInput = {
    id?: string
    encounterId: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    createdById?: string | null
    updatedById?: string | null
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: NoteVersionUncheckedCreateNestedManyWithoutNoteInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteCreateOrConnectWithoutDispatchJobsInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutDispatchJobsInput, NoteUncheckedCreateWithoutDispatchJobsInput>
  }

  export type UserCreateWithoutDispatchJobsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterCreateNestedManyWithoutProviderInput
    notesCreated?: NoteCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDispatchJobsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    passwordHash?: string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointmentsCreated?: AppointmentUncheckedCreateNestedManyWithoutCreatedByInput
    appointmentsProvided?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encountersProvided?: EncounterUncheckedCreateNestedManyWithoutProviderInput
    notesCreated?: NoteUncheckedCreateNestedManyWithoutCreatedByInput
    notesUpdated?: NoteUncheckedCreateNestedManyWithoutUpdatedByInput
    noteVersions?: NoteVersionUncheckedCreateNestedManyWithoutCreatedByInput
    chartAssets?: ChartAssetUncheckedCreateNestedManyWithoutCreatedByInput
    suggestionGenerations?: SuggestionGenerationUncheckedCreateNestedManyWithoutCreatedByInput
    codeSelections?: CodeSelectionUncheckedCreateNestedManyWithoutActorInput
    complianceIssues?: ComplianceIssueUncheckedCreateNestedManyWithoutActorInput
    wizardStepStates?: WizardStepStateUncheckedCreateNestedManyWithoutLastActorInput
    exportArtifacts?: ExportArtifactUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDispatchJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDispatchJobsInput, UserUncheckedCreateWithoutDispatchJobsInput>
  }

  export type EncounterUpsertWithoutDispatchJobsInput = {
    update: XOR<EncounterUpdateWithoutDispatchJobsInput, EncounterUncheckedUpdateWithoutDispatchJobsInput>
    create: XOR<EncounterCreateWithoutDispatchJobsInput, EncounterUncheckedCreateWithoutDispatchJobsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutDispatchJobsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutDispatchJobsInput, EncounterUncheckedUpdateWithoutDispatchJobsInput>
  }

  export type EncounterUpdateWithoutDispatchJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutDispatchJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type NoteUpsertWithoutDispatchJobsInput = {
    update: XOR<NoteUpdateWithoutDispatchJobsInput, NoteUncheckedUpdateWithoutDispatchJobsInput>
    create: XOR<NoteCreateWithoutDispatchJobsInput, NoteUncheckedCreateWithoutDispatchJobsInput>
    where?: NoteWhereInput
  }

  export type NoteUpdateToOneWithWhereWithoutDispatchJobsInput = {
    where?: NoteWhereInput
    data: XOR<NoteUpdateWithoutDispatchJobsInput, NoteUncheckedUpdateWithoutDispatchJobsInput>
  }

  export type NoteUpdateWithoutDispatchJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutNoteNestedInput
    createdBy?: UserUpdateOneWithoutNotesCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutNotesUpdatedNestedInput
    versions?: NoteVersionUpdateManyWithoutNoteNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateWithoutDispatchJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: NoteVersionUncheckedUpdateManyWithoutNoteNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type UserUpsertWithoutDispatchJobsInput = {
    update: XOR<UserUpdateWithoutDispatchJobsInput, UserUncheckedUpdateWithoutDispatchJobsInput>
    create: XOR<UserCreateWithoutDispatchJobsInput, UserUncheckedCreateWithoutDispatchJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDispatchJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDispatchJobsInput, UserUncheckedUpdateWithoutDispatchJobsInput>
  }

  export type UserUpdateWithoutDispatchJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDispatchJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodesHash?: NullableJsonNullValueInput | InputJsonValue
    mfaEnrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentsCreated?: AppointmentUncheckedUpdateManyWithoutCreatedByNestedInput
    appointmentsProvided?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encountersProvided?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
    notesCreated?: NoteUncheckedUpdateManyWithoutCreatedByNestedInput
    notesUpdated?: NoteUncheckedUpdateManyWithoutUpdatedByNestedInput
    noteVersions?: NoteVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutCreatedByNestedInput
    suggestionGenerations?: SuggestionGenerationUncheckedUpdateManyWithoutCreatedByNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutActorNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutActorNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutLastActorNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AppointmentCreateManyCreatedByInput = {
    id?: string
    externalId: string
    patientId: string
    providerId?: string | null
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateManyProviderInput = {
    id?: string
    externalId: string
    patientId: string
    createdById?: string | null
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterCreateManyProviderInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    patientId: string
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateManyCreatedByInput = {
    id?: string
    encounterId: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    updatedById?: string | null
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateManyUpdatedByInput = {
    id?: string
    encounterId: string
    status?: $Enums.NoteStatus
    visibility?: $Enums.NoteVisibility
    content?: string
    patientSummary?: string
    createdById?: string | null
    finalizedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteVersionCreateManyCreatedByInput = {
    id?: string
    noteId: string
    versionNumber: number
    source: string
    content: string
    patientSummary: string
    traceId?: string | null
    createdAt?: Date | string
  }

  export type ChartAssetCreateManyCreatedByInput = {
    id?: string
    appointmentId?: string | null
    encounterId?: string | null
    patientId?: string | null
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdAt?: Date | string
  }

  export type SuggestionGenerationCreateManyCreatedByInput = {
    id?: string
    encounterId: string
    trigger: string
    textDelta?: number
    transcriptDelta?: number
    inputHash?: string | null
    createdAt?: Date | string
  }

  export type CodeSelectionCreateManyActorInput = {
    id?: string
    encounterId: string
    codeSuggestionId?: string | null
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    action: $Enums.SelectionAction
    decisionReason?: string | null
    createdAt?: Date | string
  }

  export type ComplianceIssueCreateManyActorInput = {
    id?: string
    encounterId: string
    severity: $Enums.ComplianceSeverity
    status?: $Enums.ComplianceStatus
    title: string
    description: string
    rationale: string
    remediation: string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint: string
    resolvedAt?: Date | string | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WizardStepStateCreateManyLastActorInput = {
    id?: string
    wizardRunId: string
    encounterId: string
    step: $Enums.WizardStep
    status?: $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExportArtifactCreateManyCreatedByInput = {
    id?: string
    encounterId: string
    noteId?: string | null
    type: $Enums.ArtifactType
    filePath: string
    mimeType: string
    fileName: string
    sizeBytes: number
    createdAt?: Date | string
  }

  export type AuditLogCreateManyActorInput = {
    id?: string
    encounterId?: string | null
    action: string
    entity: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuthSessionCreateManyUserInput = {
    id?: string
    refreshTokenHash: string
    expiresAt: Date | string
    revokedAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DispatchJobCreateManyCreatedByInput = {
    id?: string
    encounterId: string
    noteId?: string | null
    target?: $Enums.DispatchTarget
    status?: $Enums.DispatchStatus
    contractType?: string | null
    attemptCount?: number
    maxAttempts?: number
    nextRetryAt?: Date | string | null
    dispatchedAt?: Date | string | null
    deadLetteredAt?: Date | string | null
    externalMessageId?: string | null
    lastError?: string | null
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    provider?: UserUpdateOneWithoutAppointmentsProvidedNestedInput
    encounter?: EncounterUpdateOneWithoutAppointmentNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUncheckedUpdateOneWithoutAppointmentNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    createdBy?: UserUpdateOneWithoutAppointmentsCreatedNestedInput
    encounter?: EncounterUpdateOneWithoutAppointmentNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUncheckedUpdateOneWithoutAppointmentNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutNoteNestedInput
    updatedBy?: UserUpdateOneWithoutNotesUpdatedNestedInput
    versions?: NoteVersionUpdateManyWithoutNoteNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutNoteNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: NoteVersionUncheckedUpdateManyWithoutNoteNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutNoteNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutNoteNestedInput
    createdBy?: UserUpdateOneWithoutNotesCreatedNestedInput
    versions?: NoteVersionUpdateManyWithoutNoteNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutNoteNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: NoteVersionUncheckedUpdateManyWithoutNoteNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutNoteNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    status?: EnumNoteStatusFieldUpdateOperationsInput | $Enums.NoteStatus
    visibility?: EnumNoteVisibilityFieldUpdateOperationsInput | $Enums.NoteVisibility
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteVersionUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type NoteVersionUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteVersionUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartAssetUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutChartAssetsNestedInput
    encounter?: EncounterUpdateOneWithoutChartAssetsNestedInput
    patient?: PatientUpdateOneWithoutChartAssetsNestedInput
  }

  export type ChartAssetUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartAssetUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestionGenerationUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    textDelta?: IntFieldUpdateOperationsInput | number
    transcriptDelta?: IntFieldUpdateOperationsInput | number
    inputHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutSuggestionCyclesNestedInput
    suggestions?: CodeSuggestionUpdateManyWithoutGenerationNestedInput
  }

  export type SuggestionGenerationUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    textDelta?: IntFieldUpdateOperationsInput | number
    transcriptDelta?: IntFieldUpdateOperationsInput | number
    inputHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suggestions?: CodeSuggestionUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type SuggestionGenerationUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    textDelta?: IntFieldUpdateOperationsInput | number
    transcriptDelta?: IntFieldUpdateOperationsInput | number
    inputHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSelectionUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    action?: EnumSelectionActionFieldUpdateOperationsInput | $Enums.SelectionAction
    decisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutCodeSelectionsNestedInput
    codeSuggestion?: CodeSuggestionUpdateOneWithoutSelectionsNestedInput
  }

  export type CodeSelectionUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    codeSuggestionId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    action?: EnumSelectionActionFieldUpdateOperationsInput | $Enums.SelectionAction
    decisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSelectionUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    codeSuggestionId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    action?: EnumSelectionActionFieldUpdateOperationsInput | $Enums.SelectionAction
    decisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceIssueUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumComplianceSeverityFieldUpdateOperationsInput | $Enums.ComplianceSeverity
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    remediation?: StringFieldUpdateOperationsInput | string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutComplianceIssuesNestedInput
  }

  export type ComplianceIssueUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    severity?: EnumComplianceSeverityFieldUpdateOperationsInput | $Enums.ComplianceSeverity
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    remediation?: StringFieldUpdateOperationsInput | string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceIssueUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    severity?: EnumComplianceSeverityFieldUpdateOperationsInput | $Enums.ComplianceSeverity
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    remediation?: StringFieldUpdateOperationsInput | string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WizardStepStateUpdateWithoutLastActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: EnumWizardStepFieldUpdateOperationsInput | $Enums.WizardStep
    status?: EnumWizardStepStatusFieldUpdateOperationsInput | $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wizardRun?: WizardRunUpdateOneRequiredWithoutStepStatesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutWizardStepStatesNestedInput
  }

  export type WizardStepStateUncheckedUpdateWithoutLastActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    wizardRunId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    step?: EnumWizardStepFieldUpdateOperationsInput | $Enums.WizardStep
    status?: EnumWizardStepStatusFieldUpdateOperationsInput | $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WizardStepStateUncheckedUpdateManyWithoutLastActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    wizardRunId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    step?: EnumWizardStepFieldUpdateOperationsInput | $Enums.WizardStep
    status?: EnumWizardStepStatusFieldUpdateOperationsInput | $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportArtifactUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutExportArtifactsNestedInput
    note?: NoteUpdateOneWithoutExportArtifactsNestedInput
  }

  export type ExportArtifactUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportArtifactUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchJobUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: EnumDispatchTargetFieldUpdateOperationsInput | $Enums.DispatchTarget
    status?: EnumDispatchStatusFieldUpdateOperationsInput | $Enums.DispatchStatus
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutDispatchJobsNestedInput
    note?: NoteUpdateOneWithoutDispatchJobsNestedInput
  }

  export type DispatchJobUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    target?: EnumDispatchTargetFieldUpdateOperationsInput | $Enums.DispatchTarget
    status?: EnumDispatchStatusFieldUpdateOperationsInput | $Enums.DispatchStatus
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchJobUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    target?: EnumDispatchTargetFieldUpdateOperationsInput | $Enums.DispatchTarget
    status?: EnumDispatchStatusFieldUpdateOperationsInput | $Enums.DispatchStatus
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyPatientInput = {
    id?: string
    externalId: string
    providerId?: string | null
    createdById?: string | null
    scheduledAt: Date | string
    durationMinutes?: number
    appointmentType: string
    location?: string | null
    status?: $Enums.AppointmentStatus
    priority?: $Enums.AppointmentPriority
    isVirtual?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterCreateManyPatientInput = {
    id?: string
    externalId: string
    appointmentId?: string | null
    providerId?: string | null
    status?: $Enums.EncounterStatus
    startedAt?: Date | string | null
    stoppedAt?: Date | string | null
    hiddenDraftCreated?: Date | string | null
    draftUnhiddenAt?: Date | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChartAssetCreateManyPatientInput = {
    id?: string
    appointmentId?: string | null
    encounterId?: string | null
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type AppointmentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneWithoutAppointmentsProvidedNestedInput
    createdBy?: UserUpdateOneWithoutAppointmentsCreatedNestedInput
    encounter?: EncounterUpdateOneWithoutAppointmentNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUncheckedUpdateOneWithoutAppointmentNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    appointmentType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    priority?: EnumAppointmentPriorityFieldUpdateOperationsInput | $Enums.AppointmentPriority
    isVirtual?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutEncounterNestedInput
    provider?: UserUpdateOneWithoutEncountersProvidedNestedInput
    note?: NoteUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUncheckedUpdateOneWithoutEncounterNestedInput
    transcriptSegments?: TranscriptSegmentUncheckedUpdateManyWithoutEncounterNestedInput
    chartAssets?: ChartAssetUncheckedUpdateManyWithoutEncounterNestedInput
    suggestionCycles?: SuggestionGenerationUncheckedUpdateManyWithoutEncounterNestedInput
    codeSuggestions?: CodeSuggestionUncheckedUpdateManyWithoutEncounterNestedInput
    codeSelections?: CodeSelectionUncheckedUpdateManyWithoutEncounterNestedInput
    complianceIssues?: ComplianceIssueUncheckedUpdateManyWithoutEncounterNestedInput
    wizardRuns?: WizardRunUncheckedUpdateManyWithoutEncounterNestedInput
    wizardStepStates?: WizardStepStateUncheckedUpdateManyWithoutEncounterNestedInput
    exportArtifacts?: ExportArtifactUncheckedUpdateManyWithoutEncounterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutEncounterNestedInput
    dispatchJobs?: DispatchJobUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenDraftCreated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    draftUnhiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartAssetUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutChartAssetsNestedInput
    encounter?: EncounterUpdateOneWithoutChartAssetsNestedInput
    createdBy?: UserUpdateOneWithoutChartAssetsNestedInput
  }

  export type ChartAssetUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartAssetUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartAssetCreateManyAppointmentInput = {
    id?: string
    encounterId?: string | null
    patientId?: string | null
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type ChartAssetUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneWithoutChartAssetsNestedInput
    patient?: PatientUpdateOneWithoutChartAssetsNestedInput
    createdBy?: UserUpdateOneWithoutChartAssetsNestedInput
  }

  export type ChartAssetUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartAssetUncheckedUpdateManyWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptSegmentCreateManyEncounterInput = {
    id?: string
    speaker: string
    speakerLabel?: string | null
    text: string
    startMs: number
    endMs: number
    source?: $Enums.TranscriptSource
    confidence?: number | null
    createdAt?: Date | string
  }

  export type ChartAssetCreateManyEncounterInput = {
    id?: string
    appointmentId?: string | null
    patientId?: string | null
    fileName: string
    mimeType: string
    sizeBytes: number
    storagePath: string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type SuggestionGenerationCreateManyEncounterInput = {
    id?: string
    trigger: string
    textDelta?: number
    transcriptDelta?: number
    inputHash?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type CodeSuggestionCreateManyEncounterInput = {
    id?: string
    generationId: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    title: string
    description: string
    rationale: string
    confidence: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.SuggestionStatus
    recommended?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeSelectionCreateManyEncounterInput = {
    id?: string
    codeSuggestionId?: string | null
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    action: $Enums.SelectionAction
    decisionReason?: string | null
    actorId?: string | null
    createdAt?: Date | string
  }

  export type ComplianceIssueCreateManyEncounterInput = {
    id?: string
    severity: $Enums.ComplianceSeverity
    status?: $Enums.ComplianceStatus
    title: string
    description: string
    rationale: string
    remediation: string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint: string
    actorId?: string | null
    resolvedAt?: Date | string | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WizardRunCreateManyEncounterInput = {
    id?: string
    status?: $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type WizardStepStateCreateManyEncounterInput = {
    id?: string
    wizardRunId: string
    step: $Enums.WizardStep
    status?: $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    lastActorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExportArtifactCreateManyEncounterInput = {
    id?: string
    noteId?: string | null
    type: $Enums.ArtifactType
    filePath: string
    mimeType: string
    fileName: string
    sizeBytes: number
    createdById?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateManyEncounterInput = {
    id?: string
    actorId?: string | null
    action: string
    entity: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DispatchJobCreateManyEncounterInput = {
    id?: string
    noteId?: string | null
    target?: $Enums.DispatchTarget
    status?: $Enums.DispatchStatus
    contractType?: string | null
    attemptCount?: number
    maxAttempts?: number
    nextRetryAt?: Date | string | null
    dispatchedAt?: Date | string | null
    deadLetteredAt?: Date | string | null
    externalMessageId?: string | null
    lastError?: string | null
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptSegmentUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
    speakerLabel?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    startMs?: IntFieldUpdateOperationsInput | number
    endMs?: IntFieldUpdateOperationsInput | number
    source?: EnumTranscriptSourceFieldUpdateOperationsInput | $Enums.TranscriptSource
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptSegmentUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
    speakerLabel?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    startMs?: IntFieldUpdateOperationsInput | number
    endMs?: IntFieldUpdateOperationsInput | number
    source?: EnumTranscriptSourceFieldUpdateOperationsInput | $Enums.TranscriptSource
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptSegmentUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: StringFieldUpdateOperationsInput | string
    speakerLabel?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    startMs?: IntFieldUpdateOperationsInput | number
    endMs?: IntFieldUpdateOperationsInput | number
    source?: EnumTranscriptSourceFieldUpdateOperationsInput | $Enums.TranscriptSource
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartAssetUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutChartAssetsNestedInput
    patient?: PatientUpdateOneWithoutChartAssetsNestedInput
    createdBy?: UserUpdateOneWithoutChartAssetsNestedInput
  }

  export type ChartAssetUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartAssetUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    extractedJson?: NullableJsonNullValueInput | InputJsonValue
    rawText?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestionGenerationUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    textDelta?: IntFieldUpdateOperationsInput | number
    transcriptDelta?: IntFieldUpdateOperationsInput | number
    inputHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutSuggestionGenerationsNestedInput
    suggestions?: CodeSuggestionUpdateManyWithoutGenerationNestedInput
  }

  export type SuggestionGenerationUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    textDelta?: IntFieldUpdateOperationsInput | number
    transcriptDelta?: IntFieldUpdateOperationsInput | number
    inputHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suggestions?: CodeSuggestionUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type SuggestionGenerationUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    textDelta?: IntFieldUpdateOperationsInput | number
    transcriptDelta?: IntFieldUpdateOperationsInput | number
    inputHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSuggestionUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumSuggestionStatusFieldUpdateOperationsInput | $Enums.SuggestionStatus
    recommended?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generation?: SuggestionGenerationUpdateOneRequiredWithoutSuggestionsNestedInput
    selections?: CodeSelectionUpdateManyWithoutCodeSuggestionNestedInput
  }

  export type CodeSuggestionUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    generationId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumSuggestionStatusFieldUpdateOperationsInput | $Enums.SuggestionStatus
    recommended?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    selections?: CodeSelectionUncheckedUpdateManyWithoutCodeSuggestionNestedInput
  }

  export type CodeSuggestionUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    generationId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumSuggestionStatusFieldUpdateOperationsInput | $Enums.SuggestionStatus
    recommended?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSelectionUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    action?: EnumSelectionActionFieldUpdateOperationsInput | $Enums.SelectionAction
    decisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codeSuggestion?: CodeSuggestionUpdateOneWithoutSelectionsNestedInput
    actor?: UserUpdateOneWithoutCodeSelectionsNestedInput
  }

  export type CodeSelectionUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeSuggestionId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    action?: EnumSelectionActionFieldUpdateOperationsInput | $Enums.SelectionAction
    decisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSelectionUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeSuggestionId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    action?: EnumSelectionActionFieldUpdateOperationsInput | $Enums.SelectionAction
    decisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceIssueUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumComplianceSeverityFieldUpdateOperationsInput | $Enums.ComplianceSeverity
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    remediation?: StringFieldUpdateOperationsInput | string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutComplianceIssuesNestedInput
  }

  export type ComplianceIssueUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumComplianceSeverityFieldUpdateOperationsInput | $Enums.ComplianceSeverity
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    remediation?: StringFieldUpdateOperationsInput | string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceIssueUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumComplianceSeverityFieldUpdateOperationsInput | $Enums.ComplianceSeverity
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    remediation?: StringFieldUpdateOperationsInput | string
    evidence?: NullableJsonNullValueInput | InputJsonValue
    fingerprint?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WizardRunUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWizardRunStatusFieldUpdateOperationsInput | $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepStates?: WizardStepStateUpdateManyWithoutWizardRunNestedInput
  }

  export type WizardRunUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWizardRunStatusFieldUpdateOperationsInput | $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepStates?: WizardStepStateUncheckedUpdateManyWithoutWizardRunNestedInput
  }

  export type WizardRunUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWizardRunStatusFieldUpdateOperationsInput | $Enums.WizardRunStatus
    runState?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WizardStepStateUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: EnumWizardStepFieldUpdateOperationsInput | $Enums.WizardStep
    status?: EnumWizardStepStatusFieldUpdateOperationsInput | $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wizardRun?: WizardRunUpdateOneRequiredWithoutStepStatesNestedInput
    lastActor?: UserUpdateOneWithoutWizardStepStatesNestedInput
  }

  export type WizardStepStateUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    wizardRunId?: StringFieldUpdateOperationsInput | string
    step?: EnumWizardStepFieldUpdateOperationsInput | $Enums.WizardStep
    status?: EnumWizardStepStatusFieldUpdateOperationsInput | $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    lastActorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WizardStepStateUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    wizardRunId?: StringFieldUpdateOperationsInput | string
    step?: EnumWizardStepFieldUpdateOperationsInput | $Enums.WizardStep
    status?: EnumWizardStepStatusFieldUpdateOperationsInput | $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    lastActorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportArtifactUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUpdateOneWithoutExportArtifactsNestedInput
    createdBy?: UserUpdateOneWithoutExportArtifactsNestedInput
  }

  export type ExportArtifactUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportArtifactUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchJobUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: EnumDispatchTargetFieldUpdateOperationsInput | $Enums.DispatchTarget
    status?: EnumDispatchStatusFieldUpdateOperationsInput | $Enums.DispatchStatus
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NoteUpdateOneWithoutDispatchJobsNestedInput
    createdBy?: UserUpdateOneWithoutDispatchJobsNestedInput
  }

  export type DispatchJobUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    target?: EnumDispatchTargetFieldUpdateOperationsInput | $Enums.DispatchTarget
    status?: EnumDispatchStatusFieldUpdateOperationsInput | $Enums.DispatchStatus
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchJobUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    target?: EnumDispatchTargetFieldUpdateOperationsInput | $Enums.DispatchTarget
    status?: EnumDispatchStatusFieldUpdateOperationsInput | $Enums.DispatchStatus
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteVersionCreateManyNoteInput = {
    id?: string
    versionNumber: number
    source: string
    content: string
    patientSummary: string
    traceId?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type ExportArtifactCreateManyNoteInput = {
    id?: string
    encounterId: string
    type: $Enums.ArtifactType
    filePath: string
    mimeType: string
    fileName: string
    sizeBytes: number
    createdById?: string | null
    createdAt?: Date | string
  }

  export type DispatchJobCreateManyNoteInput = {
    id?: string
    encounterId: string
    target?: $Enums.DispatchTarget
    status?: $Enums.DispatchStatus
    contractType?: string | null
    attemptCount?: number
    maxAttempts?: number
    nextRetryAt?: Date | string | null
    dispatchedAt?: Date | string | null
    deadLetteredAt?: Date | string | null
    externalMessageId?: string | null
    lastError?: string | null
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteVersionUpdateWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutNoteVersionsNestedInput
  }

  export type NoteVersionUncheckedUpdateWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteVersionUncheckedUpdateManyWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    patientSummary?: StringFieldUpdateOperationsInput | string
    traceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportArtifactUpdateWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutExportArtifactsNestedInput
    createdBy?: UserUpdateOneWithoutExportArtifactsNestedInput
  }

  export type ExportArtifactUncheckedUpdateWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportArtifactUncheckedUpdateManyWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchJobUpdateWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    target?: EnumDispatchTargetFieldUpdateOperationsInput | $Enums.DispatchTarget
    status?: EnumDispatchStatusFieldUpdateOperationsInput | $Enums.DispatchStatus
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutDispatchJobsNestedInput
    createdBy?: UserUpdateOneWithoutDispatchJobsNestedInput
  }

  export type DispatchJobUncheckedUpdateWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    target?: EnumDispatchTargetFieldUpdateOperationsInput | $Enums.DispatchTarget
    status?: EnumDispatchStatusFieldUpdateOperationsInput | $Enums.DispatchStatus
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchJobUncheckedUpdateManyWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    target?: EnumDispatchTargetFieldUpdateOperationsInput | $Enums.DispatchTarget
    status?: EnumDispatchStatusFieldUpdateOperationsInput | $Enums.DispatchStatus
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSuggestionCreateManyGenerationInput = {
    id?: string
    encounterId: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    title: string
    description: string
    rationale: string
    confidence: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.SuggestionStatus
    recommended?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeSuggestionUpdateWithoutGenerationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumSuggestionStatusFieldUpdateOperationsInput | $Enums.SuggestionStatus
    recommended?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutCodeSuggestionsNestedInput
    selections?: CodeSelectionUpdateManyWithoutCodeSuggestionNestedInput
  }

  export type CodeSuggestionUncheckedUpdateWithoutGenerationInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumSuggestionStatusFieldUpdateOperationsInput | $Enums.SuggestionStatus
    recommended?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    selections?: CodeSelectionUncheckedUpdateManyWithoutCodeSuggestionNestedInput
  }

  export type CodeSuggestionUncheckedUpdateManyWithoutGenerationInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumSuggestionStatusFieldUpdateOperationsInput | $Enums.SuggestionStatus
    recommended?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSelectionCreateManyCodeSuggestionInput = {
    id?: string
    encounterId: string
    code: string
    codeType: string
    category: $Enums.SuggestionCategory
    action: $Enums.SelectionAction
    decisionReason?: string | null
    actorId?: string | null
    createdAt?: Date | string
  }

  export type CodeSelectionUpdateWithoutCodeSuggestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    action?: EnumSelectionActionFieldUpdateOperationsInput | $Enums.SelectionAction
    decisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutCodeSelectionsNestedInput
    actor?: UserUpdateOneWithoutCodeSelectionsNestedInput
  }

  export type CodeSelectionUncheckedUpdateWithoutCodeSuggestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    action?: EnumSelectionActionFieldUpdateOperationsInput | $Enums.SelectionAction
    decisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSelectionUncheckedUpdateManyWithoutCodeSuggestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    codeType?: StringFieldUpdateOperationsInput | string
    category?: EnumSuggestionCategoryFieldUpdateOperationsInput | $Enums.SuggestionCategory
    action?: EnumSelectionActionFieldUpdateOperationsInput | $Enums.SelectionAction
    decisionReason?: NullableStringFieldUpdateOperationsInput | string | null
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WizardStepStateCreateManyWizardRunInput = {
    id?: string
    encounterId: string
    step: $Enums.WizardStep
    status?: $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    lastActorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WizardStepStateUpdateWithoutWizardRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: EnumWizardStepFieldUpdateOperationsInput | $Enums.WizardStep
    status?: EnumWizardStepStatusFieldUpdateOperationsInput | $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutWizardStepStatesNestedInput
    lastActor?: UserUpdateOneWithoutWizardStepStatesNestedInput
  }

  export type WizardStepStateUncheckedUpdateWithoutWizardRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    step?: EnumWizardStepFieldUpdateOperationsInput | $Enums.WizardStep
    status?: EnumWizardStepStatusFieldUpdateOperationsInput | $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    lastActorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WizardStepStateUncheckedUpdateManyWithoutWizardRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    step?: EnumWizardStepFieldUpdateOperationsInput | $Enums.WizardStep
    status?: EnumWizardStepStatusFieldUpdateOperationsInput | $Enums.WizardStepStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    lastActorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}